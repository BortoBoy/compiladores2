# Generated from grammar/Grammar.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u00c2")
        buf.write("\u07eb\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\3\2\7\2")
        buf.write("\u00e0\n\2\f\2\16\2\u00e3\13\2\3\2\3\2\3\3\7\3\u00e8\n")
        buf.write("\3\f\3\16\3\u00eb\13\3\3\3\3\3\6\3\u00ef\n\3\r\3\16\3")
        buf.write("\u00f0\3\3\7\3\u00f4\n\3\f\3\16\3\u00f7\13\3\3\3\7\3\u00fa")
        buf.write("\n\3\f\3\16\3\u00fd\13\3\3\4\3\4\3\4\5\4\u0102\n\4\5\4")
        buf.write("\u0104\n\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4\u011d")
        buf.write("\n\4\3\5\3\5\3\5\3\5\3\5\5\5\u0124\n\5\3\5\3\5\3\5\3\5")
        buf.write("\3\5\5\5\u012b\n\5\3\5\3\5\3\5\3\5\5\5\u0131\n\5\3\5\3")
        buf.write("\5\5\5\u0135\n\5\3\5\5\5\u0138\n\5\3\6\3\6\3\6\3\6\3\6")
        buf.write("\5\6\u013f\n\6\3\6\5\6\u0142\n\6\3\7\3\7\5\7\u0146\n\7")
        buf.write("\3\7\3\7\3\7\3\7\3\b\3\b\5\b\u014e\n\b\3\b\3\b\5\b\u0152")
        buf.write("\n\b\5\b\u0154\n\b\3\t\3\t\5\t\u0158\n\t\3\n\3\n\5\n\u015c")
        buf.write("\n\n\3\n\3\n\5\n\u0160\n\n\3\n\5\n\u0163\n\n\3\13\3\13")
        buf.write("\3\13\3\f\3\f\5\f\u016a\n\f\3\f\3\f\3\r\3\r\5\r\u0170")
        buf.write("\n\r\3\r\3\r\3\r\3\r\5\r\u0176\n\r\3\r\3\r\3\r\5\r\u017b")
        buf.write("\n\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\7\r\u0184\n\r\f\r\16")
        buf.write("\r\u0187\13\r\3\r\3\r\3\r\5\r\u018c\n\r\3\16\3\16\5\16")
        buf.write("\u0190\n\16\3\16\3\16\5\16\u0194\n\16\3\16\5\16\u0197")
        buf.write("\n\16\3\17\3\17\5\17\u019b\n\17\3\17\3\17\3\17\3\17\5")
        buf.write("\17\u01a1\n\17\3\17\3\17\3\17\5\17\u01a6\n\17\3\17\3\17")
        buf.write("\3\17\3\17\3\17\7\17\u01ad\n\17\f\17\16\17\u01b0\13\17")
        buf.write("\3\17\3\17\7\17\u01b4\n\17\f\17\16\17\u01b7\13\17\3\17")
        buf.write("\3\17\3\17\5\17\u01bc\n\17\3\17\3\17\5\17\u01c0\n\17\3")
        buf.write("\20\3\20\5\20\u01c4\n\20\3\20\7\20\u01c7\n\20\f\20\16")
        buf.write("\20\u01ca\13\20\3\21\6\21\u01cd\n\21\r\21\16\21\u01ce")
        buf.write("\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\5\21")
        buf.write("\u01db\n\21\3\22\3\22\5\22\u01df\n\22\3\22\3\22\3\22\5")
        buf.write("\22\u01e4\n\22\3\22\5\22\u01e7\n\22\3\22\5\22\u01ea\n")
        buf.write("\22\3\22\3\22\3\22\5\22\u01ef\n\22\3\22\5\22\u01f2\n\22")
        buf.write("\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22\3\22")
        buf.write("\3\22\5\22\u0200\n\22\3\22\3\22\3\22\3\22\3\22\5\22\u0207")
        buf.write("\n\22\3\22\3\22\3\22\3\22\3\22\5\22\u020e\n\22\5\22\u0210")
        buf.write("\n\22\3\23\5\23\u0213\n\23\3\23\3\23\3\24\3\24\5\24\u0219")
        buf.write("\n\24\3\24\3\24\3\24\5\24\u021e\n\24\3\24\3\24\3\24\3")
        buf.write("\24\7\24\u0224\n\24\f\24\16\24\u0227\13\24\3\24\3\24\5")
        buf.write("\24\u022b\n\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24\3\24")
        buf.write("\3\24\3\24\3\24\7\24\u0238\n\24\f\24\16\24\u023b\13\24")
        buf.write("\3\24\3\24\3\24\5\24\u0240\n\24\3\25\3\25\3\25\3\25\3")
        buf.write("\25\3\25\7\25\u0248\n\25\f\25\16\25\u024b\13\25\3\25\3")
        buf.write("\25\5\25\u024f\n\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\5\25\u0259\n\25\3\25\3\25\7\25\u025d\n\25\f\25\16")
        buf.write("\25\u0260\13\25\3\25\5\25\u0263\n\25\3\25\3\25\3\25\5")
        buf.write("\25\u0268\n\25\5\25\u026a\n\25\3\26\3\26\3\26\3\26\3\27")
        buf.write("\3\27\5\27\u0272\n\27\3\27\3\27\3\27\3\27\5\27\u0278\n")
        buf.write("\27\3\27\3\27\3\27\5\27\u027d\n\27\3\27\3\27\3\27\3\27")
        buf.write("\3\27\5\27\u0284\n\27\3\27\3\27\3\27\3\27\3\27\3\27\3")
        buf.write("\27\7\27\u028d\n\27\f\27\16\27\u0290\13\27\5\27\u0292")
        buf.write("\n\27\5\27\u0294\n\27\3\27\3\27\3\27\3\27\3\27\5\27\u029b")
        buf.write("\n\27\3\27\3\27\5\27\u029f\n\27\3\27\3\27\3\27\3\27\3")
        buf.write("\27\5\27\u02a6\n\27\3\27\3\27\6\27\u02aa\n\27\r\27\16")
        buf.write("\27\u02ab\3\27\3\27\3\30\3\30\5\30\u02b2\n\30\3\30\3\30")
        buf.write("\3\30\3\30\5\30\u02b8\n\30\3\30\3\30\3\30\5\30\u02bd\n")
        buf.write("\30\3\30\3\30\3\30\3\30\3\30\7\30\u02c4\n\30\f\30\16\30")
        buf.write("\u02c7\13\30\3\30\3\30\5\30\u02cb\n\30\3\30\3\30\3\30")
        buf.write("\3\31\3\31\3\31\3\31\3\31\3\31\5\31\u02d6\n\31\3\31\3")
        buf.write("\31\3\31\5\31\u02db\n\31\3\31\3\31\3\31\3\31\3\31\3\31")
        buf.write("\3\31\7\31\u02e4\n\31\f\31\16\31\u02e7\13\31\3\31\3\31")
        buf.write("\5\31\u02eb\n\31\3\32\3\32\5\32\u02ef\n\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\7\32")
        buf.write("\u02fd\n\32\f\32\16\32\u0300\13\32\3\33\3\33\3\33\3\33")
        buf.write("\3\33\7\33\u0307\n\33\f\33\16\33\u030a\13\33\3\33\3\33")
        buf.write("\5\33\u030e\n\33\3\34\3\34\3\34\3\34\3\34\3\34\5\34\u0316")
        buf.write("\n\34\3\34\3\34\3\34\3\35\3\35\3\35\3\35\3\35\7\35\u0320")
        buf.write("\n\35\f\35\16\35\u0323\13\35\3\35\3\35\5\35\u0327\n\35")
        buf.write("\3\35\3\35\3\35\3\35\3\35\3\36\5\36\u032f\n\36\3\36\3")
        buf.write("\36\3\36\3\36\3\36\5\36\u0336\n\36\3\37\5\37\u0339\n\37")
        buf.write("\3\37\3\37\3\37\3\37\3\37\5\37\u0340\n\37\3\37\5\37\u0343")
        buf.write("\n\37\3\37\5\37\u0346\n\37\3 \3 \5 \u034a\n \3 \3 \3!")
        buf.write("\3!\3!\3!\3!\3!\5!\u0354\n!\3!\3!\3!\5!\u0359\n!\3!\3")
        buf.write("!\3!\3!\3!\3!\3!\5!\u0362\n!\3!\3!\3!\7!\u0367\n!\f!\16")
        buf.write("!\u036a\13!\3!\5!\u036d\n!\3!\3!\5!\u0371\n!\3!\5!\u0374")
        buf.write("\n!\3!\3!\3!\3!\7!\u037a\n!\f!\16!\u037d\13!\3!\3!\3!")
        buf.write("\3!\3!\3!\3!\3!\3!\3!\5!\u0389\n!\3!\5!\u038c\n!\3!\3")
        buf.write("!\3!\3!\3!\3!\5!\u0394\n!\3!\3!\3!\3!\3!\6!\u039b\n!\r")
        buf.write("!\16!\u039c\3!\3!\5!\u03a1\n!\3!\3!\3!\5!\u03a6\n!\3!")
        buf.write("\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3")
        buf.write("!\3!\3!\3!\3!\3!\3!\3!\3!\3!\5!\u03c4\n!\3!\3!\3!\3!\3")
        buf.write("!\3!\3!\3!\3!\3!\5!\u03d0\n!\3!\3!\3!\5!\u03d5\n!\3!\3")
        buf.write("!\3!\3!\3!\3!\3!\3!\3!\3!\5!\u03e1\n!\3!\3!\3!\3!\5!\u03e7")
        buf.write("\n!\3!\3!\3!\3!\3!\5!\u03ee\n!\3!\3!\5!\u03f2\n!\3!\3")
        buf.write("!\3!\3!\3!\3!\7!\u03fa\n!\f!\16!\u03fd\13!\5!\u03ff\n")
        buf.write("!\3!\3!\3!\3!\5!\u0405\n!\3!\3!\3!\3!\5!\u040b\n!\3!\3")
        buf.write("!\3!\3!\3!\7!\u0412\n!\f!\16!\u0415\13!\5!\u0417\n!\3")
        buf.write("!\3!\5!\u041b\n!\7!\u041d\n!\f!\16!\u0420\13!\3\"\3\"")
        buf.write("\3\"\3\"\3\"\3\"\5\"\u0428\n\"\3\"\3\"\3#\3#\3$\5$\u042f")
        buf.write("\n$\3$\3$\3$\3$\3$\5$\u0436\n$\3$\3$\3$\3$\5$\u043c\n")
        buf.write("$\3$\3$\3$\5$\u0441\n$\3$\3$\3$\3$\7$\u0447\n$\f$\16$")
        buf.write("\u044a\13$\3$\3$\5$\u044e\n$\3$\3$\3$\3$\3$\7$\u0455\n")
        buf.write("$\f$\16$\u0458\13$\3$\3$\3$\3$\3$\3$\7$\u0460\n$\f$\16")
        buf.write("$\u0463\13$\3$\3$\7$\u0467\n$\f$\16$\u046a\13$\3$\5$\u046d")
        buf.write("\n$\3$\5$\u0470\n$\3$\3$\5$\u0474\n$\3%\3%\3%\3%\3%\3")
        buf.write("%\7%\u047c\n%\f%\16%\u047f\13%\3%\3%\3%\5%\u0484\n%\5")
        buf.write("%\u0486\n%\3%\3%\3%\3%\3%\3%\5%\u048e\n%\3%\3%\3%\3%\3")
        buf.write("%\5%\u0495\n%\3%\3%\3%\7%\u049a\n%\f%\16%\u049d\13%\3")
        buf.write("%\3%\5%\u04a1\n%\5%\u04a3\n%\3&\3&\3&\3&\5&\u04a9\n&\3")
        buf.write("&\3&\3&\3&\3&\3&\3&\5&\u04b2\n&\3\'\3\'\3\'\5\'\u04b7")
        buf.write("\n\'\3(\3(\3(\3(\3(\5(\u04be\n(\3(\3(\5(\u04c2\n(\5(\u04c4")
        buf.write("\n(\3)\5)\u04c7\n)\3)\3)\3)\3)\7)\u04cd\n)\f)\16)\u04d0")
        buf.write("\13)\3)\5)\u04d3\n)\3)\5)\u04d6\n)\3*\3*\3*\3*\5*\u04dc")
        buf.write("\n*\7*\u04de\n*\f*\16*\u04e1\13*\3+\3+\5+\u04e5\n+\3+")
        buf.write("\3+\3+\7+\u04ea\n+\f+\16+\u04ed\13+\3+\3+\3+\3+\7+\u04f3")
        buf.write("\n+\f+\16+\u04f6\13+\3+\5+\u04f9\n+\5+\u04fb\n+\3+\3+")
        buf.write("\5+\u04ff\n+\3+\3+\3+\3+\3+\7+\u0506\n+\f+\16+\u0509\13")
        buf.write("+\3+\3+\5+\u050d\n+\5+\u050f\n+\3+\3+\3+\3+\3+\3+\3+\3")
        buf.write("+\3+\7+\u051a\n+\f+\16+\u051d\13+\5+\u051f\n+\3+\3+\3")
        buf.write("+\3+\3+\7+\u0526\n+\f+\16+\u0529\13+\3+\3+\3+\3+\3+\3")
        buf.write("+\7+\u0531\n+\f+\16+\u0534\13+\3+\3+\7+\u0538\n+\f+\16")
        buf.write("+\u053b\13+\5+\u053d\n+\3,\3,\3-\5-\u0542\n-\3-\3-\5-")
        buf.write("\u0546\n-\3-\5-\u0549\n-\3.\5.\u054c\n.\3.\3.\3.\5.\u0551")
        buf.write("\n.\3.\3.\5.\u0555\n.\3.\6.\u0558\n.\r.\16.\u0559\3.\5")
        buf.write(".\u055d\n.\3.\5.\u0560\n.\3/\3/\3/\5/\u0565\n/\3/\3/\5")
        buf.write("/\u0569\n/\3/\5/\u056c\n/\3/\3/\3/\3/\3/\5/\u0573\n/\3")
        buf.write("/\3/\3/\5/\u0578\n/\3/\3/\3/\3/\3/\7/\u057f\n/\f/\16/")
        buf.write("\u0582\13/\3/\3/\5/\u0586\n/\3/\5/\u0589\n/\3/\3/\3/\3")
        buf.write("/\7/\u058f\n/\f/\16/\u0592\13/\3/\5/\u0595\n/\3/\3/\3")
        buf.write("/\3/\3/\3/\5/\u059d\n/\3/\5/\u05a0\n/\5/\u05a2\n/\3\60")
        buf.write("\3\60\3\60\3\60\3\60\3\60\3\60\5\60\u05ab\n\60\3\60\5")
        buf.write("\60\u05ae\n\60\5\60\u05b0\n\60\3\61\3\61\5\61\u05b4\n")
        buf.write("\61\3\61\3\61\5\61\u05b8\n\61\3\61\3\61\5\61\u05bc\n\61")
        buf.write("\3\61\5\61\u05bf\n\61\3\62\3\62\3\62\3\62\3\62\3\62\3")
        buf.write("\62\7\62\u05c8\n\62\f\62\16\62\u05cb\13\62\3\62\3\62\5")
        buf.write("\62\u05cf\n\62\3\63\3\63\5\63\u05d3\n\63\3\63\3\63\5\63")
        buf.write("\u05d7\n\63\3\64\5\64\u05da\n\64\3\64\3\64\3\64\5\64\u05df")
        buf.write("\n\64\3\64\3\64\3\64\3\64\5\64\u05e5\n\64\3\64\3\64\3")
        buf.write("\64\3\64\3\64\5\64\u05ec\n\64\3\64\3\64\3\64\7\64\u05f1")
        buf.write("\n\64\f\64\16\64\u05f4\13\64\3\64\3\64\5\64\u05f8\n\64")
        buf.write("\3\65\3\65\3\65\3\65\7\65\u05fe\n\65\f\65\16\65\u0601")
        buf.write("\13\65\3\65\3\65\3\66\5\66\u0606\n\66\3\66\3\66\3\66\5")
        buf.write("\66\u060b\n\66\3\66\3\66\3\66\3\66\5\66\u0611\n\66\3\66")
        buf.write("\3\66\3\66\3\66\3\66\5\66\u0618\n\66\3\66\3\66\3\66\7")
        buf.write("\66\u061d\n\66\f\66\16\66\u0620\13\66\3\66\3\66\5\66\u0624")
        buf.write("\n\66\3\66\5\66\u0627\n\66\3\66\5\66\u062a\n\66\3\67\3")
        buf.write("\67\3\67\5\67\u062f\n\67\3\67\3\67\3\67\5\67\u0634\n\67")
        buf.write("\3\67\3\67\3\67\3\67\3\67\5\67\u063b\n\67\38\38\58\u063f")
        buf.write("\n8\38\38\58\u0643\n8\39\39\39\39\39\39\3:\3:\5:\u064d")
        buf.write("\n:\3:\3:\3:\3:\3:\7:\u0654\n:\f:\16:\u0657\13:\5:\u0659")
        buf.write("\n:\3:\3:\3:\3:\3:\7:\u0660\n:\f:\16:\u0663\13:\3:\5:")
        buf.write("\u0666\n:\3:\3:\3;\3;\3;\3;\5;\u066e\n;\3;\3;\3;\3;\3")
        buf.write(";\7;\u0675\n;\f;\16;\u0678\13;\5;\u067a\n;\3;\3;\3;\3")
        buf.write(";\3;\7;\u0681\n;\f;\16;\u0684\13;\5;\u0686\n;\3;\5;\u0689")
        buf.write("\n;\3;\5;\u068c\n;\3<\3<\3<\3<\3<\3<\3<\3<\5<\u0696\n")
        buf.write("<\3=\3=\3=\3=\3=\3=\3=\5=\u069f\n=\3>\3>\3>\3>\3>\7>\u06a6")
        buf.write("\n>\f>\16>\u06a9\13>\3>\5>\u06ac\n>\3>\3>\3?\3?\3?\5?")
        buf.write("\u06b3\n?\3?\3?\3?\7?\u06b8\n?\f?\16?\u06bb\13?\3?\5?")
        buf.write("\u06be\n?\3?\3?\5?\u06c2\n?\3@\3@\3@\3@\3@\7@\u06c9\n")
        buf.write("@\f@\16@\u06cc\13@\3@\5@\u06cf\n@\3@\3@\5@\u06d3\n@\3")
        buf.write("@\3@\3@\5@\u06d8\n@\3A\3A\5A\u06dc\nA\3A\3A\3A\7A\u06e1")
        buf.write("\nA\fA\16A\u06e4\13A\3B\3B\3B\3B\3B\7B\u06eb\nB\fB\16")
        buf.write("B\u06ee\13B\3C\3C\3C\3C\5C\u06f4\nC\3D\3D\3D\5D\u06f9")
        buf.write("\nD\3D\5D\u06fc\nD\3D\3D\5D\u0700\nD\3E\3E\3F\3F\3F\3")
        buf.write("F\3F\3F\3F\3F\3F\3F\5F\u070e\nF\3G\3G\3G\3G\3G\3G\3G\3")
        buf.write("G\3G\3G\5G\u071a\nG\3H\3H\3H\3H\3H\3H\3H\5H\u0723\nH\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\5I\u072c\nI\3I\3I\5I\u0730\nI\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\5I\u073a\nI\3I\5I\u073d\nI\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\5I\u0746\nI\3I\3I\3I\3I\3I\3I\3I\5I\u074f")
        buf.write("\nI\3I\5I\u0752\nI\3I\3I\3I\3I\5I\u0758\nI\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u0766\nI\3I\3I\5I\u076a\n")
        buf.write("I\3I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u0775\nI\3I\3I\3I\5I\u077a")
        buf.write("\nI\3J\3J\3J\3K\3K\3K\3L\3L\3L\6L\u0785\nL\rL\16L\u0786")
        buf.write("\3M\3M\3M\6M\u078c\nM\rM\16M\u078d\3N\3N\3N\3N\3O\3O\5")
        buf.write("O\u0796\nO\3O\3O\3O\5O\u079b\nO\7O\u079d\nO\fO\16O\u07a0")
        buf.write("\13O\3P\3P\3Q\3Q\3R\3R\3S\3S\3T\3T\5T\u07ac\nT\3U\3U\3")
        buf.write("V\3V\3W\3W\3X\3X\3Y\3Y\3Z\3Z\3[\3[\3\\\3\\\3]\3]\3^\3")
        buf.write("^\3_\3_\3`\3`\3a\3a\3b\3b\3c\3c\3d\3d\3e\3e\3f\3f\3g\3")
        buf.write("g\3h\3h\3i\3i\3j\3j\3k\3k\3l\3l\3m\3m\3n\3n\3o\3o\3o\3")
        buf.write("o\3o\3o\3o\5o\u07e9\no\3o\4\u01ae\u01ce\3@p\2\4\6\b\n")
        buf.write("\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64\668:<")
        buf.write(">@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084\u0086")
        buf.write("\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096\u0098")
        buf.write("\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa")
        buf.write("\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc")
        buf.write("\u00be\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce")
        buf.write("\u00d0\u00d2\u00d4\u00d6\u00d8\u00da\u00dc\2\35\5\2<<")
        buf.write("GGTT\4\2\61\61DD\3\2\u0086\u0087\4\2\u0093\u0093\u00ac")
        buf.write("\u00ac\3\2\n\13\4\2==\u008e\u008e\4\2::jj\4\2<<TT\7\2")
        buf.write("\33\33JJSS||\177\177\4\2\t\t\16\17\3\2\20\23\3\2\24\27")
        buf.write("\6\2OOcceexx\5\2\33\33JJ\177\177\7\2\668jj\u00ad\u00ae")
        buf.write("\u00bb\u00bb\u00bd\u00be\4\2\37\37@@\5\2\u0081\u0081\u009b")
        buf.write("\u009b\u00b4\u00b4\4\2\7\7ll\3\2\u00b1\u00b2\4\2$$>>\4")
        buf.write("\2\u0098\u0098\u00a3\u00a3\4\2\u00a0\u00a0\u00a7\u00a7")
        buf.write("\4\2\u00a1\u00a1\u00a8\u00a9\4\2\u00a2\u00a2\u00a4\u00a4")
        buf.write("\4\2\n\fhh\4\2\u00ba\u00ba\u00bd\u00bd\3\2\33\u00b5\2")
        buf.write("\u08fd\2\u00e1\3\2\2\2\4\u00e9\3\2\2\2\6\u0103\3\2\2\2")
        buf.write("\b\u011e\3\2\2\2\n\u0139\3\2\2\2\f\u0143\3\2\2\2\16\u014b")
        buf.write("\3\2\2\2\20\u0155\3\2\2\2\22\u0159\3\2\2\2\24\u0164\3")
        buf.write("\2\2\2\26\u0167\3\2\2\2\30\u016d\3\2\2\2\32\u018f\3\2")
        buf.write("\2\2\34\u0198\3\2\2\2\36\u01c1\3\2\2\2 \u01cc\3\2\2\2")
        buf.write("\"\u01de\3\2\2\2$\u0212\3\2\2\2&\u0218\3\2\2\2(\u0241")
        buf.write("\3\2\2\2*\u026b\3\2\2\2,\u026f\3\2\2\2.\u02af\3\2\2\2")
        buf.write("\60\u02cf\3\2\2\2\62\u02ec\3\2\2\2\64\u0301\3\2\2\2\66")
        buf.write("\u030f\3\2\2\28\u031a\3\2\2\2:\u032e\3\2\2\2<\u0338\3")
        buf.write("\2\2\2>\u0347\3\2\2\2@\u03a5\3\2\2\2B\u0421\3\2\2\2D\u042b")
        buf.write("\3\2\2\2F\u0473\3\2\2\2H\u0475\3\2\2\2J\u04a4\3\2\2\2")
        buf.write("L\u04b6\3\2\2\2N\u04b8\3\2\2\2P\u04c6\3\2\2\2R\u04d7\3")
        buf.write("\2\2\2T\u053c\3\2\2\2V\u053e\3\2\2\2X\u0541\3\2\2\2Z\u054b")
        buf.write("\3\2\2\2\\\u05a1\3\2\2\2^\u05af\3\2\2\2`\u05be\3\2\2\2")
        buf.write("b\u05ce\3\2\2\2d\u05d6\3\2\2\2f\u05d9\3\2\2\2h\u05f9\3")
        buf.write("\2\2\2j\u0605\3\2\2\2l\u062e\3\2\2\2n\u063c\3\2\2\2p\u0644")
        buf.write("\3\2\2\2r\u064a\3\2\2\2t\u0669\3\2\2\2v\u068d\3\2\2\2")
        buf.write("x\u0697\3\2\2\2z\u06a0\3\2\2\2|\u06af\3\2\2\2~\u06c3\3")
        buf.write("\2\2\2\u0080\u06d9\3\2\2\2\u0082\u06e5\3\2\2\2\u0084\u06ef")
        buf.write("\3\2\2\2\u0086\u06f5\3\2\2\2\u0088\u0701\3\2\2\2\u008a")
        buf.write("\u070d\3\2\2\2\u008c\u0719\3\2\2\2\u008e\u0722\3\2\2\2")
        buf.write("\u0090\u0779\3\2\2\2\u0092\u077b\3\2\2\2\u0094\u077e\3")
        buf.write("\2\2\2\u0096\u0781\3\2\2\2\u0098\u0788\3\2\2\2\u009a\u078f")
        buf.write("\3\2\2\2\u009c\u0793\3\2\2\2\u009e\u07a1\3\2\2\2\u00a0")
        buf.write("\u07a3\3\2\2\2\u00a2\u07a5\3\2\2\2\u00a4\u07a7\3\2\2\2")
        buf.write("\u00a6\u07ab\3\2\2\2\u00a8\u07ad\3\2\2\2\u00aa\u07af\3")
        buf.write("\2\2\2\u00ac\u07b1\3\2\2\2\u00ae\u07b3\3\2\2\2\u00b0\u07b5")
        buf.write("\3\2\2\2\u00b2\u07b7\3\2\2\2\u00b4\u07b9\3\2\2\2\u00b6")
        buf.write("\u07bb\3\2\2\2\u00b8\u07bd\3\2\2\2\u00ba\u07bf\3\2\2\2")
        buf.write("\u00bc\u07c1\3\2\2\2\u00be\u07c3\3\2\2\2\u00c0\u07c5\3")
        buf.write("\2\2\2\u00c2\u07c7\3\2\2\2\u00c4\u07c9\3\2\2\2\u00c6\u07cb")
        buf.write("\3\2\2\2\u00c8\u07cd\3\2\2\2\u00ca\u07cf\3\2\2\2\u00cc")
        buf.write("\u07d1\3\2\2\2\u00ce\u07d3\3\2\2\2\u00d0\u07d5\3\2\2\2")
        buf.write("\u00d2\u07d7\3\2\2\2\u00d4\u07d9\3\2\2\2\u00d6\u07db\3")
        buf.write("\2\2\2\u00d8\u07dd\3\2\2\2\u00da\u07df\3\2\2\2\u00dc\u07e8")
        buf.write("\3\2\2\2\u00de\u00e0\5\4\3\2\u00df\u00de\3\2\2\2\u00e0")
        buf.write("\u00e3\3\2\2\2\u00e1\u00df\3\2\2\2\u00e1\u00e2\3\2\2\2")
        buf.write("\u00e2\u00e4\3\2\2\2\u00e3\u00e1\3\2\2\2\u00e4\u00e5\7")
        buf.write("\2\2\3\u00e5\3\3\2\2\2\u00e6\u00e8\7\3\2\2\u00e7\u00e6")
        buf.write("\3\2\2\2\u00e8\u00eb\3\2\2\2\u00e9\u00e7\3\2\2\2\u00e9")
        buf.write("\u00ea\3\2\2\2\u00ea\u00ec\3\2\2\2\u00eb\u00e9\3\2\2\2")
        buf.write("\u00ec\u00f5\5\6\4\2\u00ed\u00ef\7\3\2\2\u00ee\u00ed\3")
        buf.write("\2\2\2\u00ef\u00f0\3\2\2\2\u00f0\u00ee\3\2\2\2\u00f0\u00f1")
        buf.write("\3\2\2\2\u00f1\u00f2\3\2\2\2\u00f2\u00f4\5\6\4\2\u00f3")
        buf.write("\u00ee\3\2\2\2\u00f4\u00f7\3\2\2\2\u00f5\u00f3\3\2\2\2")
        buf.write("\u00f5\u00f6\3\2\2\2\u00f6\u00fb\3\2\2\2\u00f7\u00f5\3")
        buf.write("\2\2\2\u00f8\u00fa\7\3\2\2\u00f9\u00f8\3\2\2\2\u00fa\u00fd")
        buf.write("\3\2\2\2\u00fb\u00f9\3\2\2\2\u00fb\u00fc\3\2\2\2\u00fc")
        buf.write("\5\3\2\2\2\u00fd\u00fb\3\2\2\2\u00fe\u0101\7I\2\2\u00ff")
        buf.write("\u0100\7t\2\2\u0100\u0102\7q\2\2\u0101\u00ff\3\2\2\2\u0101")
        buf.write("\u0102\3\2\2\2\u0102\u0104\3\2\2\2\u0103\u00fe\3\2\2\2")
        buf.write("\u0103\u0104\3\2\2\2\u0104\u011c\3\2\2\2\u0105\u011d\5")
        buf.write("\b\5\2\u0106\u011d\5\n\6\2\u0107\u011d\5\f\7\2\u0108\u011d")
        buf.write("\5\16\b\2\u0109\u011d\5\20\t\2\u010a\u011d\5\30\r\2\u010b")
        buf.write("\u011d\5\34\17\2\u010c\u011d\5,\27\2\u010d\u011d\5.\30")
        buf.write("\2\u010e\u011d\5\60\31\2\u010f\u011d\5:\36\2\u0110\u011d")
        buf.write("\5<\37\2\u0111\u011d\5> \2\u0112\u011d\5F$\2\u0113\u011d")
        buf.write("\5J&\2\u0114\u011d\5N(\2\u0115\u011d\5\26\f\2\u0116\u011d")
        buf.write("\5\22\n\2\u0117\u011d\5\24\13\2\u0118\u011d\5P)\2\u0119")
        buf.write("\u011d\5f\64\2\u011a\u011d\5j\66\2\u011b\u011d\5n8\2\u011c")
        buf.write("\u0105\3\2\2\2\u011c\u0106\3\2\2\2\u011c\u0107\3\2\2\2")
        buf.write("\u011c\u0108\3\2\2\2\u011c\u0109\3\2\2\2\u011c\u010a\3")
        buf.write("\2\2\2\u011c\u010b\3\2\2\2\u011c\u010c\3\2\2\2\u011c\u010d")
        buf.write("\3\2\2\2\u011c\u010e\3\2\2\2\u011c\u010f\3\2\2\2\u011c")
        buf.write("\u0110\3\2\2\2\u011c\u0111\3\2\2\2\u011c\u0112\3\2\2\2")
        buf.write("\u011c\u0113\3\2\2\2\u011c\u0114\3\2\2\2\u011c\u0115\3")
        buf.write("\2\2\2\u011c\u0116\3\2\2\2\u011c\u0117\3\2\2\2\u011c\u0118")
        buf.write("\3\2\2\2\u011c\u0119\3\2\2\2\u011c\u011a\3\2\2\2\u011c")
        buf.write("\u011b\3\2\2\2\u011d\7\3\2\2\2\u011e\u011f\7 \2\2\u011f")
        buf.write("\u0123\7\u0085\2\2\u0120\u0121\5\u00b0Y\2\u0121\u0122")
        buf.write("\7\4\2\2\u0122\u0124\3\2\2\2\u0123\u0120\3\2\2\2\u0123")
        buf.write("\u0124\3\2\2\2\u0124\u0125\3\2\2\2\u0125\u0137\5\u00b2")
        buf.write("Z\2\u0126\u0130\7{\2\2\u0127\u0128\7\u0089\2\2\u0128\u0131")
        buf.write("\5\u00b6\\\2\u0129\u012b\7\60\2\2\u012a\u0129\3\2\2\2")
        buf.write("\u012a\u012b\3\2\2\2\u012b\u012c\3\2\2\2\u012c\u012d\5")
        buf.write("\u00b8]\2\u012d\u012e\7\u0089\2\2\u012e\u012f\5\u00b8")
        buf.write("]\2\u012f\u0131\3\2\2\2\u0130\u0127\3\2\2\2\u0130\u012a")
        buf.write("\3\2\2\2\u0131\u0138\3\2\2\2\u0132\u0134\7\35\2\2\u0133")
        buf.write("\u0135\7\60\2\2\u0134\u0133\3\2\2\2\u0134\u0135\3\2\2")
        buf.write("\2\u0135\u0136\3\2\2\2\u0136\u0138\5\36\20\2\u0137\u0126")
        buf.write("\3\2\2\2\u0137\u0132\3\2\2\2\u0138\t\3\2\2\2\u0139\u0141")
        buf.write("\7!\2\2\u013a\u0142\5\u00b0Y\2\u013b\u013c\5\u00b0Y\2")
        buf.write("\u013c\u013d\7\4\2\2\u013d\u013f\3\2\2\2\u013e\u013b\3")
        buf.write("\2\2\2\u013e\u013f\3\2\2\2\u013f\u0140\3\2\2\2\u0140\u0142")
        buf.write("\5\u00b4[\2\u0141\u013a\3\2\2\2\u0141\u013e\3\2\2\2\u0141")
        buf.write("\u0142\3\2\2\2\u0142\13\3\2\2\2\u0143\u0145\7%\2\2\u0144")
        buf.write("\u0146\79\2\2\u0145\u0144\3\2\2\2\u0145\u0146\3\2\2\2")
        buf.write("\u0146\u0147\3\2\2\2\u0147\u0148\5@!\2\u0148\u0149\7#")
        buf.write("\2\2\u0149\u014a\5\u00b0Y\2\u014a\r\3\2\2\2\u014b\u014d")
        buf.write("\7(\2\2\u014c\u014e\t\2\2\2\u014d\u014c\3\2\2\2\u014d")
        buf.write("\u014e\3\2\2\2\u014e\u0153\3\2\2\2\u014f\u0151\7\u008a")
        buf.write("\2\2\u0150\u0152\5\u00ccg\2\u0151\u0150\3\2\2\2\u0151")
        buf.write("\u0152\3\2\2\2\u0152\u0154\3\2\2\2\u0153\u014f\3\2\2\2")
        buf.write("\u0153\u0154\3\2\2\2\u0154\17\3\2\2\2\u0155\u0157\t\3")
        buf.write("\2\2\u0156\u0158\7\u008a\2\2\u0157\u0156\3\2\2\2\u0157")
        buf.write("\u0158\3\2\2\2\u0158\21\3\2\2\2\u0159\u015b\7\177\2\2")
        buf.write("\u015a\u015c\7\u008a\2\2\u015b\u015a\3\2\2\2\u015b\u015c")
        buf.write("\3\2\2\2\u015c\u0162\3\2\2\2\u015d\u015f\7\u0089\2\2\u015e")
        buf.write("\u0160\7\u0082\2\2\u015f\u015e\3\2\2\2\u015f\u0160\3\2")
        buf.write("\2\2\u0160\u0161\3\2\2\2\u0161\u0163\5\u00c8e\2\u0162")
        buf.write("\u015d\3\2\2\2\u0162\u0163\3\2\2\2\u0163\23\3\2\2\2\u0164")
        buf.write("\u0165\7\u0082\2\2\u0165\u0166\5\u00c8e\2\u0166\25\3\2")
        buf.write("\2\2\u0167\u0169\7z\2\2\u0168\u016a\7\u0082\2\2\u0169")
        buf.write("\u0168\3\2\2\2\u0169\u016a\3\2\2\2\u016a\u016b\3\2\2\2")
        buf.write("\u016b\u016c\5\u00c8e\2\u016c\27\3\2\2\2\u016d\u016f\7")
        buf.write("\64\2\2\u016e\u0170\7\u008d\2\2\u016f\u016e\3\2\2\2\u016f")
        buf.write("\u0170\3\2\2\2\u0170\u0171\3\2\2\2\u0171\u0175\7V\2\2")
        buf.write("\u0172\u0173\7R\2\2\u0173\u0174\7h\2\2\u0174\u0176\7H")
        buf.write("\2\2\u0175\u0172\3\2\2\2\u0175\u0176\3\2\2\2\u0176\u017a")
        buf.write("\3\2\2\2\u0177\u0178\5\u00b0Y\2\u0178\u0179\7\4\2\2\u0179")
        buf.write("\u017b\3\2\2\2\u017a\u0177\3\2\2\2\u017a\u017b\3\2\2\2")
        buf.write("\u017b\u017c\3\2\2\2\u017c\u017d\5\u00be`\2\u017d\u017e")
        buf.write("\7m\2\2\u017e\u017f\5\u00b2Z\2\u017f\u0180\7\5\2\2\u0180")
        buf.write("\u0185\5\32\16\2\u0181\u0182\7\7\2\2\u0182\u0184\5\32")
        buf.write("\16\2\u0183\u0181\3\2\2\2\u0184\u0187\3\2\2\2\u0185\u0183")
        buf.write("\3\2\2\2\u0185\u0186\3\2\2\2\u0186\u0188\3\2\2\2\u0187")
        buf.write("\u0185\3\2\2\2\u0188\u018b\7\6\2\2\u0189\u018a\7\u0095")
        buf.write("\2\2\u018a\u018c\5@!\2\u018b\u0189\3\2\2\2\u018b\u018c")
        buf.write("\3\2\2\2\u018c\31\3\2\2\2\u018d\u0190\5\u00b8]\2\u018e")
        buf.write("\u0190\5@!\2\u018f\u018d\3\2\2\2\u018f\u018e\3\2\2\2\u0190")
        buf.write("\u0193\3\2\2\2\u0191\u0192\7/\2\2\u0192\u0194\5\u00ba")
        buf.write("^\2\u0193\u0191\3\2\2\2\u0193\u0194\3\2\2\2\u0194\u0196")
        buf.write("\3\2\2\2\u0195\u0197\5\u0088E\2\u0196\u0195\3\2\2\2\u0196")
        buf.write("\u0197\3\2\2\2\u0197\33\3\2\2\2\u0198\u019a\7\64\2\2\u0199")
        buf.write("\u019b\t\4\2\2\u019a\u0199\3\2\2\2\u019a\u019b\3\2\2\2")
        buf.write("\u019b\u019c\3\2\2\2\u019c\u01a0\7\u0085\2\2\u019d\u019e")
        buf.write("\7R\2\2\u019e\u019f\7h\2\2\u019f\u01a1\7H\2\2\u01a0\u019d")
        buf.write("\3\2\2\2\u01a0\u01a1\3\2\2\2\u01a1\u01a5\3\2\2\2\u01a2")
        buf.write("\u01a3\5\u00b0Y\2\u01a3\u01a4\7\4\2\2\u01a4\u01a6\3\2")
        buf.write("\2\2\u01a5\u01a2\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6\u01a7")
        buf.write("\3\2\2\2\u01a7\u01bf\5\u00b2Z\2\u01a8\u01a9\7\5\2\2\u01a9")
        buf.write("\u01ae\5\36\20\2\u01aa\u01ab\7\7\2\2\u01ab\u01ad\5\36")
        buf.write("\20\2\u01ac\u01aa\3\2\2\2\u01ad\u01b0\3\2\2\2\u01ae\u01af")
        buf.write("\3\2\2\2\u01ae\u01ac\3\2\2\2\u01af\u01b5\3\2\2\2\u01b0")
        buf.write("\u01ae\3\2\2\2\u01b1\u01b2\7\7\2\2\u01b2\u01b4\5&\24\2")
        buf.write("\u01b3\u01b1\3\2\2\2\u01b4\u01b7\3\2\2\2\u01b5\u01b3\3")
        buf.write("\2\2\2\u01b5\u01b6\3\2\2\2\u01b6\u01b8\3\2\2\2\u01b7\u01b5")
        buf.write("\3\2\2\2\u01b8\u01bb\7\6\2\2\u01b9\u01ba\7\u0097\2\2\u01ba")
        buf.write("\u01bc\7\u00ba\2\2\u01bb\u01b9\3\2\2\2\u01bb\u01bc\3\2")
        buf.write("\2\2\u01bc\u01c0\3\2\2\2\u01bd\u01be\7#\2\2\u01be\u01c0")
        buf.write("\5P)\2\u01bf\u01a8\3\2\2\2\u01bf\u01bd\3\2\2\2\u01c0\35")
        buf.write("\3\2\2\2\u01c1\u01c3\5\u00b8]\2\u01c2\u01c4\5 \21\2\u01c3")
        buf.write("\u01c2\3\2\2\2\u01c3\u01c4\3\2\2\2\u01c4\u01c8\3\2\2\2")
        buf.write("\u01c5\u01c7\5\"\22\2\u01c6\u01c5\3\2\2\2\u01c7\u01ca")
        buf.write("\3\2\2\2\u01c8\u01c6\3\2\2\2\u01c8\u01c9\3\2\2\2\u01c9")
        buf.write("\37\3\2\2\2\u01ca\u01c8\3\2\2\2\u01cb\u01cd\5\u00acW\2")
        buf.write("\u01cc\u01cb\3\2\2\2\u01cd\u01ce\3\2\2\2\u01ce\u01cf\3")
        buf.write("\2\2\2\u01ce\u01cc\3\2\2\2\u01cf\u01da\3\2\2\2\u01d0\u01d1")
        buf.write("\7\5\2\2\u01d1\u01d2\5$\23\2\u01d2\u01d3\7\6\2\2\u01d3")
        buf.write("\u01db\3\2\2\2\u01d4\u01d5\7\5\2\2\u01d5\u01d6\5$\23\2")
        buf.write("\u01d6\u01d7\7\7\2\2\u01d7\u01d8\5$\23\2\u01d8\u01d9\7")
        buf.write("\6\2\2\u01d9\u01db\3\2\2\2\u01da\u01d0\3\2\2\2\u01da\u01d4")
        buf.write("\3\2\2\2\u01da\u01db\3\2\2\2\u01db!\3\2\2\2\u01dc\u01dd")
        buf.write("\7\63\2\2\u01dd\u01df\5\u00acW\2\u01de\u01dc\3\2\2\2\u01de")
        buf.write("\u01df\3\2\2\2\u01df\u020f\3\2\2\2\u01e0\u01e1\7s\2\2")
        buf.write("\u01e1\u01e3\7a\2\2\u01e2\u01e4\5\u0088E\2\u01e3\u01e2")
        buf.write("\3\2\2\2\u01e3\u01e4\3\2\2\2\u01e4\u01e6\3\2\2\2\u01e5")
        buf.write("\u01e7\5*\26\2\u01e6\u01e5\3\2\2\2\u01e6\u01e7\3\2\2\2")
        buf.write("\u01e7\u01e9\3\2\2\2\u01e8\u01ea\7&\2\2\u01e9\u01e8\3")
        buf.write("\2\2\2\u01e9\u01ea\3\2\2\2\u01ea\u0210\3\2\2\2\u01eb\u01ec")
        buf.write("\7h\2\2\u01ec\u01ef\7j\2\2\u01ed\u01ef\7\u008d\2\2\u01ee")
        buf.write("\u01eb\3\2\2\2\u01ee\u01ed\3\2\2\2\u01ef\u01f1\3\2\2\2")
        buf.write("\u01f0\u01f2\5*\26\2\u01f1\u01f0\3\2\2\2\u01f1\u01f2\3")
        buf.write("\2\2\2\u01f2\u0210\3\2\2\2\u01f3\u01f4\7.\2\2\u01f4\u01f5")
        buf.write("\7\5\2\2\u01f5\u01f6\5@!\2\u01f6\u01f7\7\6\2\2\u01f7\u0210")
        buf.write("\3\2\2\2\u01f8\u01ff\7:\2\2\u01f9\u0200\5$\23\2\u01fa")
        buf.write("\u0200\5D#\2\u01fb\u01fc\7\5\2\2\u01fc\u01fd\5@!\2\u01fd")
        buf.write("\u01fe\7\6\2\2\u01fe\u0200\3\2\2\2\u01ff\u01f9\3\2\2\2")
        buf.write("\u01ff\u01fa\3\2\2\2\u01ff\u01fb\3\2\2\2\u0200\u0210\3")
        buf.write("\2\2\2\u0201\u0202\7/\2\2\u0202\u0210\5\u00ba^\2\u0203")
        buf.write("\u0210\5(\25\2\u0204\u0205\7\u00aa\2\2\u0205\u0207\7\u00ab")
        buf.write("\2\2\u0206\u0204\3\2\2\2\u0206\u0207\3\2\2\2\u0207\u0208")
        buf.write("\3\2\2\2\u0208\u0209\7#\2\2\u0209\u020a\7\5\2\2\u020a")
        buf.write("\u020b\5@!\2\u020b\u020d\7\6\2\2\u020c\u020e\t\5\2\2\u020d")
        buf.write("\u020c\3\2\2\2\u020d\u020e\3\2\2\2\u020e\u0210\3\2\2\2")
        buf.write("\u020f\u01e0\3\2\2\2\u020f\u01ee\3\2\2\2\u020f\u01f3\3")
        buf.write("\2\2\2\u020f\u01f8\3\2\2\2\u020f\u0201\3\2\2\2\u020f\u0203")
        buf.write("\3\2\2\2\u020f\u0206\3\2\2\2\u0210#\3\2\2\2\u0211\u0213")
        buf.write("\t\6\2\2\u0212\u0211\3\2\2\2\u0212\u0213\3\2\2\2\u0213")
        buf.write("\u0214\3\2\2\2\u0214\u0215\7\u00bb\2\2\u0215%\3\2\2\2")
        buf.write("\u0216\u0217\7\63\2\2\u0217\u0219\5\u00acW\2\u0218\u0216")
        buf.write("\3\2\2\2\u0218\u0219\3\2\2\2\u0219\u023f\3\2\2\2\u021a")
        buf.write("\u021b\7s\2\2\u021b\u021e\7a\2\2\u021c\u021e\7\u008d\2")
        buf.write("\2\u021d\u021a\3\2\2\2\u021d\u021c\3\2\2\2\u021e\u021f")
        buf.write("\3\2\2\2\u021f\u0220\7\5\2\2\u0220\u0225\5\32\16\2\u0221")
        buf.write("\u0222\7\7\2\2\u0222\u0224\5\32\16\2\u0223\u0221\3\2\2")
        buf.write("\2\u0224\u0227\3\2\2\2\u0225\u0223\3\2\2\2\u0225\u0226")
        buf.write("\3\2\2\2\u0226\u0228\3\2\2\2\u0227\u0225\3\2\2\2\u0228")
        buf.write("\u022a\7\6\2\2\u0229\u022b\5*\26\2\u022a\u0229\3\2\2\2")
        buf.write("\u022a\u022b\3\2\2\2\u022b\u0240\3\2\2\2\u022c\u022d\7")
        buf.write(".\2\2\u022d\u022e\7\5\2\2\u022e\u022f\5@!\2\u022f\u0230")
        buf.write("\7\6\2\2\u0230\u0240\3\2\2\2\u0231\u0232\7L\2\2\u0232")
        buf.write("\u0233\7a\2\2\u0233\u0234\7\5\2\2\u0234\u0239\5\u00b8")
        buf.write("]\2\u0235\u0236\7\7\2\2\u0236\u0238\5\u00b8]\2\u0237\u0235")
        buf.write("\3\2\2\2\u0238\u023b\3\2\2\2\u0239\u0237\3\2\2\2\u0239")
        buf.write("\u023a\3\2\2\2\u023a\u023c\3\2\2\2\u023b\u0239\3\2\2\2")
        buf.write("\u023c\u023d\7\6\2\2\u023d\u023e\5(\25\2\u023e\u0240\3")
        buf.write("\2\2\2\u023f\u021d\3\2\2\2\u023f\u022c\3\2\2\2\u023f\u0231")
        buf.write("\3\2\2\2\u0240\'\3\2\2\2\u0241\u0242\7w\2\2\u0242\u024e")
        buf.write("\5\u00bc_\2\u0243\u0244\7\5\2\2\u0244\u0249\5\u00b8]\2")
        buf.write("\u0245\u0246\7\7\2\2\u0246\u0248\5\u00b8]\2\u0247\u0245")
        buf.write("\3\2\2\2\u0248\u024b\3\2\2\2\u0249\u0247\3\2\2\2\u0249")
        buf.write("\u024a\3\2\2\2\u024a\u024c\3\2\2\2\u024b\u0249\3\2\2\2")
        buf.write("\u024c\u024d\7\6\2\2\u024d\u024f\3\2\2\2\u024e\u0243\3")
        buf.write("\2\2\2\u024e\u024f\3\2\2\2\u024f\u025e\3\2\2\2\u0250\u0251")
        buf.write("\7m\2\2\u0251\u0258\t\7\2\2\u0252\u0253\7\u0084\2\2\u0253")
        buf.write("\u0259\t\b\2\2\u0254\u0259\7+\2\2\u0255\u0259\7}\2\2\u0256")
        buf.write("\u0257\7g\2\2\u0257\u0259\7\34\2\2\u0258\u0252\3\2\2\2")
        buf.write("\u0258\u0254\3\2\2\2\u0258\u0255\3\2\2\2\u0258\u0256\3")
        buf.write("\2\2\2\u0259\u025d\3\2\2\2\u025a\u025b\7e\2\2\u025b\u025d")
        buf.write("\5\u00acW\2\u025c\u0250\3\2\2\2\u025c\u025a\3\2\2\2\u025d")
        buf.write("\u0260\3\2\2\2\u025e\u025c\3\2\2\2\u025e\u025f\3\2\2\2")
        buf.write("\u025f\u0269\3\2\2\2\u0260\u025e\3\2\2\2\u0261\u0263\7")
        buf.write("h\2\2\u0262\u0261\3\2\2\2\u0262\u0263\3\2\2\2\u0263\u0264")
        buf.write("\3\2\2\2\u0264\u0267\7;\2\2\u0265\u0266\7X\2\2\u0266\u0268")
        buf.write("\t\t\2\2\u0267\u0265\3\2\2\2\u0267\u0268\3\2\2\2\u0268")
        buf.write("\u026a\3\2\2\2\u0269\u0262\3\2\2\2\u0269\u026a\3\2\2\2")
        buf.write("\u026a)\3\2\2\2\u026b\u026c\7m\2\2\u026c\u026d\7\62\2")
        buf.write("\2\u026d\u026e\t\n\2\2\u026e+\3\2\2\2\u026f\u0271\7\64")
        buf.write("\2\2\u0270\u0272\t\4\2\2\u0271\u0270\3\2\2\2\u0271\u0272")
        buf.write("\3\2\2\2\u0272\u0273\3\2\2\2\u0273\u0277\7\u008b\2\2\u0274")
        buf.write("\u0275\7R\2\2\u0275\u0276\7h\2\2\u0276\u0278\7H\2\2\u0277")
        buf.write("\u0274\3\2\2\2\u0277\u0278\3\2\2\2\u0278\u027c\3\2\2\2")
        buf.write("\u0279\u027a\5\u00b0Y\2\u027a\u027b\7\4\2\2\u027b\u027d")
        buf.write("\3\2\2\2\u027c\u0279\3\2\2\2\u027c\u027d\3\2\2\2\u027d")
        buf.write("\u027e\3\2\2\2\u027e\u0283\5\u00c0a\2\u027f\u0284\7\'")
        buf.write("\2\2\u0280\u0284\7\36\2\2\u0281\u0282\7[\2\2\u0282\u0284")
        buf.write("\7k\2\2\u0283\u027f\3\2\2\2\u0283\u0280\3\2\2\2\u0283")
        buf.write("\u0281\3\2\2\2\u0283\u0284\3\2\2\2\u0284\u0293\3\2\2\2")
        buf.write("\u0285\u0294\7=\2\2\u0286\u0294\7Z\2\2\u0287\u0291\7\u008e")
        buf.write("\2\2\u0288\u0289\7k\2\2\u0289\u028e\5\u00b8]\2\u028a\u028b")
        buf.write("\7\7\2\2\u028b\u028d\5\u00b8]\2\u028c\u028a\3\2\2\2\u028d")
        buf.write("\u0290\3\2\2\2\u028e\u028c\3\2\2\2\u028e\u028f\3\2\2\2")
        buf.write("\u028f\u0292\3\2\2\2\u0290\u028e\3\2\2\2\u0291\u0288\3")
        buf.write("\2\2\2\u0291\u0292\3\2\2\2\u0292\u0294\3\2\2\2\u0293\u0285")
        buf.write("\3\2\2\2\u0293\u0286\3\2\2\2\u0293\u0287\3\2\2\2\u0294")
        buf.write("\u0295\3\2\2\2\u0295\u0296\7m\2\2\u0296\u029a\5\u00b2")
        buf.write("Z\2\u0297\u0298\7K\2\2\u0298\u0299\7B\2\2\u0299\u029b")
        buf.write("\7\u0080\2\2\u029a\u0297\3\2\2\2\u029a\u029b\3\2\2\2\u029b")
        buf.write("\u029e\3\2\2\2\u029c\u029d\7\u0094\2\2\u029d\u029f\5@")
        buf.write("!\2\u029e\u029c\3\2\2\2\u029e\u029f\3\2\2\2\u029f\u02a0")
        buf.write("\3\2\2\2\u02a0\u02a9\7(\2\2\u02a1\u02a6\5f\64\2\u02a2")
        buf.write("\u02a6\5F$\2\u02a3\u02a6\5:\36\2\u02a4\u02a6\5P)\2\u02a5")
        buf.write("\u02a1\3\2\2\2\u02a5\u02a2\3\2\2\2\u02a5\u02a3\3\2\2\2")
        buf.write("\u02a5\u02a4\3\2\2\2\u02a6\u02a7\3\2\2\2\u02a7\u02a8\7")
        buf.write("\3\2\2\u02a8\u02aa\3\2\2\2\u02a9\u02a5\3\2\2\2\u02aa\u02ab")
        buf.write("\3\2\2\2\u02ab\u02a9\3\2\2\2\u02ab\u02ac\3\2\2\2\u02ac")
        buf.write("\u02ad\3\2\2\2\u02ad\u02ae\7D\2\2\u02ae-\3\2\2\2\u02af")
        buf.write("\u02b1\7\64\2\2\u02b0\u02b2\t\4\2\2\u02b1\u02b0\3\2\2")
        buf.write("\2\u02b1\u02b2\3\2\2\2\u02b2\u02b3\3\2\2\2\u02b3\u02b7")
        buf.write("\7\u0092\2\2\u02b4\u02b5\7R\2\2\u02b5\u02b6\7h\2\2\u02b6")
        buf.write("\u02b8\7H\2\2\u02b7\u02b4\3\2\2\2\u02b7\u02b8\3\2\2\2")
        buf.write("\u02b8\u02bc\3\2\2\2\u02b9\u02ba\5\u00b0Y\2\u02ba\u02bb")
        buf.write("\7\4\2\2\u02bb\u02bd\3\2\2\2\u02bc\u02b9\3\2\2\2\u02bc")
        buf.write("\u02bd\3\2\2\2\u02bd\u02be\3\2\2\2\u02be\u02ca\5\u00c2")
        buf.write("b\2\u02bf\u02c0\7\5\2\2\u02c0\u02c5\5\u00b8]\2\u02c1\u02c2")
        buf.write("\7\7\2\2\u02c2\u02c4\5\u00b8]\2\u02c3\u02c1\3\2\2\2\u02c4")
        buf.write("\u02c7\3\2\2\2\u02c5\u02c3\3\2\2\2\u02c5\u02c6\3\2\2\2")
        buf.write("\u02c6\u02c8\3\2\2\2\u02c7\u02c5\3\2\2\2\u02c8\u02c9\7")
        buf.write("\6\2\2\u02c9\u02cb\3\2\2\2\u02ca\u02bf\3\2\2\2\u02ca\u02cb")
        buf.write("\3\2\2\2\u02cb\u02cc\3\2\2\2\u02cc\u02cd\7#\2\2\u02cd")
        buf.write("\u02ce\5P)\2\u02ce/\3\2\2\2\u02cf\u02d0\7\64\2\2\u02d0")
        buf.write("\u02d1\7\u0093\2\2\u02d1\u02d5\7\u0085\2\2\u02d2\u02d3")
        buf.write("\7R\2\2\u02d3\u02d4\7h\2\2\u02d4\u02d6\7H\2\2\u02d5\u02d2")
        buf.write("\3\2\2\2\u02d5\u02d6\3\2\2\2\u02d6\u02da\3\2\2\2\u02d7")
        buf.write("\u02d8\5\u00b0Y\2\u02d8\u02d9\7\4\2\2\u02d9\u02db\3\2")
        buf.write("\2\2\u02da\u02d7\3\2\2\2\u02da\u02db\3\2\2\2\u02db\u02dc")
        buf.write("\3\2\2\2\u02dc\u02dd\5\u00b2Z\2\u02dd\u02de\7\u008f\2")
        buf.write("\2\u02de\u02ea\5\u00c4c\2\u02df\u02e0\7\5\2\2\u02e0\u02e5")
        buf.write("\5\u00a6T\2\u02e1\u02e2\7\7\2\2\u02e2\u02e4\5\u00a6T\2")
        buf.write("\u02e3\u02e1\3\2\2\2\u02e4\u02e7\3\2\2\2\u02e5\u02e3\3")
        buf.write("\2\2\2\u02e5\u02e6\3\2\2\2\u02e6\u02e8\3\2\2\2\u02e7\u02e5")
        buf.write("\3\2\2\2\u02e8\u02e9\7\6\2\2\u02e9\u02eb\3\2\2\2\u02ea")
        buf.write("\u02df\3\2\2\2\u02ea\u02eb\3\2\2\2\u02eb\61\3\2\2\2\u02ec")
        buf.write("\u02ee\7\u0096\2\2\u02ed\u02ef\7v\2\2\u02ee\u02ed\3\2")
        buf.write("\2\2\u02ee\u02ef\3\2\2\2\u02ef\u02f0\3\2\2\2\u02f0\u02f1")
        buf.write("\5\64\33\2\u02f1\u02f2\7#\2\2\u02f2\u02f3\7\5\2\2\u02f3")
        buf.write("\u02f4\5P)\2\u02f4\u02fe\7\6\2\2\u02f5\u02f6\7\7\2\2\u02f6")
        buf.write("\u02f7\5\64\33\2\u02f7\u02f8\7#\2\2\u02f8\u02f9\7\5\2")
        buf.write("\2\u02f9\u02fa\5P)\2\u02fa\u02fb\7\6\2\2\u02fb\u02fd\3")
        buf.write("\2\2\2\u02fc\u02f5\3\2\2\2\u02fd\u0300\3\2\2\2\u02fe\u02fc")
        buf.write("\3\2\2\2\u02fe\u02ff\3\2\2\2\u02ff\63\3\2\2\2\u0300\u02fe")
        buf.write("\3\2\2\2\u0301\u030d\5\u00b2Z\2\u0302\u0303\7\5\2\2\u0303")
        buf.write("\u0308\5\u00b8]\2\u0304\u0305\7\7\2\2\u0305\u0307\5\u00b8")
        buf.write("]\2\u0306\u0304\3\2\2\2\u0307\u030a\3\2\2\2\u0308\u0306")
        buf.write("\3\2\2\2\u0308\u0309\3\2\2\2\u0309\u030b\3\2\2\2\u030a")
        buf.write("\u0308\3\2\2\2\u030b\u030c\7\6\2\2\u030c\u030e\3\2\2\2")
        buf.write("\u030d\u0302\3\2\2\2\u030d\u030e\3\2\2\2\u030e\65\3\2")
        buf.write("\2\2\u030f\u0310\5\64\33\2\u0310\u0311\7#\2\2\u0311\u0312")
        buf.write("\7\5\2\2\u0312\u0313\5\u009eP\2\u0313\u0315\7\u008c\2")
        buf.write("\2\u0314\u0316\7\37\2\2\u0315\u0314\3\2\2\2\u0315\u0316")
        buf.write("\3\2\2\2\u0316\u0317\3\2\2\2\u0317\u0318\5\u00a0Q\2\u0318")
        buf.write("\u0319\7\6\2\2\u0319\67\3\2\2\2\u031a\u0326\5\u00b2Z\2")
        buf.write("\u031b\u031c\7\5\2\2\u031c\u0321\5\u00b8]\2\u031d\u031e")
        buf.write("\7\7\2\2\u031e\u0320\5\u00b8]\2\u031f\u031d\3\2\2\2\u0320")
        buf.write("\u0323\3\2\2\2\u0321\u031f\3\2\2\2\u0321\u0322\3\2\2\2")
        buf.write("\u0322\u0324\3\2\2\2\u0323\u0321\3\2\2\2\u0324\u0325\7")
        buf.write("\6\2\2\u0325\u0327\3\2\2\2\u0326\u031b\3\2\2\2\u0326\u0327")
        buf.write("\3\2\2\2\u0327\u0328\3\2\2\2\u0328\u0329\7#\2\2\u0329")
        buf.write("\u032a\7\5\2\2\u032a\u032b\5P)\2\u032b\u032c\7\6\2\2\u032c")
        buf.write("9\3\2\2\2\u032d\u032f\5\62\32\2\u032e\u032d\3\2\2\2\u032e")
        buf.write("\u032f\3\2\2\2\u032f\u0330\3\2\2\2\u0330\u0331\7=\2\2")
        buf.write("\u0331\u0332\7M\2\2\u0332\u0335\5l\67\2\u0333\u0334\7")
        buf.write("\u0095\2\2\u0334\u0336\5@!\2\u0335\u0333\3\2\2\2\u0335")
        buf.write("\u0336\3\2\2\2\u0336;\3\2\2\2\u0337\u0339\5\62\32\2\u0338")
        buf.write("\u0337\3\2\2\2\u0338\u0339\3\2\2\2\u0339\u033a\3\2\2\2")
        buf.write("\u033a\u033b\7=\2\2\u033b\u033c\7M\2\2\u033c\u033f\5l")
        buf.write("\67\2\u033d\u033e\7\u0095\2\2\u033e\u0340\5@!\2\u033f")
        buf.write("\u033d\3\2\2\2\u033f\u0340\3\2\2\2\u0340\u0345\3\2\2\2")
        buf.write("\u0341\u0343\5\u0082B\2\u0342\u0341\3\2\2\2\u0342\u0343")
        buf.write("\3\2\2\2\u0343\u0344\3\2\2\2\u0344\u0346\5\u0084C\2\u0345")
        buf.write("\u0342\3\2\2\2\u0345\u0346\3\2\2\2\u0346=\3\2\2\2\u0347")
        buf.write("\u0349\7?\2\2\u0348\u034a\79\2\2\u0349\u0348\3\2\2\2\u0349")
        buf.write("\u034a\3\2\2\2\u034a\u034b\3\2\2\2\u034b\u034c\5\u00b0")
        buf.write("Y\2\u034c?\3\2\2\2\u034d\u034e\b!\1\2\u034e\u03a6\5D#")
        buf.write("\2\u034f\u03a6\7\u00bc\2\2\u0350\u0351\5\u00b0Y\2\u0351")
        buf.write("\u0352\7\4\2\2\u0352\u0354\3\2\2\2\u0353\u0350\3\2\2\2")
        buf.write("\u0353\u0354\3\2\2\2\u0354\u0355\3\2\2\2\u0355\u0356\5")
        buf.write("\u00b2Z\2\u0356\u0357\7\4\2\2\u0357\u0359\3\2\2\2\u0358")
        buf.write("\u0353\3\2\2\2\u0358\u0359\3\2\2\2\u0359\u035a\3\2\2\2")
        buf.write("\u035a\u03a6\5\u00b8]\2\u035b\u035c\5\u00a2R\2\u035c\u035d")
        buf.write("\5@!\27\u035d\u03a6\3\2\2\2\u035e\u035f\5\u00aeX\2\u035f")
        buf.write("\u036c\7\5\2\2\u0360\u0362\7@\2\2\u0361\u0360\3\2\2\2")
        buf.write("\u0361\u0362\3\2\2\2\u0362\u0363\3\2\2\2\u0363\u0368\5")
        buf.write("@!\2\u0364\u0365\7\7\2\2\u0365\u0367\5@!\2\u0366\u0364")
        buf.write("\3\2\2\2\u0367\u036a\3\2\2\2\u0368\u0366\3\2\2\2\u0368")
        buf.write("\u0369\3\2\2\2\u0369\u036d\3\2\2\2\u036a\u0368\3\2\2\2")
        buf.write("\u036b\u036d\7\t\2\2\u036c\u0361\3\2\2\2\u036c\u036b\3")
        buf.write("\2\2\2\u036c\u036d\3\2\2\2\u036d\u036e\3\2\2\2\u036e\u0370")
        buf.write("\7\6\2\2\u036f\u0371\5p9\2\u0370\u036f\3\2\2\2\u0370\u0371")
        buf.write("\3\2\2\2\u0371\u0373\3\2\2\2\u0372\u0374\5t;\2\u0373\u0372")
        buf.write("\3\2\2\2\u0373\u0374\3\2\2\2\u0374\u03a6\3\2\2\2\u0375")
        buf.write("\u0376\7\5\2\2\u0376\u037b\5@!\2\u0377\u0378\7\7\2\2\u0378")
        buf.write("\u037a\5@!\2\u0379\u0377\3\2\2\2\u037a\u037d\3\2\2\2\u037b")
        buf.write("\u0379\3\2\2\2\u037b\u037c\3\2\2\2\u037c\u037e\3\2\2\2")
        buf.write("\u037d\u037b\3\2\2\2\u037e\u037f\7\6\2\2\u037f\u03a6\3")
        buf.write("\2\2\2\u0380\u0381\7-\2\2\u0381\u0382\7\5\2\2\u0382\u0383")
        buf.write("\5@!\2\u0383\u0384\7#\2\2\u0384\u0385\5 \21\2\u0385\u0386")
        buf.write("\7\6\2\2\u0386\u03a6\3\2\2\2\u0387\u0389\7h\2\2\u0388")
        buf.write("\u0387\3\2\2\2\u0388\u0389\3\2\2\2\u0389\u038a\3\2\2\2")
        buf.write("\u038a\u038c\7H\2\2\u038b\u0388\3\2\2\2\u038b\u038c\3")
        buf.write("\2\2\2\u038c\u038d\3\2\2\2\u038d\u038e\7\5\2\2\u038e\u038f")
        buf.write("\5P)\2\u038f\u0390\7\6\2\2\u0390\u03a6\3\2\2\2\u0391\u0393")
        buf.write("\7,\2\2\u0392\u0394\5@!\2\u0393\u0392\3\2\2\2\u0393\u0394")
        buf.write("\3\2\2\2\u0394\u039a\3\2\2\2\u0395\u0396\7\u0094\2\2\u0396")
        buf.write("\u0397\5@!\2\u0397\u0398\7\u0088\2\2\u0398\u0399\5@!\2")
        buf.write("\u0399\u039b\3\2\2\2\u039a\u0395\3\2\2\2\u039b\u039c\3")
        buf.write("\2\2\2\u039c\u039a\3\2\2\2\u039c\u039d\3\2\2\2\u039d\u03a0")
        buf.write("\3\2\2\2\u039e\u039f\7C\2\2\u039f\u03a1\5@!\2\u03a0\u039e")
        buf.write("\3\2\2\2\u03a0\u03a1\3\2\2\2\u03a1\u03a2\3\2\2\2\u03a2")
        buf.write("\u03a3\7D\2\2\u03a3\u03a6\3\2\2\2\u03a4\u03a6\5B\"\2\u03a5")
        buf.write("\u034d\3\2\2\2\u03a5\u034f\3\2\2\2\u03a5\u0358\3\2\2\2")
        buf.write("\u03a5\u035b\3\2\2\2\u03a5\u035e\3\2\2\2\u03a5\u0375\3")
        buf.write("\2\2\2\u03a5\u0380\3\2\2\2\u03a5\u038b\3\2\2\2\u03a5\u0391")
        buf.write("\3\2\2\2\u03a5\u03a4\3\2\2\2\u03a6\u041e\3\2\2\2\u03a7")
        buf.write("\u03a8\f\26\2\2\u03a8\u03a9\7\r\2\2\u03a9\u041d\5@!\27")
        buf.write("\u03aa\u03ab\f\25\2\2\u03ab\u03ac\t\13\2\2\u03ac\u041d")
        buf.write("\5@!\26\u03ad\u03ae\f\24\2\2\u03ae\u03af\t\6\2\2\u03af")
        buf.write("\u041d\5@!\25\u03b0\u03b1\f\23\2\2\u03b1\u03b2\t\f\2\2")
        buf.write("\u03b2\u041d\5@!\24\u03b3\u03b4\f\22\2\2\u03b4\u03b5\t")
        buf.write("\r\2\2\u03b5\u041d\5@!\23\u03b6\u03c3\f\21\2\2\u03b7\u03c4")
        buf.write("\7\b\2\2\u03b8\u03c4\7\30\2\2\u03b9\u03c4\7\31\2\2\u03ba")
        buf.write("\u03c4\7\32\2\2\u03bb\u03c4\7^\2\2\u03bc\u03bd\7^\2\2")
        buf.write("\u03bd\u03c4\7h\2\2\u03be\u03c4\7U\2\2\u03bf\u03c4\7c")
        buf.write("\2\2\u03c0\u03c4\7O\2\2\u03c1\u03c4\7e\2\2\u03c2\u03c4")
        buf.write("\7x\2\2\u03c3\u03b7\3\2\2\2\u03c3\u03b8\3\2\2\2\u03c3")
        buf.write("\u03b9\3\2\2\2\u03c3\u03ba\3\2\2\2\u03c3\u03bb\3\2\2\2")
        buf.write("\u03c3\u03bc\3\2\2\2\u03c3\u03be\3\2\2\2\u03c3\u03bf\3")
        buf.write("\2\2\2\u03c3\u03c0\3\2\2\2\u03c3\u03c1\3\2\2\2\u03c3\u03c2")
        buf.write("\3\2\2\2\u03c4\u03c5\3\2\2\2\u03c5\u041d\5@!\22\u03c6")
        buf.write("\u03c7\f\20\2\2\u03c7\u03c8\7\"\2\2\u03c8\u041d\5@!\21")
        buf.write("\u03c9\u03ca\f\17\2\2\u03ca\u03cb\7n\2\2\u03cb\u041d\5")
        buf.write("@!\20\u03cc\u03cd\f\b\2\2\u03cd\u03cf\7^\2\2\u03ce\u03d0")
        buf.write("\7h\2\2\u03cf\u03ce\3\2\2\2\u03cf\u03d0\3\2\2\2\u03d0")
        buf.write("\u03d1\3\2\2\2\u03d1\u041d\5@!\t\u03d2\u03d4\f\7\2\2\u03d3")
        buf.write("\u03d5\7h\2\2\u03d4\u03d3\3\2\2\2\u03d4\u03d5\3\2\2\2")
        buf.write("\u03d5\u03d6\3\2\2\2\u03d6\u03d7\7)\2\2\u03d7\u03d8\5")
        buf.write("@!\2\u03d8\u03d9\7\"\2\2\u03d9\u03da\5@!\b\u03da\u041d")
        buf.write("\3\2\2\2\u03db\u03dc\f\13\2\2\u03dc\u03dd\7/\2\2\u03dd")
        buf.write("\u041d\5\u00ba^\2\u03de\u03e0\f\n\2\2\u03df\u03e1\7h\2")
        buf.write("\2\u03e0\u03df\3\2\2\2\u03e0\u03e1\3\2\2\2\u03e1\u03e2")
        buf.write("\3\2\2\2\u03e2\u03e3\t\16\2\2\u03e3\u03e6\5@!\2\u03e4")
        buf.write("\u03e5\7E\2\2\u03e5\u03e7\5@!\2\u03e6\u03e4\3\2\2\2\u03e6")
        buf.write("\u03e7\3\2\2\2\u03e7\u041d\3\2\2\2\u03e8\u03ed\f\t\2\2")
        buf.write("\u03e9\u03ee\7_\2\2\u03ea\u03ee\7i\2\2\u03eb\u03ec\7h")
        buf.write("\2\2\u03ec\u03ee\7j\2\2\u03ed\u03e9\3\2\2\2\u03ed\u03ea")
        buf.write("\3\2\2\2\u03ed\u03eb\3\2\2\2\u03ee\u041d\3\2\2\2\u03ef")
        buf.write("\u03f1\f\6\2\2\u03f0\u03f2\7h\2\2\u03f1\u03f0\3\2\2\2")
        buf.write("\u03f1\u03f2\3\2\2\2\u03f2\u03f3\3\2\2\2\u03f3\u041a\7")
        buf.write("U\2\2\u03f4\u03fe\7\5\2\2\u03f5\u03ff\5P)\2\u03f6\u03fb")
        buf.write("\5@!\2\u03f7\u03f8\7\7\2\2\u03f8\u03fa\5@!\2\u03f9\u03f7")
        buf.write("\3\2\2\2\u03fa\u03fd\3\2\2\2\u03fb\u03f9\3\2\2\2\u03fb")
        buf.write("\u03fc\3\2\2\2\u03fc\u03ff\3\2\2\2\u03fd\u03fb\3\2\2\2")
        buf.write("\u03fe\u03f5\3\2\2\2\u03fe\u03f6\3\2\2\2\u03fe\u03ff\3")
        buf.write("\2\2\2\u03ff\u0400\3\2\2\2\u0400\u041b\7\6\2\2\u0401\u0402")
        buf.write("\5\u00b0Y\2\u0402\u0403\7\4\2\2\u0403\u0405\3\2\2\2\u0404")
        buf.write("\u0401\3\2\2\2\u0404\u0405\3\2\2\2\u0405\u0406\3\2\2\2")
        buf.write("\u0406\u041b\5\u00b2Z\2\u0407\u0408\5\u00b0Y\2\u0408\u0409")
        buf.write("\7\4\2\2\u0409\u040b\3\2\2\2\u040a\u0407\3\2\2\2\u040a")
        buf.write("\u040b\3\2\2\2\u040b\u040c\3\2\2\2\u040c\u040d\5\u00da")
        buf.write("n\2\u040d\u0416\7\5\2\2\u040e\u0413\5@!\2\u040f\u0410")
        buf.write("\7\7\2\2\u0410\u0412\5@!\2\u0411\u040f\3\2\2\2\u0412\u0415")
        buf.write("\3\2\2\2\u0413\u0411\3\2\2\2\u0413\u0414\3\2\2\2\u0414")
        buf.write("\u0417\3\2\2\2\u0415\u0413\3\2\2\2\u0416\u040e\3\2\2\2")
        buf.write("\u0416\u0417\3\2\2\2\u0417\u0418\3\2\2\2\u0418\u0419\7")
        buf.write("\6\2\2\u0419\u041b\3\2\2\2\u041a\u03f4\3\2\2\2\u041a\u0404")
        buf.write("\3\2\2\2\u041a\u040a\3\2\2\2\u041b\u041d\3\2\2\2\u041c")
        buf.write("\u03a7\3\2\2\2\u041c\u03aa\3\2\2\2\u041c\u03ad\3\2\2\2")
        buf.write("\u041c\u03b0\3\2\2\2\u041c\u03b3\3\2\2\2\u041c\u03b6\3")
        buf.write("\2\2\2\u041c\u03c6\3\2\2\2\u041c\u03c9\3\2\2\2\u041c\u03cc")
        buf.write("\3\2\2\2\u041c\u03d2\3\2\2\2\u041c\u03db\3\2\2\2\u041c")
        buf.write("\u03de\3\2\2\2\u041c\u03e8\3\2\2\2\u041c\u03ef\3\2\2\2")
        buf.write("\u041d\u0420\3\2\2\2\u041e\u041c\3\2\2\2\u041e\u041f\3")
        buf.write("\2\2\2\u041fA\3\2\2\2\u0420\u041e\3\2\2\2\u0421\u0422")
        buf.write("\7u\2\2\u0422\u0427\7\5\2\2\u0423\u0428\7S\2\2\u0424\u0425")
        buf.write("\t\17\2\2\u0425\u0426\7\7\2\2\u0426\u0428\5\u00a4S\2\u0427")
        buf.write("\u0423\3\2\2\2\u0427\u0424\3\2\2\2\u0428\u0429\3\2\2\2")
        buf.write("\u0429\u042a\7\6\2\2\u042aC\3\2\2\2\u042b\u042c\t\20\2")
        buf.write("\2\u042cE\3\2\2\2\u042d\u042f\5\62\32\2\u042e\u042d\3")
        buf.write("\2\2\2\u042e\u042f\3\2\2\2\u042f\u0435\3\2\2\2\u0430\u0436")
        buf.write("\7Z\2\2\u0431\u0436\7|\2\2\u0432\u0433\7Z\2\2\u0433\u0434")
        buf.write("\7n\2\2\u0434\u0436\t\n\2\2\u0435\u0430\3\2\2\2\u0435")
        buf.write("\u0431\3\2\2\2\u0435\u0432\3\2\2\2\u0436\u0437\3\2\2\2")
        buf.write("\u0437\u043b\7]\2\2\u0438\u0439\5\u00b0Y\2\u0439\u043a")
        buf.write("\7\4\2\2\u043a\u043c\3\2\2\2\u043b\u0438\3\2\2\2\u043b")
        buf.write("\u043c\3\2\2\2\u043c\u043d\3\2\2\2\u043d\u0440\5\u00b2")
        buf.write("Z\2\u043e\u043f\7#\2\2\u043f\u0441\5\u00caf\2\u0440\u043e")
        buf.write("\3\2\2\2\u0440\u0441\3\2\2\2\u0441\u044d\3\2\2\2\u0442")
        buf.write("\u0443\7\5\2\2\u0443\u0448\5\u00b8]\2\u0444\u0445\7\7")
        buf.write("\2\2\u0445\u0447\5\u00b8]\2\u0446\u0444\3\2\2\2\u0447")
        buf.write("\u044a\3\2\2\2\u0448\u0446\3\2\2\2\u0448\u0449\3\2\2\2")
        buf.write("\u0449\u044b\3\2\2\2\u044a\u0448\3\2\2\2\u044b\u044c\7")
        buf.write("\6\2\2\u044c\u044e\3\2\2\2\u044d\u0442\3\2\2\2\u044d\u044e")
        buf.write("\3\2\2\2\u044e\u046c\3\2\2\2\u044f\u0450\7\u0091\2\2\u0450")
        buf.write("\u0451\7\5\2\2\u0451\u0456\5@!\2\u0452\u0453\7\7\2\2\u0453")
        buf.write("\u0455\5@!\2\u0454\u0452\3\2\2\2\u0455\u0458\3\2\2\2\u0456")
        buf.write("\u0454\3\2\2\2\u0456\u0457\3\2\2\2\u0457\u0459\3\2\2\2")
        buf.write("\u0458\u0456\3\2\2\2\u0459\u0468\7\6\2\2\u045a\u045b\7")
        buf.write("\7\2\2\u045b\u045c\7\5\2\2\u045c\u0461\5@!\2\u045d\u045e")
        buf.write("\7\7\2\2\u045e\u0460\5@!\2\u045f\u045d\3\2\2\2\u0460\u0463")
        buf.write("\3\2\2\2\u0461\u045f\3\2\2\2\u0461\u0462\3\2\2\2\u0462")
        buf.write("\u0464\3\2\2\2\u0463\u0461\3\2\2\2\u0464\u0465\7\6\2\2")
        buf.write("\u0465\u0467\3\2\2\2\u0466\u045a\3\2\2\2\u0467\u046a\3")
        buf.write("\2\2\2\u0468\u0466\3\2\2\2\u0468\u0469\3\2\2\2\u0469\u046d")
        buf.write("\3\2\2\2\u046a\u0468\3\2\2\2\u046b\u046d\5P)\2\u046c\u044f")
        buf.write("\3\2\2\2\u046c\u046b\3\2\2\2\u046d\u046f\3\2\2\2\u046e")
        buf.write("\u0470\5H%\2\u046f\u046e\3\2\2\2\u046f\u0470\3\2\2\2\u0470")
        buf.write("\u0474\3\2\2\2\u0471\u0472\7:\2\2\u0472\u0474\7\u0091")
        buf.write("\2\2\u0473\u042e\3\2\2\2\u0473\u0471\3\2\2\2\u0474G\3")
        buf.write("\2\2\2\u0475\u0476\7m\2\2\u0476\u0485\7\62\2\2\u0477\u0478")
        buf.write("\7\5\2\2\u0478\u047d\5\32\16\2\u0479\u047a\7\7\2\2\u047a")
        buf.write("\u047c\5\32\16\2\u047b\u0479\3\2\2\2\u047c\u047f\3\2\2")
        buf.write("\2\u047d\u047b\3\2\2\2\u047d\u047e\3\2\2\2\u047e\u0480")
        buf.write("\3\2\2\2\u047f\u047d\3\2\2\2\u0480\u0483\7\6\2\2\u0481")
        buf.write("\u0482\7\u0095\2\2\u0482\u0484\5@!\2\u0483\u0481\3\2\2")
        buf.write("\2\u0483\u0484\3\2\2\2\u0484\u0486\3\2\2\2\u0485\u0477")
        buf.write("\3\2\2\2\u0485\u0486\3\2\2\2\u0486\u0487\3\2\2\2\u0487")
        buf.write("\u04a2\7\u00b8\2\2\u0488\u04a3\7\u00b9\2\2\u0489\u048a")
        buf.write("\7\u008e\2\2\u048a\u048d\7\u0084\2\2\u048b\u048e\5\u00b8")
        buf.write("]\2\u048c\u048e\5h\65\2\u048d\u048b\3\2\2\2\u048d\u048c")
        buf.write("\3\2\2\2\u048e\u048f\3\2\2\2\u048f\u0490\7\30\2\2\u0490")
        buf.write("\u049b\5@!\2\u0491\u0494\7\7\2\2\u0492\u0495\5\u00b8]")
        buf.write("\2\u0493\u0495\5h\65\2\u0494\u0492\3\2\2\2\u0494\u0493")
        buf.write("\3\2\2\2\u0495\u0496\3\2\2\2\u0496\u0497\7\30\2\2\u0497")
        buf.write("\u0498\5@!\2\u0498\u049a\3\2\2\2\u0499\u0491\3\2\2\2\u049a")
        buf.write("\u049d\3\2\2\2\u049b\u0499\3\2\2\2\u049b\u049c\3\2\2\2")
        buf.write("\u049c\u04a0\3\2\2\2\u049d\u049b\3\2\2\2\u049e\u049f\7")
        buf.write("\u0095\2\2\u049f\u04a1\5@!\2\u04a0\u049e\3\2\2\2\u04a0")
        buf.write("\u04a1\3\2\2\2\u04a1\u04a3\3\2\2\2\u04a2\u0488\3\2\2\2")
        buf.write("\u04a2\u0489\3\2\2\2\u04a3I\3\2\2\2\u04a4\u04a8\7r\2\2")
        buf.write("\u04a5\u04a6\5\u00b0Y\2\u04a6\u04a7\7\4\2\2\u04a7\u04a9")
        buf.write("\3\2\2\2\u04a8\u04a5\3\2\2\2\u04a8\u04a9\3\2\2\2\u04a9")
        buf.write("\u04aa\3\2\2\2\u04aa\u04b1\5\u00c6d\2\u04ab\u04ac\7\b")
        buf.write("\2\2\u04ac\u04b2\5L\'\2\u04ad\u04ae\7\5\2\2\u04ae\u04af")
        buf.write("\5L\'\2\u04af\u04b0\7\6\2\2\u04b0\u04b2\3\2\2\2\u04b1")
        buf.write("\u04ab\3\2\2\2\u04b1\u04ad\3\2\2\2\u04b1\u04b2\3\2\2\2")
        buf.write("\u04b2K\3\2\2\2\u04b3\u04b7\5$\23\2\u04b4\u04b7\5\u00ac")
        buf.write("W\2\u04b5\u04b7\7\u00bd\2\2\u04b6\u04b3\3\2\2\2\u04b6")
        buf.write("\u04b4\3\2\2\2\u04b6\u04b5\3\2\2\2\u04b7M\3\2\2\2\u04b8")
        buf.write("\u04c3\7y\2\2\u04b9\u04c4\5\u00ba^\2\u04ba\u04bb\5\u00b0")
        buf.write("Y\2\u04bb\u04bc\7\4\2\2\u04bc\u04be\3\2\2\2\u04bd\u04ba")
        buf.write("\3\2\2\2\u04bd\u04be\3\2\2\2\u04be\u04c1\3\2\2\2\u04bf")
        buf.write("\u04c2\5\u00b2Z\2\u04c0\u04c2\5\u00be`\2\u04c1\u04bf\3")
        buf.write("\2\2\2\u04c1\u04c0\3\2\2\2\u04c2\u04c4\3\2\2\2\u04c3\u04b9")
        buf.write("\3\2\2\2\u04c3\u04bd\3\2\2\2\u04c3\u04c4\3\2\2\2\u04c4")
        buf.write("O\3\2\2\2\u04c5\u04c7\5\u0080A\2\u04c6\u04c5\3\2\2\2\u04c6")
        buf.write("\u04c7\3\2\2\2\u04c7\u04c8\3\2\2\2\u04c8\u04ce\5T+\2\u04c9")
        buf.write("\u04ca\5d\63\2\u04ca\u04cb\5T+\2\u04cb\u04cd\3\2\2\2\u04cc")
        buf.write("\u04c9\3\2\2\2\u04cd\u04d0\3\2\2\2\u04ce\u04cc\3\2\2\2")
        buf.write("\u04ce\u04cf\3\2\2\2\u04cf\u04d2\3\2\2\2\u04d0\u04ce\3")
        buf.write("\2\2\2\u04d1\u04d3\5\u0082B\2\u04d2\u04d1\3\2\2\2\u04d2")
        buf.write("\u04d3\3\2\2\2\u04d3\u04d5\3\2\2\2\u04d4\u04d6\5\u0084")
        buf.write("C\2\u04d5\u04d4\3\2\2\2\u04d5\u04d6\3\2\2\2\u04d6Q\3\2")
        buf.write("\2\2\u04d7\u04df\5\\/\2\u04d8\u04d9\5`\61\2\u04d9\u04db")
        buf.write("\5\\/\2\u04da\u04dc\5b\62\2\u04db\u04da\3\2\2\2\u04db")
        buf.write("\u04dc\3\2\2\2\u04dc\u04de\3\2\2\2\u04dd\u04d8\3\2\2\2")
        buf.write("\u04de\u04e1\3\2\2\2\u04df\u04dd\3\2\2\2\u04df\u04e0\3")
        buf.write("\2\2\2\u04e0S\3\2\2\2\u04e1\u04df\3\2\2\2\u04e2\u04e4")
        buf.write("\7\u0083\2\2\u04e3\u04e5\t\21\2\2\u04e4\u04e3\3\2\2\2")
        buf.write("\u04e4\u04e5\3\2\2\2\u04e5\u04e6\3\2\2\2\u04e6\u04eb\5")
        buf.write("^\60\2\u04e7\u04e8\7\7\2\2\u04e8\u04ea\5^\60\2\u04e9\u04e7")
        buf.write("\3\2\2\2\u04ea\u04ed\3\2\2\2\u04eb\u04e9\3\2\2\2\u04eb")
        buf.write("\u04ec\3\2\2\2\u04ec\u04fa\3\2\2\2\u04ed\u04eb\3\2\2\2")
        buf.write("\u04ee\u04f8\7M\2\2\u04ef\u04f4\5\\/\2\u04f0\u04f1\7\7")
        buf.write("\2\2\u04f1\u04f3\5\\/\2\u04f2\u04f0\3\2\2\2\u04f3\u04f6")
        buf.write("\3\2\2\2\u04f4\u04f2\3\2\2\2\u04f4\u04f5\3\2\2\2\u04f5")
        buf.write("\u04f9\3\2\2\2\u04f6\u04f4\3\2\2\2\u04f7\u04f9\5R*\2\u04f8")
        buf.write("\u04ef\3\2\2\2\u04f8\u04f7\3\2\2\2\u04f9\u04fb\3\2\2\2")
        buf.write("\u04fa\u04ee\3\2\2\2\u04fa\u04fb\3\2\2\2\u04fb\u04fe\3")
        buf.write("\2\2\2\u04fc\u04fd\7\u0095\2\2\u04fd\u04ff\5@!\2\u04fe")
        buf.write("\u04fc\3\2\2\2\u04fe\u04ff\3\2\2\2\u04ff\u050e\3\2\2\2")
        buf.write("\u0500\u0501\7P\2\2\u0501\u0502\7*\2\2\u0502\u0507\5@")
        buf.write("!\2\u0503\u0504\7\7\2\2\u0504\u0506\5@!\2\u0505\u0503")
        buf.write("\3\2\2\2\u0506\u0509\3\2\2\2\u0507\u0505\3\2\2\2\u0507")
        buf.write("\u0508\3\2\2\2\u0508\u050c\3\2\2\2\u0509\u0507\3\2\2\2")
        buf.write("\u050a\u050b\7Q\2\2\u050b\u050d\5@!\2\u050c\u050a\3\2")
        buf.write("\2\2\u050c\u050d\3\2\2\2\u050d\u050f\3\2\2\2\u050e\u0500")
        buf.write("\3\2\2\2\u050e\u050f\3\2\2\2\u050f\u051e\3\2\2\2\u0510")
        buf.write("\u0511\7\u00af\2\2\u0511\u0512\5\u00ceh\2\u0512\u0513")
        buf.write("\7#\2\2\u0513\u051b\5r:\2\u0514\u0515\7\7\2\2\u0515\u0516")
        buf.write("\5\u00ceh\2\u0516\u0517\7#\2\2\u0517\u0518\5r:\2\u0518")
        buf.write("\u051a\3\2\2\2\u0519\u0514\3\2\2\2\u051a\u051d\3\2\2\2")
        buf.write("\u051b\u0519\3\2\2\2\u051b\u051c\3\2\2\2\u051c\u051f\3")
        buf.write("\2\2\2\u051d\u051b\3\2\2\2\u051e\u0510\3\2\2\2\u051e\u051f")
        buf.write("\3\2\2\2\u051f\u053d\3\2\2\2\u0520\u0521\7\u0091\2\2\u0521")
        buf.write("\u0522\7\5\2\2\u0522\u0527\5@!\2\u0523\u0524\7\7\2\2\u0524")
        buf.write("\u0526\5@!\2\u0525\u0523\3\2\2\2\u0526\u0529\3\2\2\2\u0527")
        buf.write("\u0525\3\2\2\2\u0527\u0528\3\2\2\2\u0528\u052a\3\2\2\2")
        buf.write("\u0529\u0527\3\2\2\2\u052a\u0539\7\6\2\2\u052b\u052c\7")
        buf.write("\7\2\2\u052c\u052d\7\5\2\2\u052d\u0532\5@!\2\u052e\u052f")
        buf.write("\7\7\2\2\u052f\u0531\5@!\2\u0530\u052e\3\2\2\2\u0531\u0534")
        buf.write("\3\2\2\2\u0532\u0530\3\2\2\2\u0532\u0533\3\2\2\2\u0533")
        buf.write("\u0535\3\2\2\2\u0534\u0532\3\2\2\2\u0535\u0536\7\6\2\2")
        buf.write("\u0536\u0538\3\2\2\2\u0537\u052b\3\2\2\2\u0538\u053b\3")
        buf.write("\2\2\2\u0539\u0537\3\2\2\2\u0539\u053a\3\2\2\2\u053a\u053d")
        buf.write("\3\2\2\2\u053b\u0539\3\2\2\2\u053c\u04e2\3\2\2\2\u053c")
        buf.write("\u0520\3\2\2\2\u053dU\3\2\2\2\u053e\u053f\5P)\2\u053f")
        buf.write("W\3\2\2\2\u0540\u0542\5\u0080A\2\u0541\u0540\3\2\2\2\u0541")
        buf.write("\u0542\3\2\2\2\u0542\u0543\3\2\2\2\u0543\u0545\5T+\2\u0544")
        buf.write("\u0546\5\u0082B\2\u0545\u0544\3\2\2\2\u0545\u0546\3\2")
        buf.write("\2\2\u0546\u0548\3\2\2\2\u0547\u0549\5\u0084C\2\u0548")
        buf.write("\u0547\3\2\2\2\u0548\u0549\3\2\2\2\u0549Y\3\2\2\2\u054a")
        buf.write("\u054c\5\u0080A\2\u054b\u054a\3\2\2\2\u054b\u054c\3\2")
        buf.write("\2\2\u054c\u054d\3\2\2\2\u054d\u0557\5T+\2\u054e\u0550")
        buf.write("\7\u008c\2\2\u054f\u0551\7\37\2\2\u0550\u054f\3\2\2\2")
        buf.write("\u0550\u0551\3\2\2\2\u0551\u0555\3\2\2\2\u0552\u0555\7")
        buf.write("\\\2\2\u0553\u0555\7F\2\2\u0554\u054e\3\2\2\2\u0554\u0552")
        buf.write("\3\2\2\2\u0554\u0553\3\2\2\2\u0555\u0556\3\2\2\2\u0556")
        buf.write("\u0558\5T+\2\u0557\u0554\3\2\2\2\u0558\u0559\3\2\2\2\u0559")
        buf.write("\u0557\3\2\2\2\u0559\u055a\3\2\2\2\u055a\u055c\3\2\2\2")
        buf.write("\u055b\u055d\5\u0082B\2\u055c\u055b\3\2\2\2\u055c\u055d")
        buf.write("\3\2\2\2\u055d\u055f\3\2\2\2\u055e\u0560\5\u0084C\2\u055f")
        buf.write("\u055e\3\2\2\2\u055f\u0560\3\2\2\2\u0560[\3\2\2\2\u0561")
        buf.write("\u0562\5\u00b0Y\2\u0562\u0563\7\4\2\2\u0563\u0565\3\2")
        buf.write("\2\2\u0564\u0561\3\2\2\2\u0564\u0565\3\2\2\2\u0565\u0566")
        buf.write("\3\2\2\2\u0566\u056b\5\u00b2Z\2\u0567\u0569\7#\2\2\u0568")
        buf.write("\u0567\3\2\2\2\u0568\u0569\3\2\2\2\u0569\u056a\3\2\2\2")
        buf.write("\u056a\u056c\5\u00caf\2\u056b\u0568\3\2\2\2\u056b\u056c")
        buf.write("\3\2\2\2\u056c\u0572\3\2\2\2\u056d\u056e\7W\2\2\u056e")
        buf.write("\u056f\7*\2\2\u056f\u0573\5\u00be`\2\u0570\u0571\7h\2")
        buf.write("\2\u0571\u0573\7W\2\2\u0572\u056d\3\2\2\2\u0572\u0570")
        buf.write("\3\2\2\2\u0572\u0573\3\2\2\2\u0573\u05a2\3\2\2\2\u0574")
        buf.write("\u0575\5\u00b0Y\2\u0575\u0576\7\4\2\2\u0576\u0578\3\2")
        buf.write("\2\2\u0577\u0574\3\2\2\2\u0577\u0578\3\2\2\2\u0578\u0579")
        buf.write("\3\2\2\2\u0579\u057a\5\u00dan\2\u057a\u057b\7\5\2\2\u057b")
        buf.write("\u0580\5@!\2\u057c\u057d\7\7\2\2\u057d\u057f\5@!\2\u057e")
        buf.write("\u057c\3\2\2\2\u057f\u0582\3\2\2\2\u0580\u057e\3\2\2\2")
        buf.write("\u0580\u0581\3\2\2\2\u0581\u0583\3\2\2\2\u0582\u0580\3")
        buf.write("\2\2\2\u0583\u0588\7\6\2\2\u0584\u0586\7#\2\2\u0585\u0584")
        buf.write("\3\2\2\2\u0585\u0586\3\2\2\2\u0586\u0587\3\2\2\2\u0587")
        buf.write("\u0589\5\u00caf\2\u0588\u0585\3\2\2\2\u0588\u0589\3\2")
        buf.write("\2\2\u0589\u05a2\3\2\2\2\u058a\u0594\7\5\2\2\u058b\u0590")
        buf.write("\5\\/\2\u058c\u058d\7\7\2\2\u058d\u058f\5\\/\2\u058e\u058c")
        buf.write("\3\2\2\2\u058f\u0592\3\2\2\2\u0590\u058e\3\2\2\2\u0590")
        buf.write("\u0591\3\2\2\2\u0591\u0595\3\2\2\2\u0592\u0590\3\2\2\2")
        buf.write("\u0593\u0595\5R*\2\u0594\u058b\3\2\2\2\u0594\u0593\3\2")
        buf.write("\2\2\u0595\u0596\3\2\2\2\u0596\u0597\7\6\2\2\u0597\u05a2")
        buf.write("\3\2\2\2\u0598\u0599\7\5\2\2\u0599\u059a\5P)\2\u059a\u059f")
        buf.write("\7\6\2\2\u059b\u059d\7#\2\2\u059c\u059b\3\2\2\2\u059c")
        buf.write("\u059d\3\2\2\2\u059d\u059e\3\2\2\2\u059e\u05a0\5\u00ca")
        buf.write("f\2\u059f\u059c\3\2\2\2\u059f\u05a0\3\2\2\2\u05a0\u05a2")
        buf.write("\3\2\2\2\u05a1\u0564\3\2\2\2\u05a1\u0577\3\2\2\2\u05a1")
        buf.write("\u058a\3\2\2\2\u05a1\u0598\3\2\2\2\u05a2]\3\2\2\2\u05a3")
        buf.write("\u05b0\7\t\2\2\u05a4\u05a5\5\u00b2Z\2\u05a5\u05a6\7\4")
        buf.write("\2\2\u05a6\u05a7\7\t\2\2\u05a7\u05b0\3\2\2\2\u05a8\u05ad")
        buf.write("\5@!\2\u05a9\u05ab\7#\2\2\u05aa\u05a9\3\2\2\2\u05aa\u05ab")
        buf.write("\3\2\2\2\u05ab\u05ac\3\2\2\2\u05ac\u05ae\5\u00a8U\2\u05ad")
        buf.write("\u05aa\3\2\2\2\u05ad\u05ae\3\2\2\2\u05ae\u05b0\3\2\2\2")
        buf.write("\u05af\u05a3\3\2\2\2\u05af\u05a4\3\2\2\2\u05af\u05a8\3")
        buf.write("\2\2\2\u05b0_\3\2\2\2\u05b1\u05bf\7\7\2\2\u05b2\u05b4")
        buf.write("\7f\2\2\u05b3\u05b2\3\2\2\2\u05b3\u05b4\3\2\2\2\u05b4")
        buf.write("\u05bb\3\2\2\2\u05b5\u05b7\7b\2\2\u05b6\u05b8\7p\2\2\u05b7")
        buf.write("\u05b6\3\2\2\2\u05b7\u05b8\3\2\2\2\u05b8\u05bc\3\2\2\2")
        buf.write("\u05b9\u05bc\7Y\2\2\u05ba\u05bc\7\65\2\2\u05bb\u05b5\3")
        buf.write("\2\2\2\u05bb\u05b9\3\2\2\2\u05bb\u05ba\3\2\2\2\u05bb\u05bc")
        buf.write("\3\2\2\2\u05bc\u05bd\3\2\2\2\u05bd\u05bf\7`\2\2\u05be")
        buf.write("\u05b1\3\2\2\2\u05be\u05b3\3\2\2\2\u05bfa\3\2\2\2\u05c0")
        buf.write("\u05c1\7m\2\2\u05c1\u05cf\5@!\2\u05c2\u05c3\7\u008f\2")
        buf.write("\2\u05c3\u05c4\7\5\2\2\u05c4\u05c9\5\u00b8]\2\u05c5\u05c6")
        buf.write("\7\7\2\2\u05c6\u05c8\5\u00b8]\2\u05c7\u05c5\3\2\2\2\u05c8")
        buf.write("\u05cb\3\2\2\2\u05c9\u05c7\3\2\2\2\u05c9\u05ca\3\2\2\2")
        buf.write("\u05ca\u05cc\3\2\2\2\u05cb\u05c9\3\2\2\2\u05cc\u05cd\7")
        buf.write("\6\2\2\u05cd\u05cf\3\2\2\2\u05ce\u05c0\3\2\2\2\u05ce\u05c2")
        buf.write("\3\2\2\2\u05cfc\3\2\2\2\u05d0\u05d2\7\u008c\2\2\u05d1")
        buf.write("\u05d3\7\37\2\2\u05d2\u05d1\3\2\2\2\u05d2\u05d3\3\2\2")
        buf.write("\2\u05d3\u05d7\3\2\2\2\u05d4\u05d7\7\\\2\2\u05d5\u05d7")
        buf.write("\7F\2\2\u05d6\u05d0\3\2\2\2\u05d6\u05d4\3\2\2\2\u05d6")
        buf.write("\u05d5\3\2\2\2\u05d7e\3\2\2\2\u05d8\u05da\5\62\32\2\u05d9")
        buf.write("\u05d8\3\2\2\2\u05d9\u05da\3\2\2\2\u05da\u05db\3\2\2\2")
        buf.write("\u05db\u05de\7\u008e\2\2\u05dc\u05dd\7n\2\2\u05dd\u05df")
        buf.write("\t\n\2\2\u05de\u05dc\3\2\2\2\u05de\u05df\3\2\2\2\u05df")
        buf.write("\u05e0\3\2\2\2\u05e0\u05e1\5l\67\2\u05e1\u05e4\7\u0084")
        buf.write("\2\2\u05e2\u05e5\5\u00b8]\2\u05e3\u05e5\5h\65\2\u05e4")
        buf.write("\u05e2\3\2\2\2\u05e4\u05e3\3\2\2\2\u05e5\u05e6\3\2\2\2")
        buf.write("\u05e6\u05e7\7\b\2\2\u05e7\u05f2\5@!\2\u05e8\u05eb\7\7")
        buf.write("\2\2\u05e9\u05ec\5\u00b8]\2\u05ea\u05ec\5h\65\2\u05eb")
        buf.write("\u05e9\3\2\2\2\u05eb\u05ea\3\2\2\2\u05ec\u05ed\3\2\2\2")
        buf.write("\u05ed\u05ee\7\b\2\2\u05ee\u05ef\5@!\2\u05ef\u05f1\3\2")
        buf.write("\2\2\u05f0\u05e8\3\2\2\2\u05f1\u05f4\3\2\2\2\u05f2\u05f0")
        buf.write("\3\2\2\2\u05f2\u05f3\3\2\2\2\u05f3\u05f7\3\2\2\2\u05f4")
        buf.write("\u05f2\3\2\2\2\u05f5\u05f6\7\u0095\2\2\u05f6\u05f8\5@")
        buf.write("!\2\u05f7\u05f5\3\2\2\2\u05f7\u05f8\3\2\2\2\u05f8g\3\2")
        buf.write("\2\2\u05f9\u05fa\7\5\2\2\u05fa\u05ff\5\u00b8]\2\u05fb")
        buf.write("\u05fc\7\7\2\2\u05fc\u05fe\5\u00b8]\2\u05fd\u05fb\3\2")
        buf.write("\2\2\u05fe\u0601\3\2\2\2\u05ff\u05fd\3\2\2\2\u05ff\u0600")
        buf.write("\3\2\2\2\u0600\u0602\3\2\2\2\u0601\u05ff\3\2\2\2\u0602")
        buf.write("\u0603\7\6\2\2\u0603i\3\2\2\2\u0604\u0606\5\62\32\2\u0605")
        buf.write("\u0604\3\2\2\2\u0605\u0606\3\2\2\2\u0606\u0607\3\2\2\2")
        buf.write("\u0607\u060a\7\u008e\2\2\u0608\u0609\7n\2\2\u0609\u060b")
        buf.write("\t\n\2\2\u060a\u0608\3\2\2\2\u060a\u060b\3\2\2\2\u060b")
        buf.write("\u060c\3\2\2\2\u060c\u060d\5l\67\2\u060d\u0610\7\u0084")
        buf.write("\2\2\u060e\u0611\5\u00b8]\2\u060f\u0611\5h\65\2\u0610")
        buf.write("\u060e\3\2\2\2\u0610\u060f\3\2\2\2\u0611\u0612\3\2\2\2")
        buf.write("\u0612\u0613\7\b\2\2\u0613\u061e\5@!\2\u0614\u0617\7\7")
        buf.write("\2\2\u0615\u0618\5\u00b8]\2\u0616\u0618\5h\65\2\u0617")
        buf.write("\u0615\3\2\2\2\u0617\u0616\3\2\2\2\u0618\u0619\3\2\2\2")
        buf.write("\u0619\u061a\7\b\2\2\u061a\u061b\5@!\2\u061b\u061d\3\2")
        buf.write("\2\2\u061c\u0614\3\2\2\2\u061d\u0620\3\2\2\2\u061e\u061c")
        buf.write("\3\2\2\2\u061e\u061f\3\2\2\2\u061f\u0623\3\2\2\2\u0620")
        buf.write("\u061e\3\2\2\2\u0621\u0622\7\u0095\2\2\u0622\u0624\5@")
        buf.write("!\2\u0623\u0621\3\2\2\2\u0623\u0624\3\2\2\2\u0624\u0629")
        buf.write("\3\2\2\2\u0625\u0627\5\u0082B\2\u0626\u0625\3\2\2\2\u0626")
        buf.write("\u0627\3\2\2\2\u0627\u0628\3\2\2\2\u0628\u062a\5\u0084")
        buf.write("C\2\u0629\u0626\3\2\2\2\u0629\u062a\3\2\2\2\u062ak\3\2")
        buf.write("\2\2\u062b\u062c\5\u00b0Y\2\u062c\u062d\7\4\2\2\u062d")
        buf.write("\u062f\3\2\2\2\u062e\u062b\3\2\2\2\u062e\u062f\3\2\2\2")
        buf.write("\u062f\u0630\3\2\2\2\u0630\u0633\5\u00b2Z\2\u0631\u0632")
        buf.write("\7#\2\2\u0632\u0634\5\u00d0i\2\u0633\u0631\3\2\2\2\u0633")
        buf.write("\u0634\3\2\2\2\u0634\u063a\3\2\2\2\u0635\u0636\7W\2\2")
        buf.write("\u0636\u0637\7*\2\2\u0637\u063b\5\u00be`\2\u0638\u0639")
        buf.write("\7h\2\2\u0639\u063b\7W\2\2\u063a\u0635\3\2\2\2\u063a\u0638")
        buf.write("\3\2\2\2\u063a\u063b\3\2\2\2\u063bm\3\2\2\2\u063c\u063e")
        buf.write("\7\u0090\2\2\u063d\u063f\5\u00b0Y\2\u063e\u063d\3\2\2")
        buf.write("\2\u063e\u063f\3\2\2\2\u063f\u0642\3\2\2\2\u0640\u0641")
        buf.write("\7]\2\2\u0641\u0643\5\u00d2j\2\u0642\u0640\3\2\2\2\u0642")
        buf.write("\u0643\3\2\2\2\u0643o\3\2\2\2\u0644\u0645\7\u00b3\2\2")
        buf.write("\u0645\u0646\7\5\2\2\u0646\u0647\7\u0095\2\2\u0647\u0648")
        buf.write("\5@!\2\u0648\u0649\7\6\2\2\u0649q\3\2\2\2\u064a\u064c")
        buf.write("\7\5\2\2\u064b\u064d\5\u00d4k\2\u064c\u064b\3\2\2\2\u064c")
        buf.write("\u064d\3\2\2\2\u064d\u0658\3\2\2\2\u064e\u064f\7\u009a")
        buf.write("\2\2\u064f\u0650\7*\2\2\u0650\u0655\5@!\2\u0651\u0652")
        buf.write("\7\7\2\2\u0652\u0654\5@!\2\u0653\u0651\3\2\2\2\u0654\u0657")
        buf.write("\3\2\2\2\u0655\u0653\3\2\2\2\u0655\u0656\3\2\2\2\u0656")
        buf.write("\u0659\3\2\2\2\u0657\u0655\3\2\2\2\u0658\u064e\3\2\2\2")
        buf.write("\u0658\u0659\3\2\2\2\u0659\u065a\3\2\2\2\u065a\u065b\7")
        buf.write("o\2\2\u065b\u065c\7*\2\2\u065c\u0661\5\u0086D\2\u065d")
        buf.write("\u065e\7\7\2\2\u065e\u0660\5\u0086D\2\u065f\u065d\3\2")
        buf.write("\2\2\u0660\u0663\3\2\2\2\u0661\u065f\3\2\2\2\u0661\u0662")
        buf.write("\3\2\2\2\u0662\u0665\3\2\2\2\u0663\u0661\3\2\2\2\u0664")
        buf.write("\u0666\5v<\2\u0665\u0664\3\2\2\2\u0665\u0666\3\2\2\2\u0666")
        buf.write("\u0667\3\2\2\2\u0667\u0668\7\6\2\2\u0668s\3\2\2\2\u0669")
        buf.write("\u068b\7\u0099\2\2\u066a\u068c\5\u00ceh\2\u066b\u066d")
        buf.write("\7\5\2\2\u066c\u066e\5\u00d4k\2\u066d\u066c\3\2\2\2\u066d")
        buf.write("\u066e\3\2\2\2\u066e\u0679\3\2\2\2\u066f\u0670\7\u009a")
        buf.write("\2\2\u0670\u0671\7*\2\2\u0671\u0676\5@!\2\u0672\u0673")
        buf.write("\7\7\2\2\u0673\u0675\5@!\2\u0674\u0672\3\2\2\2\u0675\u0678")
        buf.write("\3\2\2\2\u0676\u0674\3\2\2\2\u0676\u0677\3\2\2\2\u0677")
        buf.write("\u067a\3\2\2\2\u0678\u0676\3\2\2\2\u0679\u066f\3\2\2\2")
        buf.write("\u0679\u067a\3\2\2\2\u067a\u0685\3\2\2\2\u067b\u067c\7")
        buf.write("o\2\2\u067c\u067d\7*\2\2\u067d\u0682\5\u0086D\2\u067e")
        buf.write("\u067f\7\7\2\2\u067f\u0681\5\u0086D\2\u0680\u067e\3\2")
        buf.write("\2\2\u0681\u0684\3\2\2\2\u0682\u0680\3\2\2\2\u0682\u0683")
        buf.write("\3\2\2\2\u0683\u0686\3\2\2\2\u0684\u0682\3\2\2\2\u0685")
        buf.write("\u067b\3\2\2\2\u0685\u0686\3\2\2\2\u0686\u0688\3\2\2\2")
        buf.write("\u0687\u0689\5v<\2\u0688\u0687\3\2\2\2\u0688\u0689\3\2")
        buf.write("\2\2\u0689\u068a\3\2\2\2\u068a\u068c\7\6\2\2\u068b\u066a")
        buf.write("\3\2\2\2\u068b\u066b\3\2\2\2\u068cu\3\2\2\2\u068d\u0695")
        buf.write("\5x=\2\u068e\u068f\7\u00b5\2\2\u068f\u0690\7g\2\2\u0690")
        buf.write("\u0696\7\u00b7\2\2\u0691\u0692\7\u009e\2\2\u0692\u0696")
        buf.write("\7\u0080\2\2\u0693\u0696\7P\2\2\u0694\u0696\7\u00b6\2")
        buf.write("\2\u0695\u068e\3\2\2\2\u0695\u0691\3\2\2\2\u0695\u0693")
        buf.write("\3\2\2\2\u0695\u0694\3\2\2\2\u0695\u0696\3\2\2\2\u0696")
        buf.write("w\3\2\2\2\u0697\u069e\t\22\2\2\u0698\u069f\5\u008eH\2")
        buf.write("\u0699\u069a\7)\2\2\u069a\u069b\5\u008aF\2\u069b\u069c")
        buf.write("\7\"\2\2\u069c\u069d\5\u008cG\2\u069d\u069f\3\2\2\2\u069e")
        buf.write("\u0698\3\2\2\2\u069e\u0699\3\2\2\2\u069fy\3\2\2\2\u06a0")
        buf.write("\u06a1\5\u00d6l\2\u06a1\u06ab\7\5\2\2\u06a2\u06a7\5@!")
        buf.write("\2\u06a3\u06a4\7\7\2\2\u06a4\u06a6\5@!\2\u06a5\u06a3\3")
        buf.write("\2\2\2\u06a6\u06a9\3\2\2\2\u06a7\u06a5\3\2\2\2\u06a7\u06a8")
        buf.write("\3\2\2\2\u06a8\u06ac\3\2\2\2\u06a9\u06a7\3\2\2\2\u06aa")
        buf.write("\u06ac\7\t\2\2\u06ab\u06a2\3\2\2\2\u06ab\u06aa\3\2\2\2")
        buf.write("\u06ac\u06ad\3\2\2\2\u06ad\u06ae\7\6\2\2\u06ae{\3\2\2")
        buf.write("\2\u06af\u06b0\5\u00d8m\2\u06b0\u06bd\7\5\2\2\u06b1\u06b3")
        buf.write("\7@\2\2\u06b2\u06b1\3\2\2\2\u06b2\u06b3\3\2\2\2\u06b3")
        buf.write("\u06b4\3\2\2\2\u06b4\u06b9\5@!\2\u06b5\u06b6\7\7\2\2\u06b6")
        buf.write("\u06b8\5@!\2\u06b7\u06b5\3\2\2\2\u06b8\u06bb\3\2\2\2\u06b9")
        buf.write("\u06b7\3\2\2\2\u06b9\u06ba\3\2\2\2\u06ba\u06be\3\2\2\2")
        buf.write("\u06bb\u06b9\3\2\2\2\u06bc\u06be\7\t\2\2\u06bd\u06b2\3")
        buf.write("\2\2\2\u06bd\u06bc\3\2\2\2\u06bd\u06be\3\2\2\2\u06be\u06bf")
        buf.write("\3\2\2\2\u06bf\u06c1\7\6\2\2\u06c0\u06c2\5p9\2\u06c1\u06c0")
        buf.write("\3\2\2\2\u06c1\u06c2\3\2\2\2\u06c2}\3\2\2\2\u06c3\u06c4")
        buf.write("\5\u0090I\2\u06c4\u06ce\7\5\2\2\u06c5\u06ca\5@!\2\u06c6")
        buf.write("\u06c7\7\7\2\2\u06c7\u06c9\5@!\2\u06c8\u06c6\3\2\2\2\u06c9")
        buf.write("\u06cc\3\2\2\2\u06ca\u06c8\3\2\2\2\u06ca\u06cb\3\2\2\2")
        buf.write("\u06cb\u06cf\3\2\2\2\u06cc\u06ca\3\2\2\2\u06cd\u06cf\7")
        buf.write("\t\2\2\u06ce\u06c5\3\2\2\2\u06ce\u06cd\3\2\2\2\u06ce\u06cf")
        buf.write("\3\2\2\2\u06cf\u06d0\3\2\2\2\u06d0\u06d2\7\6\2\2\u06d1")
        buf.write("\u06d3\5p9\2\u06d2\u06d1\3\2\2\2\u06d2\u06d3\3\2\2\2\u06d3")
        buf.write("\u06d4\3\2\2\2\u06d4\u06d7\7\u0099\2\2\u06d5\u06d8\5r")
        buf.write(":\2\u06d6\u06d8\5\u00ceh\2\u06d7\u06d5\3\2\2\2\u06d7\u06d6")
        buf.write("\3\2\2\2\u06d8\177\3\2\2\2\u06d9\u06db\7\u0096\2\2\u06da")
        buf.write("\u06dc\7v\2\2\u06db\u06da\3\2\2\2\u06db\u06dc\3\2\2\2")
        buf.write("\u06dc\u06dd\3\2\2\2\u06dd\u06e2\58\35\2\u06de\u06df\7")
        buf.write("\7\2\2\u06df\u06e1\58\35\2\u06e0\u06de\3\2\2\2\u06e1\u06e4")
        buf.write("\3\2\2\2\u06e2\u06e0\3\2\2\2\u06e2\u06e3\3\2\2\2\u06e3")
        buf.write("\u0081\3\2\2\2\u06e4\u06e2\3\2\2\2\u06e5\u06e6\7o\2\2")
        buf.write("\u06e6\u06e7\7*\2\2\u06e7\u06ec\5\u0086D\2\u06e8\u06e9")
        buf.write("\7\7\2\2\u06e9\u06eb\5\u0086D\2\u06ea\u06e8\3\2\2\2\u06eb")
        buf.write("\u06ee\3\2\2\2\u06ec\u06ea\3\2\2\2\u06ec\u06ed\3\2\2\2")
        buf.write("\u06ed\u0083\3\2\2\2\u06ee\u06ec\3\2\2\2\u06ef\u06f0\7")
        buf.write("d\2\2\u06f0\u06f3\5@!\2\u06f1\u06f2\t\23\2\2\u06f2\u06f4")
        buf.write("\5@!\2\u06f3\u06f1\3\2\2\2\u06f3\u06f4\3\2\2\2\u06f4\u0085")
        buf.write("\3\2\2\2\u06f5\u06f8\5@!\2\u06f6\u06f7\7/\2\2\u06f7\u06f9")
        buf.write("\5\u00ba^\2\u06f8\u06f6\3\2\2\2\u06f8\u06f9\3\2\2\2\u06f9")
        buf.write("\u06fb\3\2\2\2\u06fa\u06fc\5\u0088E\2\u06fb\u06fa\3\2")
        buf.write("\2\2\u06fb\u06fc\3\2\2\2\u06fc\u06ff\3\2\2\2\u06fd\u06fe")
        buf.write("\7\u00b0\2\2\u06fe\u0700\t\24\2\2\u06ff\u06fd\3\2\2\2")
        buf.write("\u06ff\u0700\3\2\2\2\u0700\u0087\3\2\2\2\u0701\u0702\t")
        buf.write("\25\2\2\u0702\u0089\3\2\2\2\u0703\u0704\5@!\2\u0704\u0705")
        buf.write("\7\u009c\2\2\u0705\u070e\3\2\2\2\u0706\u0707\5@!\2\u0707")
        buf.write("\u0708\7\u009f\2\2\u0708\u070e\3\2\2\2\u0709\u070a\7\u009e")
        buf.write("\2\2\u070a\u070e\7\u0080\2\2\u070b\u070c\7\u009d\2\2\u070c")
        buf.write("\u070e\7\u009c\2\2\u070d\u0703\3\2\2\2\u070d\u0706\3\2")
        buf.write("\2\2\u070d\u0709\3\2\2\2\u070d\u070b\3\2\2\2\u070e\u008b")
        buf.write("\3\2\2\2\u070f\u0710\5@!\2\u0710\u0711\7\u009c\2\2\u0711")
        buf.write("\u071a\3\2\2\2\u0712\u0713\5@!\2\u0713\u0714\7\u009f\2")
        buf.write("\2\u0714\u071a\3\2\2\2\u0715\u0716\7\u009e\2\2\u0716\u071a")
        buf.write("\7\u0080\2\2\u0717\u0718\7\u009d\2\2\u0718\u071a\7\u009f")
        buf.write("\2\2\u0719\u070f\3\2\2\2\u0719\u0712\3\2\2\2\u0719\u0715")
        buf.write("\3\2\2\2\u0719\u0717\3\2\2\2\u071a\u008d\3\2\2\2\u071b")
        buf.write("\u071c\5@!\2\u071c\u071d\7\u009c\2\2\u071d\u0723\3\2\2")
        buf.write("\2\u071e\u071f\7\u009d\2\2\u071f\u0723\7\u009c\2\2\u0720")
        buf.write("\u0721\7\u009e\2\2\u0721\u0723\7\u0080\2\2\u0722\u071b")
        buf.write("\3\2\2\2\u0722\u071e\3\2\2\2\u0722\u0720\3\2\2\2\u0723")
        buf.write("\u008f\3\2\2\2\u0724\u0725\t\26\2\2\u0725\u0726\7\5\2")
        buf.write("\2\u0726\u0727\5@!\2\u0727\u0728\7\6\2\2\u0728\u0729\7")
        buf.write("\u0099\2\2\u0729\u072b\7\5\2\2\u072a\u072c\5\u0096L\2")
        buf.write("\u072b\u072a\3\2\2\2\u072b\u072c\3\2\2\2\u072c\u072d\3")
        buf.write("\2\2\2\u072d\u072f\5\u009aN\2\u072e\u0730\5x=\2\u072f")
        buf.write("\u072e\3\2\2\2\u072f\u0730\3\2\2\2\u0730\u0731\3\2\2\2")
        buf.write("\u0731\u0732\7\6\2\2\u0732\u077a\3\2\2\2\u0733\u0734\t")
        buf.write("\27\2\2\u0734\u0735\7\5\2\2\u0735\u0736\7\6\2\2\u0736")
        buf.write("\u0737\7\u0099\2\2\u0737\u0739\7\5\2\2\u0738\u073a\5\u0096")
        buf.write("L\2\u0739\u0738\3\2\2\2\u0739\u073a\3\2\2\2\u073a\u073c")
        buf.write("\3\2\2\2\u073b\u073d\5\u0098M\2\u073c\u073b\3\2\2\2\u073c")
        buf.write("\u073d\3\2\2\2\u073d\u073e\3\2\2\2\u073e\u077a\7\6\2\2")
        buf.write("\u073f\u0740\t\30\2\2\u0740\u0741\7\5\2\2\u0741\u0742")
        buf.write("\7\6\2\2\u0742\u0743\7\u0099\2\2\u0743\u0745\7\5\2\2\u0744")
        buf.write("\u0746\5\u0096L\2\u0745\u0744\3\2\2\2\u0745\u0746\3\2")
        buf.write("\2\2\u0746\u0747\3\2\2\2\u0747\u0748\5\u009aN\2\u0748")
        buf.write("\u0749\7\6\2\2\u0749\u077a\3\2\2\2\u074a\u074b\t\31\2")
        buf.write("\2\u074b\u074c\7\5\2\2\u074c\u074e\5@!\2\u074d\u074f\5")
        buf.write("\u0092J\2\u074e\u074d\3\2\2\2\u074e\u074f\3\2\2\2\u074f")
        buf.write("\u0751\3\2\2\2\u0750\u0752\5\u0094K\2\u0751\u0750\3\2")
        buf.write("\2\2\u0751\u0752\3\2\2\2\u0752\u0753\3\2\2\2\u0753\u0754")
        buf.write("\7\6\2\2\u0754\u0755\7\u0099\2\2\u0755\u0757\7\5\2\2\u0756")
        buf.write("\u0758\5\u0096L\2\u0757\u0756\3\2\2\2\u0757\u0758\3\2")
        buf.write("\2\2\u0758\u0759\3\2\2\2\u0759\u075a\5\u009aN\2\u075a")
        buf.write("\u075b\7\6\2\2\u075b\u077a\3\2\2\2\u075c\u075d\7\u00a5")
        buf.write("\2\2\u075d\u075e\7\5\2\2\u075e\u075f\5@!\2\u075f\u0760")
        buf.write("\7\7\2\2\u0760\u0761\5$\23\2\u0761\u0762\7\6\2\2\u0762")
        buf.write("\u0763\7\u0099\2\2\u0763\u0765\7\5\2\2\u0764\u0766\5\u0096")
        buf.write("L\2\u0765\u0764\3\2\2\2\u0765\u0766\3\2\2\2\u0766\u0767")
        buf.write("\3\2\2\2\u0767\u0769\5\u009aN\2\u0768\u076a\5x=\2\u0769")
        buf.write("\u0768\3\2\2\2\u0769\u076a\3\2\2\2\u076a\u076b\3\2\2\2")
        buf.write("\u076b\u076c\7\6\2\2\u076c\u077a\3\2\2\2\u076d\u076e\7")
        buf.write("\u00a6\2\2\u076e\u076f\7\5\2\2\u076f\u0770\5@!\2\u0770")
        buf.write("\u0771\7\6\2\2\u0771\u0772\7\u0099\2\2\u0772\u0774\7\5")
        buf.write("\2\2\u0773\u0775\5\u0096L\2\u0774\u0773\3\2\2\2\u0774")
        buf.write("\u0775\3\2\2\2\u0775\u0776\3\2\2\2\u0776\u0777\5\u009a")
        buf.write("N\2\u0777\u0778\7\6\2\2\u0778\u077a\3\2\2\2\u0779\u0724")
        buf.write("\3\2\2\2\u0779\u0733\3\2\2\2\u0779\u073f\3\2\2\2\u0779")
        buf.write("\u074a\3\2\2\2\u0779\u075c\3\2\2\2\u0779\u076d\3\2\2\2")
        buf.write("\u077a\u0091\3\2\2\2\u077b\u077c\7\7\2\2\u077c\u077d\5")
        buf.write("$\23\2\u077d\u0093\3\2\2\2\u077e\u077f\7\7\2\2\u077f\u0780")
        buf.write("\5$\23\2\u0780\u0095\3\2\2\2\u0781\u0782\7\u009a\2\2\u0782")
        buf.write("\u0784\7*\2\2\u0783\u0785\5@!\2\u0784\u0783\3\2\2\2\u0785")
        buf.write("\u0786\3\2\2\2\u0786\u0784\3\2\2\2\u0786\u0787\3\2\2\2")
        buf.write("\u0787\u0097\3\2\2\2\u0788\u0789\7o\2\2\u0789\u078b\7")
        buf.write("*\2\2\u078a\u078c\5@!\2\u078b\u078a\3\2\2\2\u078c\u078d")
        buf.write("\3\2\2\2\u078d\u078b\3\2\2\2\u078d\u078e\3\2\2\2\u078e")
        buf.write("\u0099\3\2\2\2\u078f\u0790\7o\2\2\u0790\u0791\7*\2\2\u0791")
        buf.write("\u0792\5\u009aN\2\u0792\u009b\3\2\2\2\u0793\u0795\5@!")
        buf.write("\2\u0794\u0796\5\u0088E\2\u0795\u0794\3\2\2\2\u0795\u0796")
        buf.write("\3\2\2\2\u0796\u079e\3\2\2\2\u0797\u0798\7\7\2\2\u0798")
        buf.write("\u079a\5@!\2\u0799\u079b\5\u0088E\2\u079a\u0799\3\2\2")
        buf.write("\2\u079a\u079b\3\2\2\2\u079b\u079d\3\2\2\2\u079c\u0797")
        buf.write("\3\2\2\2\u079d\u07a0\3\2\2\2\u079e\u079c\3\2\2\2\u079e")
        buf.write("\u079f\3\2\2\2\u079f\u009d\3\2\2\2\u07a0\u079e\3\2\2\2")
        buf.write("\u07a1\u07a2\5P)\2\u07a2\u009f\3\2\2\2\u07a3\u07a4\5P")
        buf.write(")\2\u07a4\u00a1\3\2\2\2\u07a5\u07a6\t\32\2\2\u07a6\u00a3")
        buf.write("\3\2\2\2\u07a7\u07a8\7\u00bd\2\2\u07a8\u00a5\3\2\2\2\u07a9")
        buf.write("\u07ac\5@!\2\u07aa\u07ac\5\36\20\2\u07ab\u07a9\3\2\2\2")
        buf.write("\u07ab\u07aa\3\2\2\2\u07ac\u00a7\3\2\2\2\u07ad\u07ae\t")
        buf.write("\33\2\2\u07ae\u00a9\3\2\2\2\u07af\u07b0\t\34\2\2\u07b0")
        buf.write("\u00ab\3\2\2\2\u07b1\u07b2\5\u00dco\2\u07b2\u00ad\3\2")
        buf.write("\2\2\u07b3\u07b4\5\u00dco\2\u07b4\u00af\3\2\2\2\u07b5")
        buf.write("\u07b6\5\u00dco\2\u07b6\u00b1\3\2\2\2\u07b7\u07b8\5\u00dc")
        buf.write("o\2\u07b8\u00b3\3\2\2\2\u07b9\u07ba\5\u00dco\2\u07ba\u00b5")
        buf.write("\3\2\2\2\u07bb\u07bc\5\u00dco\2\u07bc\u00b7\3\2\2\2\u07bd")
        buf.write("\u07be\5\u00dco\2\u07be\u00b9\3\2\2\2\u07bf\u07c0\5\u00dc")
        buf.write("o\2\u07c0\u00bb\3\2\2\2\u07c1\u07c2\5\u00dco\2\u07c2\u00bd")
        buf.write("\3\2\2\2\u07c3\u07c4\5\u00dco\2\u07c4\u00bf\3\2\2\2\u07c5")
        buf.write("\u07c6\5\u00dco\2\u07c6\u00c1\3\2\2\2\u07c7\u07c8\5\u00dc")
        buf.write("o\2\u07c8\u00c3\3\2\2\2\u07c9\u07ca\5\u00dco\2\u07ca\u00c5")
        buf.write("\3\2\2\2\u07cb\u07cc\5\u00dco\2\u07cc\u00c7\3\2\2\2\u07cd")
        buf.write("\u07ce\5\u00dco\2\u07ce\u00c9\3\2\2\2\u07cf\u07d0\5\u00dc")
        buf.write("o\2\u07d0\u00cb\3\2\2\2\u07d1\u07d2\5\u00dco\2\u07d2\u00cd")
        buf.write("\3\2\2\2\u07d3\u07d4\5\u00dco\2\u07d4\u00cf\3\2\2\2\u07d5")
        buf.write("\u07d6\5\u00dco\2\u07d6\u00d1\3\2\2\2\u07d7\u07d8\5\u00dc")
        buf.write("o\2\u07d8\u00d3\3\2\2\2\u07d9\u07da\5\u00dco\2\u07da\u00d5")
        buf.write("\3\2\2\2\u07db\u07dc\5\u00dco\2\u07dc\u00d7\3\2\2\2\u07dd")
        buf.write("\u07de\5\u00dco\2\u07de\u00d9\3\2\2\2\u07df\u07e0\5\u00dc")
        buf.write("o\2\u07e0\u00db\3\2\2\2\u07e1\u07e9\7\u00ba\2\2\u07e2")
        buf.write("\u07e9\5\u00aaV\2\u07e3\u07e9\7\u00bd\2\2\u07e4\u07e5")
        buf.write("\7\5\2\2\u07e5\u07e6\5\u00dco\2\u07e6\u07e7\7\6\2\2\u07e7")
        buf.write("\u07e9\3\2\2\2\u07e8\u07e1\3\2\2\2\u07e8\u07e2\3\2\2\2")
        buf.write("\u07e8\u07e3\3\2\2\2\u07e8\u07e4\3\2\2\2\u07e9\u00dd\3")
        buf.write("\2\2\2\u0120\u00e1\u00e9\u00f0\u00f5\u00fb\u0101\u0103")
        buf.write("\u011c\u0123\u012a\u0130\u0134\u0137\u013e\u0141\u0145")
        buf.write("\u014d\u0151\u0153\u0157\u015b\u015f\u0162\u0169\u016f")
        buf.write("\u0175\u017a\u0185\u018b\u018f\u0193\u0196\u019a\u01a0")
        buf.write("\u01a5\u01ae\u01b5\u01bb\u01bf\u01c3\u01c8\u01ce\u01da")
        buf.write("\u01de\u01e3\u01e6\u01e9\u01ee\u01f1\u01ff\u0206\u020d")
        buf.write("\u020f\u0212\u0218\u021d\u0225\u022a\u0239\u023f\u0249")
        buf.write("\u024e\u0258\u025c\u025e\u0262\u0267\u0269\u0271\u0277")
        buf.write("\u027c\u0283\u028e\u0291\u0293\u029a\u029e\u02a5\u02ab")
        buf.write("\u02b1\u02b7\u02bc\u02c5\u02ca\u02d5\u02da\u02e5\u02ea")
        buf.write("\u02ee\u02fe\u0308\u030d\u0315\u0321\u0326\u032e\u0335")
        buf.write("\u0338\u033f\u0342\u0345\u0349\u0353\u0358\u0361\u0368")
        buf.write("\u036c\u0370\u0373\u037b\u0388\u038b\u0393\u039c\u03a0")
        buf.write("\u03a5\u03c3\u03cf\u03d4\u03e0\u03e6\u03ed\u03f1\u03fb")
        buf.write("\u03fe\u0404\u040a\u0413\u0416\u041a\u041c\u041e\u0427")
        buf.write("\u042e\u0435\u043b\u0440\u0448\u044d\u0456\u0461\u0468")
        buf.write("\u046c\u046f\u0473\u047d\u0483\u0485\u048d\u0494\u049b")
        buf.write("\u04a0\u04a2\u04a8\u04b1\u04b6\u04bd\u04c1\u04c3\u04c6")
        buf.write("\u04ce\u04d2\u04d5\u04db\u04df\u04e4\u04eb\u04f4\u04f8")
        buf.write("\u04fa\u04fe\u0507\u050c\u050e\u051b\u051e\u0527\u0532")
        buf.write("\u0539\u053c\u0541\u0545\u0548\u054b\u0550\u0554\u0559")
        buf.write("\u055c\u055f\u0564\u0568\u056b\u0572\u0577\u0580\u0585")
        buf.write("\u0588\u0590\u0594\u059c\u059f\u05a1\u05aa\u05ad\u05af")
        buf.write("\u05b3\u05b7\u05bb\u05be\u05c9\u05ce\u05d2\u05d6\u05d9")
        buf.write("\u05de\u05e4\u05eb\u05f2\u05f7\u05ff\u0605\u060a\u0610")
        buf.write("\u0617\u061e\u0623\u0626\u0629\u062e\u0633\u063a\u063e")
        buf.write("\u0642\u064c\u0655\u0658\u0661\u0665\u066d\u0676\u0679")
        buf.write("\u0682\u0685\u0688\u068b\u0695\u069e\u06a7\u06ab\u06b2")
        buf.write("\u06b9\u06bd\u06c1\u06ca\u06ce\u06d2\u06d7\u06db\u06e2")
        buf.write("\u06ec\u06f3\u06f8\u06fb\u06ff\u070d\u0719\u0722\u072b")
        buf.write("\u072f\u0739\u073c\u0745\u074e\u0751\u0757\u0765\u0769")
        buf.write("\u0774\u0779\u0786\u078d\u0795\u079a\u079e\u07ab\u07e8")
        return buf.getvalue()


class GrammarParser ( Parser ):

    grammarFileName = "Grammar.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "';'", "'.'", "'('", "')'", "','", "'='", 
                     "'*'", "'+'", "'-'", "'~'", "'||'", "'/'", "'%'", "'<<'", 
                     "'>>'", "'&'", "'|'", "'<'", "'<='", "'>'", "'>='", 
                     "'=='", "'!='", "'<>'" ]

    symbolicNames = [ "<INVALID>", "SCOL", "DOT", "OPEN_PAR", "CLOSE_PAR", 
                      "COMMA", "ASSIGN", "STAR", "PLUS", "MINUS", "TILDE", 
                      "PIPE2", "DIV", "MOD", "LT2", "GT2", "AMP", "PIPE", 
                      "LT", "LT_EQ", "GT", "GT_EQ", "EQ", "NOT_EQ1", "NOT_EQ2", 
                      "ABORT_", "ACTION_", "ADD_", "AFTER_", "ALL_", "ALTER_", 
                      "ANALYZE_", "AND_", "AS_", "ASC_", "ATTACH_", "AUTOINCREMENT_", 
                      "BEFORE_", "BEGIN_", "BETWEEN_", "BY_", "CASCADE_", 
                      "CASE_", "CAST_", "CHECK_", "COLLATE_", "COLUMN_", 
                      "COMMIT_", "CONFLICT_", "CONSTRAINT_", "CREATE_", 
                      "CROSS_", "CURRENT_DATE_", "CURRENT_TIME_", "CURRENT_TIMESTAMP_", 
                      "DATABASE_", "DEFAULT_", "DEFERRABLE_", "DEFERRED_", 
                      "DELETE_", "DESC_", "DETACH_", "DISTINCT_", "DROP_", 
                      "EACH_", "ELSE_", "END_", "ESCAPE_", "EXCEPT_", "EXCLUSIVE_", 
                      "EXISTS_", "EXPLAIN_", "FAIL_", "FOR_", "FOREIGN_", 
                      "FROM_", "FULL_", "GLOB_", "GROUP_", "HAVING_", "IF_", 
                      "IGNORE_", "IMMEDIATE_", "IN_", "INDEX_", "INDEXED_", 
                      "INITIALLY_", "INNER_", "INSERT_", "INSTEAD_", "INTERSECT_", 
                      "INTO_", "IS_", "ISNULL_", "JOIN_", "KEY_", "LEFT_", 
                      "LIKE_", "LIMIT_", "MATCH_", "NATURAL_", "NO_", "NOT_", 
                      "NOTNULL_", "NULL_", "OF_", "OFFSET_", "ON_", "OR_", 
                      "ORDER_", "OUTER_", "PLAN_", "PRAGMA_", "PRIMARY_", 
                      "QUERY_", "RAISE_", "RECURSIVE_", "REFERENCES_", "REGEXP_", 
                      "REINDEX_", "RELEASE_", "RENAME_", "REPLACE_", "RESTRICT_", 
                      "RIGHT_", "ROLLBACK_", "ROW_", "ROWS_", "SAVEPOINT_", 
                      "SELECT_", "SET_", "TABLE_", "TEMP_", "TEMPORARY_", 
                      "THEN_", "TO_", "TRANSACTION_", "TRIGGER_", "UNION_", 
                      "UNIQUE_", "UPDATE_", "USING_", "VACUUM_", "VALUES_", 
                      "VIEW_", "VIRTUAL_", "WHEN_", "WHERE_", "WITH_", "WITHOUT_", 
                      "FIRST_VALUE_", "OVER_", "PARTITION_", "RANGE_", "PRECEDING_", 
                      "UNBOUNDED_", "CURRENT_", "FOLLOWING_", "CUME_DIST_", 
                      "DENSE_RANK_", "LAG_", "LAST_VALUE_", "LEAD_", "NTH_VALUE_", 
                      "NTILE_", "PERCENT_RANK_", "RANK_", "ROW_NUMBER_", 
                      "GENERATED_", "ALWAYS_", "STORED_", "TRUE_", "FALSE_", 
                      "WINDOW_", "NULLS_", "FIRST_", "LAST_", "FILTER_", 
                      "GROUPS_", "EXCLUDE_", "TIES_", "OTHERS_", "DO_", 
                      "NOTHING_", "IDENTIFIER", "NUMERIC_LITERAL", "BIND_PARAMETER", 
                      "STRING_LITERAL", "BLOB_LITERAL", "SINGLE_LINE_COMMENT", 
                      "MULTILINE_COMMENT", "SPACES", "UNEXPECTED_CHAR" ]

    RULE_parse = 0
    RULE_sql_stmt_list = 1
    RULE_sql_stmt = 2
    RULE_alter_table_stmt = 3
    RULE_analyze_stmt = 4
    RULE_attach_stmt = 5
    RULE_begin_stmt = 6
    RULE_commit_stmt = 7
    RULE_rollback_stmt = 8
    RULE_savepoint_stmt = 9
    RULE_release_stmt = 10
    RULE_create_index_stmt = 11
    RULE_indexed_column = 12
    RULE_create_table_stmt = 13
    RULE_column_def = 14
    RULE_type_name = 15
    RULE_column_constraint = 16
    RULE_signed_number = 17
    RULE_table_constraint = 18
    RULE_foreign_key_clause = 19
    RULE_conflict_clause = 20
    RULE_create_trigger_stmt = 21
    RULE_create_view_stmt = 22
    RULE_create_virtual_table_stmt = 23
    RULE_with_clause = 24
    RULE_cte_table_name = 25
    RULE_recursive_cte = 26
    RULE_common_table_expression = 27
    RULE_delete_stmt = 28
    RULE_delete_stmt_limited = 29
    RULE_detach_stmt = 30
    RULE_expr = 31
    RULE_raise_function = 32
    RULE_literal_value = 33
    RULE_insert_stmt = 34
    RULE_upsert_clause = 35
    RULE_pragma_stmt = 36
    RULE_pragma_value = 37
    RULE_reindex_stmt = 38
    RULE_select_stmt = 39
    RULE_join_clause = 40
    RULE_select_core = 41
    RULE_factored_select_stmt = 42
    RULE_simple_select_stmt = 43
    RULE_compound_select_stmt = 44
    RULE_table_or_subquery = 45
    RULE_result_column = 46
    RULE_join_operator = 47
    RULE_join_constraint = 48
    RULE_compound_operator = 49
    RULE_update_stmt = 50
    RULE_column_name_list = 51
    RULE_update_stmt_limited = 52
    RULE_qualified_table_name = 53
    RULE_vacuum_stmt = 54
    RULE_filter_clause = 55
    RULE_window_defn = 56
    RULE_over_clause = 57
    RULE_frame_spec = 58
    RULE_frame_clause = 59
    RULE_simple_function_invocation = 60
    RULE_aggregate_function_invocation = 61
    RULE_window_function_invocation = 62
    RULE_common_table_stmt = 63
    RULE_order_by_stmt = 64
    RULE_limit_stmt = 65
    RULE_ordering_term = 66
    RULE_asc_desc = 67
    RULE_frame_left = 68
    RULE_frame_right = 69
    RULE_frame_single = 70
    RULE_window_function = 71
    RULE_of_OF_fset = 72
    RULE_default_DEFAULT__value = 73
    RULE_partition_by = 74
    RULE_order_by_expr = 75
    RULE_order_by_expr_asc_desc = 76
    RULE_expr_asc_desc = 77
    RULE_initial_select = 78
    RULE_recursive__select = 79
    RULE_unary_operator = 80
    RULE_error_message = 81
    RULE_module_argument = 82
    RULE_column_alias = 83
    RULE_keyword = 84
    RULE_name = 85
    RULE_function_name = 86
    RULE_schema_name = 87
    RULE_table_name = 88
    RULE_table_or_index_name = 89
    RULE_new_table_name = 90
    RULE_column_name = 91
    RULE_collation_name = 92
    RULE_foreign_table = 93
    RULE_index_name = 94
    RULE_trigger_name = 95
    RULE_view_name = 96
    RULE_module_name = 97
    RULE_pragma_name = 98
    RULE_savepoint_name = 99
    RULE_table_alias = 100
    RULE_transaction_name = 101
    RULE_window_name = 102
    RULE_alias = 103
    RULE_filename = 104
    RULE_base_window_name = 105
    RULE_simple_func = 106
    RULE_aggregate_func = 107
    RULE_table_function_name = 108
    RULE_any_name = 109

    ruleNames =  [ "parse", "sql_stmt_list", "sql_stmt", "alter_table_stmt", 
                   "analyze_stmt", "attach_stmt", "begin_stmt", "commit_stmt", 
                   "rollback_stmt", "savepoint_stmt", "release_stmt", "create_index_stmt", 
                   "indexed_column", "create_table_stmt", "column_def", 
                   "type_name", "column_constraint", "signed_number", "table_constraint", 
                   "foreign_key_clause", "conflict_clause", "create_trigger_stmt", 
                   "create_view_stmt", "create_virtual_table_stmt", "with_clause", 
                   "cte_table_name", "recursive_cte", "common_table_expression", 
                   "delete_stmt", "delete_stmt_limited", "detach_stmt", 
                   "expr", "raise_function", "literal_value", "insert_stmt", 
                   "upsert_clause", "pragma_stmt", "pragma_value", "reindex_stmt", 
                   "select_stmt", "join_clause", "select_core", "factored_select_stmt", 
                   "simple_select_stmt", "compound_select_stmt", "table_or_subquery", 
                   "result_column", "join_operator", "join_constraint", 
                   "compound_operator", "update_stmt", "column_name_list", 
                   "update_stmt_limited", "qualified_table_name", "vacuum_stmt", 
                   "filter_clause", "window_defn", "over_clause", "frame_spec", 
                   "frame_clause", "simple_function_invocation", "aggregate_function_invocation", 
                   "window_function_invocation", "common_table_stmt", "order_by_stmt", 
                   "limit_stmt", "ordering_term", "asc_desc", "frame_left", 
                   "frame_right", "frame_single", "window_function", "of_OF_fset", 
                   "default_DEFAULT__value", "partition_by", "order_by_expr", 
                   "order_by_expr_asc_desc", "expr_asc_desc", "initial_select", 
                   "recursive__select", "unary_operator", "error_message", 
                   "module_argument", "column_alias", "keyword", "name", 
                   "function_name", "schema_name", "table_name", "table_or_index_name", 
                   "new_table_name", "column_name", "collation_name", "foreign_table", 
                   "index_name", "trigger_name", "view_name", "module_name", 
                   "pragma_name", "savepoint_name", "table_alias", "transaction_name", 
                   "window_name", "alias", "filename", "base_window_name", 
                   "simple_func", "aggregate_func", "table_function_name", 
                   "any_name" ]

    EOF = Token.EOF
    SCOL=1
    DOT=2
    OPEN_PAR=3
    CLOSE_PAR=4
    COMMA=5
    ASSIGN=6
    STAR=7
    PLUS=8
    MINUS=9
    TILDE=10
    PIPE2=11
    DIV=12
    MOD=13
    LT2=14
    GT2=15
    AMP=16
    PIPE=17
    LT=18
    LT_EQ=19
    GT=20
    GT_EQ=21
    EQ=22
    NOT_EQ1=23
    NOT_EQ2=24
    ABORT_=25
    ACTION_=26
    ADD_=27
    AFTER_=28
    ALL_=29
    ALTER_=30
    ANALYZE_=31
    AND_=32
    AS_=33
    ASC_=34
    ATTACH_=35
    AUTOINCREMENT_=36
    BEFORE_=37
    BEGIN_=38
    BETWEEN_=39
    BY_=40
    CASCADE_=41
    CASE_=42
    CAST_=43
    CHECK_=44
    COLLATE_=45
    COLUMN_=46
    COMMIT_=47
    CONFLICT_=48
    CONSTRAINT_=49
    CREATE_=50
    CROSS_=51
    CURRENT_DATE_=52
    CURRENT_TIME_=53
    CURRENT_TIMESTAMP_=54
    DATABASE_=55
    DEFAULT_=56
    DEFERRABLE_=57
    DEFERRED_=58
    DELETE_=59
    DESC_=60
    DETACH_=61
    DISTINCT_=62
    DROP_=63
    EACH_=64
    ELSE_=65
    END_=66
    ESCAPE_=67
    EXCEPT_=68
    EXCLUSIVE_=69
    EXISTS_=70
    EXPLAIN_=71
    FAIL_=72
    FOR_=73
    FOREIGN_=74
    FROM_=75
    FULL_=76
    GLOB_=77
    GROUP_=78
    HAVING_=79
    IF_=80
    IGNORE_=81
    IMMEDIATE_=82
    IN_=83
    INDEX_=84
    INDEXED_=85
    INITIALLY_=86
    INNER_=87
    INSERT_=88
    INSTEAD_=89
    INTERSECT_=90
    INTO_=91
    IS_=92
    ISNULL_=93
    JOIN_=94
    KEY_=95
    LEFT_=96
    LIKE_=97
    LIMIT_=98
    MATCH_=99
    NATURAL_=100
    NO_=101
    NOT_=102
    NOTNULL_=103
    NULL_=104
    OF_=105
    OFFSET_=106
    ON_=107
    OR_=108
    ORDER_=109
    OUTER_=110
    PLAN_=111
    PRAGMA_=112
    PRIMARY_=113
    QUERY_=114
    RAISE_=115
    RECURSIVE_=116
    REFERENCES_=117
    REGEXP_=118
    REINDEX_=119
    RELEASE_=120
    RENAME_=121
    REPLACE_=122
    RESTRICT_=123
    RIGHT_=124
    ROLLBACK_=125
    ROW_=126
    ROWS_=127
    SAVEPOINT_=128
    SELECT_=129
    SET_=130
    TABLE_=131
    TEMP_=132
    TEMPORARY_=133
    THEN_=134
    TO_=135
    TRANSACTION_=136
    TRIGGER_=137
    UNION_=138
    UNIQUE_=139
    UPDATE_=140
    USING_=141
    VACUUM_=142
    VALUES_=143
    VIEW_=144
    VIRTUAL_=145
    WHEN_=146
    WHERE_=147
    WITH_=148
    WITHOUT_=149
    FIRST_VALUE_=150
    OVER_=151
    PARTITION_=152
    RANGE_=153
    PRECEDING_=154
    UNBOUNDED_=155
    CURRENT_=156
    FOLLOWING_=157
    CUME_DIST_=158
    DENSE_RANK_=159
    LAG_=160
    LAST_VALUE_=161
    LEAD_=162
    NTH_VALUE_=163
    NTILE_=164
    PERCENT_RANK_=165
    RANK_=166
    ROW_NUMBER_=167
    GENERATED_=168
    ALWAYS_=169
    STORED_=170
    TRUE_=171
    FALSE_=172
    WINDOW_=173
    NULLS_=174
    FIRST_=175
    LAST_=176
    FILTER_=177
    GROUPS_=178
    EXCLUDE_=179
    TIES_=180
    OTHERS_=181
    DO_=182
    NOTHING_=183
    IDENTIFIER=184
    NUMERIC_LITERAL=185
    BIND_PARAMETER=186
    STRING_LITERAL=187
    BLOB_LITERAL=188
    SINGLE_LINE_COMMENT=189
    MULTILINE_COMMENT=190
    SPACES=191
    UNEXPECTED_CHAR=192

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class ParseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(GrammarParser.EOF, 0)

        def sql_stmt_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Sql_stmt_listContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Sql_stmt_listContext,i)


        def getRuleIndex(self):
            return GrammarParser.RULE_parse

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitParse" ):
                return visitor.visitParse(self)
            else:
                return visitor.visitChildren(self)




    def parse(self):

        localctx = GrammarParser.ParseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_parse)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.SCOL) | (1 << GrammarParser.ALTER_) | (1 << GrammarParser.ANALYZE_) | (1 << GrammarParser.ATTACH_) | (1 << GrammarParser.BEGIN_) | (1 << GrammarParser.COMMIT_) | (1 << GrammarParser.CREATE_) | (1 << GrammarParser.DEFAULT_) | (1 << GrammarParser.DELETE_) | (1 << GrammarParser.DETACH_))) != 0) or ((((_la - 66)) & ~0x3f) == 0 and ((1 << (_la - 66)) & ((1 << (GrammarParser.END_ - 66)) | (1 << (GrammarParser.EXPLAIN_ - 66)) | (1 << (GrammarParser.INSERT_ - 66)) | (1 << (GrammarParser.PRAGMA_ - 66)) | (1 << (GrammarParser.REINDEX_ - 66)) | (1 << (GrammarParser.RELEASE_ - 66)) | (1 << (GrammarParser.REPLACE_ - 66)) | (1 << (GrammarParser.ROLLBACK_ - 66)) | (1 << (GrammarParser.SAVEPOINT_ - 66)) | (1 << (GrammarParser.SELECT_ - 66)))) != 0) or ((((_la - 140)) & ~0x3f) == 0 and ((1 << (_la - 140)) & ((1 << (GrammarParser.UPDATE_ - 140)) | (1 << (GrammarParser.VACUUM_ - 140)) | (1 << (GrammarParser.VALUES_ - 140)) | (1 << (GrammarParser.WITH_ - 140)))) != 0):
                self.state = 220
                self.sql_stmt_list()
                self.state = 225
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 226
            self.match(GrammarParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_stmt_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def sql_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Sql_stmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Sql_stmtContext,i)


        def SCOL(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.SCOL)
            else:
                return self.getToken(GrammarParser.SCOL, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_sql_stmt_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSql_stmt_list" ):
                return visitor.visitSql_stmt_list(self)
            else:
                return visitor.visitChildren(self)




    def sql_stmt_list(self):

        localctx = GrammarParser.Sql_stmt_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_sql_stmt_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 231
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.SCOL:
                self.state = 228
                self.match(GrammarParser.SCOL)
                self.state = 233
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 234
            self.sql_stmt()
            self.state = 243
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,3,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 236 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 235
                        self.match(GrammarParser.SCOL)
                        self.state = 238 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==GrammarParser.SCOL):
                            break

                    self.state = 240
                    self.sql_stmt() 
                self.state = 245
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,3,self._ctx)

            self.state = 249
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,4,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 246
                    self.match(GrammarParser.SCOL) 
                self.state = 251
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,4,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sql_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def alter_table_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Alter_table_stmtContext,0)


        def analyze_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Analyze_stmtContext,0)


        def attach_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Attach_stmtContext,0)


        def begin_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Begin_stmtContext,0)


        def commit_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Commit_stmtContext,0)


        def create_index_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Create_index_stmtContext,0)


        def create_table_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Create_table_stmtContext,0)


        def create_trigger_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Create_trigger_stmtContext,0)


        def create_view_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Create_view_stmtContext,0)


        def create_virtual_table_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Create_virtual_table_stmtContext,0)


        def delete_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Delete_stmtContext,0)


        def delete_stmt_limited(self):
            return self.getTypedRuleContext(GrammarParser.Delete_stmt_limitedContext,0)


        def detach_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Detach_stmtContext,0)


        def insert_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Insert_stmtContext,0)


        def pragma_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Pragma_stmtContext,0)


        def reindex_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Reindex_stmtContext,0)


        def release_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Release_stmtContext,0)


        def rollback_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Rollback_stmtContext,0)


        def savepoint_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Savepoint_stmtContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def update_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Update_stmtContext,0)


        def update_stmt_limited(self):
            return self.getTypedRuleContext(GrammarParser.Update_stmt_limitedContext,0)


        def vacuum_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Vacuum_stmtContext,0)


        def EXPLAIN_(self):
            return self.getToken(GrammarParser.EXPLAIN_, 0)

        def QUERY_(self):
            return self.getToken(GrammarParser.QUERY_, 0)

        def PLAN_(self):
            return self.getToken(GrammarParser.PLAN_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_sql_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSql_stmt" ):
                return visitor.visitSql_stmt(self)
            else:
                return visitor.visitChildren(self)




    def sql_stmt(self):

        localctx = GrammarParser.Sql_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_sql_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 257
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.EXPLAIN_:
                self.state = 252
                self.match(GrammarParser.EXPLAIN_)
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.QUERY_:
                    self.state = 253
                    self.match(GrammarParser.QUERY_)
                    self.state = 254
                    self.match(GrammarParser.PLAN_)




            self.state = 282
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                self.state = 259
                self.alter_table_stmt()
                pass

            elif la_ == 2:
                self.state = 260
                self.analyze_stmt()
                pass

            elif la_ == 3:
                self.state = 261
                self.attach_stmt()
                pass

            elif la_ == 4:
                self.state = 262
                self.begin_stmt()
                pass

            elif la_ == 5:
                self.state = 263
                self.commit_stmt()
                pass

            elif la_ == 6:
                self.state = 264
                self.create_index_stmt()
                pass

            elif la_ == 7:
                self.state = 265
                self.create_table_stmt()
                pass

            elif la_ == 8:
                self.state = 266
                self.create_trigger_stmt()
                pass

            elif la_ == 9:
                self.state = 267
                self.create_view_stmt()
                pass

            elif la_ == 10:
                self.state = 268
                self.create_virtual_table_stmt()
                pass

            elif la_ == 11:
                self.state = 269
                self.delete_stmt()
                pass

            elif la_ == 12:
                self.state = 270
                self.delete_stmt_limited()
                pass

            elif la_ == 13:
                self.state = 271
                self.detach_stmt()
                pass

            elif la_ == 14:
                self.state = 272
                self.insert_stmt()
                pass

            elif la_ == 15:
                self.state = 273
                self.pragma_stmt()
                pass

            elif la_ == 16:
                self.state = 274
                self.reindex_stmt()
                pass

            elif la_ == 17:
                self.state = 275
                self.release_stmt()
                pass

            elif la_ == 18:
                self.state = 276
                self.rollback_stmt()
                pass

            elif la_ == 19:
                self.state = 277
                self.savepoint_stmt()
                pass

            elif la_ == 20:
                self.state = 278
                self.select_stmt()
                pass

            elif la_ == 21:
                self.state = 279
                self.update_stmt()
                pass

            elif la_ == 22:
                self.state = 280
                self.update_stmt_limited()
                pass

            elif la_ == 23:
                self.state = 281
                self.vacuum_stmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_table_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.old_column_name = None # Column_nameContext
            self.new_column_name = None # Column_nameContext

        def ALTER_(self):
            return self.getToken(GrammarParser.ALTER_, 0)

        def TABLE_(self):
            return self.getToken(GrammarParser.TABLE_, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def RENAME_(self):
            return self.getToken(GrammarParser.RENAME_, 0)

        def ADD_(self):
            return self.getToken(GrammarParser.ADD_, 0)

        def column_def(self):
            return self.getTypedRuleContext(GrammarParser.Column_defContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def TO_(self):
            return self.getToken(GrammarParser.TO_, 0)

        def new_table_name(self):
            return self.getTypedRuleContext(GrammarParser.New_table_nameContext,0)


        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def COLUMN_(self):
            return self.getToken(GrammarParser.COLUMN_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_alter_table_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlter_table_stmt" ):
                return visitor.visitAlter_table_stmt(self)
            else:
                return visitor.visitChildren(self)




    def alter_table_stmt(self):

        localctx = GrammarParser.Alter_table_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_alter_table_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 284
            self.match(GrammarParser.ALTER_)
            self.state = 285
            self.match(GrammarParser.TABLE_)
            self.state = 289
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,8,self._ctx)
            if la_ == 1:
                self.state = 286
                self.schema_name()
                self.state = 287
                self.match(GrammarParser.DOT)


            self.state = 291
            self.table_name()
            self.state = 309
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.RENAME_]:
                self.state = 292
                self.match(GrammarParser.RENAME_)
                self.state = 302
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
                if la_ == 1:
                    self.state = 293
                    self.match(GrammarParser.TO_)
                    self.state = 294
                    self.new_table_name()
                    pass

                elif la_ == 2:
                    self.state = 296
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
                    if la_ == 1:
                        self.state = 295
                        self.match(GrammarParser.COLUMN_)


                    self.state = 298
                    localctx.old_column_name = self.column_name()
                    self.state = 299
                    self.match(GrammarParser.TO_)
                    self.state = 300
                    localctx.new_column_name = self.column_name()
                    pass


                pass
            elif token in [GrammarParser.ADD_]:
                self.state = 304
                self.match(GrammarParser.ADD_)
                self.state = 306
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
                if la_ == 1:
                    self.state = 305
                    self.match(GrammarParser.COLUMN_)


                self.state = 308
                self.column_def()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Analyze_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANALYZE_(self):
            return self.getToken(GrammarParser.ANALYZE_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def table_or_index_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_or_index_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_analyze_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAnalyze_stmt" ):
                return visitor.visitAnalyze_stmt(self)
            else:
                return visitor.visitChildren(self)




    def analyze_stmt(self):

        localctx = GrammarParser.Analyze_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_analyze_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 311
            self.match(GrammarParser.ANALYZE_)
            self.state = 319
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 312
                self.schema_name()

            elif la_ == 2:
                self.state = 316
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
                if la_ == 1:
                    self.state = 313
                    self.schema_name()
                    self.state = 314
                    self.match(GrammarParser.DOT)


                self.state = 318
                self.table_or_index_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Attach_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ATTACH_(self):
            return self.getToken(GrammarParser.ATTACH_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DATABASE_(self):
            return self.getToken(GrammarParser.DATABASE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_attach_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAttach_stmt" ):
                return visitor.visitAttach_stmt(self)
            else:
                return visitor.visitChildren(self)




    def attach_stmt(self):

        localctx = GrammarParser.Attach_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_attach_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 321
            self.match(GrammarParser.ATTACH_)
            self.state = 323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,15,self._ctx)
            if la_ == 1:
                self.state = 322
                self.match(GrammarParser.DATABASE_)


            self.state = 325
            self.expr(0)
            self.state = 326
            self.match(GrammarParser.AS_)
            self.state = 327
            self.schema_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Begin_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BEGIN_(self):
            return self.getToken(GrammarParser.BEGIN_, 0)

        def TRANSACTION_(self):
            return self.getToken(GrammarParser.TRANSACTION_, 0)

        def DEFERRED_(self):
            return self.getToken(GrammarParser.DEFERRED_, 0)

        def IMMEDIATE_(self):
            return self.getToken(GrammarParser.IMMEDIATE_, 0)

        def EXCLUSIVE_(self):
            return self.getToken(GrammarParser.EXCLUSIVE_, 0)

        def transaction_name(self):
            return self.getTypedRuleContext(GrammarParser.Transaction_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_begin_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBegin_stmt" ):
                return visitor.visitBegin_stmt(self)
            else:
                return visitor.visitChildren(self)




    def begin_stmt(self):

        localctx = GrammarParser.Begin_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_begin_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self.match(GrammarParser.BEGIN_)
            self.state = 331
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 58)) & ~0x3f) == 0 and ((1 << (_la - 58)) & ((1 << (GrammarParser.DEFERRED_ - 58)) | (1 << (GrammarParser.EXCLUSIVE_ - 58)) | (1 << (GrammarParser.IMMEDIATE_ - 58)))) != 0):
                self.state = 330
                _la = self._input.LA(1)
                if not(((((_la - 58)) & ~0x3f) == 0 and ((1 << (_la - 58)) & ((1 << (GrammarParser.DEFERRED_ - 58)) | (1 << (GrammarParser.EXCLUSIVE_ - 58)) | (1 << (GrammarParser.IMMEDIATE_ - 58)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 337
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TRANSACTION_:
                self.state = 333
                self.match(GrammarParser.TRANSACTION_)
                self.state = 335
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
                if la_ == 1:
                    self.state = 334
                    self.transaction_name()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Commit_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMIT_(self):
            return self.getToken(GrammarParser.COMMIT_, 0)

        def END_(self):
            return self.getToken(GrammarParser.END_, 0)

        def TRANSACTION_(self):
            return self.getToken(GrammarParser.TRANSACTION_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_commit_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommit_stmt" ):
                return visitor.visitCommit_stmt(self)
            else:
                return visitor.visitChildren(self)




    def commit_stmt(self):

        localctx = GrammarParser.Commit_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_commit_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 339
            _la = self._input.LA(1)
            if not(_la==GrammarParser.COMMIT_ or _la==GrammarParser.END_):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 341
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TRANSACTION_:
                self.state = 340
                self.match(GrammarParser.TRANSACTION_)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rollback_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def TRANSACTION_(self):
            return self.getToken(GrammarParser.TRANSACTION_, 0)

        def TO_(self):
            return self.getToken(GrammarParser.TO_, 0)

        def savepoint_name(self):
            return self.getTypedRuleContext(GrammarParser.Savepoint_nameContext,0)


        def SAVEPOINT_(self):
            return self.getToken(GrammarParser.SAVEPOINT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_rollback_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRollback_stmt" ):
                return visitor.visitRollback_stmt(self)
            else:
                return visitor.visitChildren(self)




    def rollback_stmt(self):

        localctx = GrammarParser.Rollback_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_rollback_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            self.match(GrammarParser.ROLLBACK_)
            self.state = 345
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TRANSACTION_:
                self.state = 344
                self.match(GrammarParser.TRANSACTION_)


            self.state = 352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TO_:
                self.state = 347
                self.match(GrammarParser.TO_)
                self.state = 349
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
                if la_ == 1:
                    self.state = 348
                    self.match(GrammarParser.SAVEPOINT_)


                self.state = 351
                self.savepoint_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Savepoint_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SAVEPOINT_(self):
            return self.getToken(GrammarParser.SAVEPOINT_, 0)

        def savepoint_name(self):
            return self.getTypedRuleContext(GrammarParser.Savepoint_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_savepoint_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSavepoint_stmt" ):
                return visitor.visitSavepoint_stmt(self)
            else:
                return visitor.visitChildren(self)




    def savepoint_stmt(self):

        localctx = GrammarParser.Savepoint_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_savepoint_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 354
            self.match(GrammarParser.SAVEPOINT_)
            self.state = 355
            self.savepoint_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Release_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RELEASE_(self):
            return self.getToken(GrammarParser.RELEASE_, 0)

        def savepoint_name(self):
            return self.getTypedRuleContext(GrammarParser.Savepoint_nameContext,0)


        def SAVEPOINT_(self):
            return self.getToken(GrammarParser.SAVEPOINT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_release_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelease_stmt" ):
                return visitor.visitRelease_stmt(self)
            else:
                return visitor.visitChildren(self)




    def release_stmt(self):

        localctx = GrammarParser.Release_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_release_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 357
            self.match(GrammarParser.RELEASE_)
            self.state = 359
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                self.state = 358
                self.match(GrammarParser.SAVEPOINT_)


            self.state = 361
            self.savepoint_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_index_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_(self):
            return self.getToken(GrammarParser.CREATE_, 0)

        def INDEX_(self):
            return self.getToken(GrammarParser.INDEX_, 0)

        def index_name(self):
            return self.getTypedRuleContext(GrammarParser.Index_nameContext,0)


        def ON_(self):
            return self.getToken(GrammarParser.ON_, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def indexed_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Indexed_columnContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Indexed_columnContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def UNIQUE_(self):
            return self.getToken(GrammarParser.UNIQUE_, 0)

        def IF_(self):
            return self.getToken(GrammarParser.IF_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_create_index_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreate_index_stmt" ):
                return visitor.visitCreate_index_stmt(self)
            else:
                return visitor.visitChildren(self)




    def create_index_stmt(self):

        localctx = GrammarParser.Create_index_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_create_index_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 363
            self.match(GrammarParser.CREATE_)
            self.state = 365
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.UNIQUE_:
                self.state = 364
                self.match(GrammarParser.UNIQUE_)


            self.state = 367
            self.match(GrammarParser.INDEX_)
            self.state = 371
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
            if la_ == 1:
                self.state = 368
                self.match(GrammarParser.IF_)
                self.state = 369
                self.match(GrammarParser.NOT_)
                self.state = 370
                self.match(GrammarParser.EXISTS_)


            self.state = 376
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.state = 373
                self.schema_name()
                self.state = 374
                self.match(GrammarParser.DOT)


            self.state = 378
            self.index_name()
            self.state = 379
            self.match(GrammarParser.ON_)
            self.state = 380
            self.table_name()
            self.state = 381
            self.match(GrammarParser.OPEN_PAR)
            self.state = 382
            self.indexed_column()
            self.state = 387
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 383
                self.match(GrammarParser.COMMA)
                self.state = 384
                self.indexed_column()
                self.state = 389
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 390
            self.match(GrammarParser.CLOSE_PAR)
            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WHERE_:
                self.state = 391
                self.match(GrammarParser.WHERE_)
                self.state = 392
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Indexed_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self):
            return self.getTypedRuleContext(GrammarParser.Column_nameContext,0)


        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def COLLATE_(self):
            return self.getToken(GrammarParser.COLLATE_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(GrammarParser.Collation_nameContext,0)


        def asc_desc(self):
            return self.getTypedRuleContext(GrammarParser.Asc_descContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_indexed_column

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndexed_column" ):
                return visitor.visitIndexed_column(self)
            else:
                return visitor.visitChildren(self)




    def indexed_column(self):

        localctx = GrammarParser.Indexed_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_indexed_column)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 397
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.state = 395
                self.column_name()
                pass

            elif la_ == 2:
                self.state = 396
                self.expr(0)
                pass


            self.state = 401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.COLLATE_:
                self.state = 399
                self.match(GrammarParser.COLLATE_)
                self.state = 400
                self.collation_name()


            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ASC_ or _la==GrammarParser.DESC_:
                self.state = 403
                self.asc_desc()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_table_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.row_ROW_ID = None # Token

        def CREATE_(self):
            return self.getToken(GrammarParser.CREATE_, 0)

        def TABLE_(self):
            return self.getToken(GrammarParser.TABLE_, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def column_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_defContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_defContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def IF_(self):
            return self.getToken(GrammarParser.IF_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def TEMP_(self):
            return self.getToken(GrammarParser.TEMP_, 0)

        def TEMPORARY_(self):
            return self.getToken(GrammarParser.TEMPORARY_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def table_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Table_constraintContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Table_constraintContext,i)


        def WITHOUT_(self):
            return self.getToken(GrammarParser.WITHOUT_, 0)

        def IDENTIFIER(self):
            return self.getToken(GrammarParser.IDENTIFIER, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_create_table_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreate_table_stmt" ):
                return visitor.visitCreate_table_stmt(self)
            else:
                return visitor.visitChildren(self)




    def create_table_stmt(self):

        localctx = GrammarParser.Create_table_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_create_table_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 406
            self.match(GrammarParser.CREATE_)
            self.state = 408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TEMP_ or _la==GrammarParser.TEMPORARY_:
                self.state = 407
                _la = self._input.LA(1)
                if not(_la==GrammarParser.TEMP_ or _la==GrammarParser.TEMPORARY_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 410
            self.match(GrammarParser.TABLE_)
            self.state = 414
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,33,self._ctx)
            if la_ == 1:
                self.state = 411
                self.match(GrammarParser.IF_)
                self.state = 412
                self.match(GrammarParser.NOT_)
                self.state = 413
                self.match(GrammarParser.EXISTS_)


            self.state = 419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,34,self._ctx)
            if la_ == 1:
                self.state = 416
                self.schema_name()
                self.state = 417
                self.match(GrammarParser.DOT)


            self.state = 421
            self.table_name()
            self.state = 445
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.OPEN_PAR]:
                self.state = 422
                self.match(GrammarParser.OPEN_PAR)
                self.state = 423
                self.column_def()
                self.state = 428
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,35,self._ctx)
                while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1+1:
                        self.state = 424
                        self.match(GrammarParser.COMMA)
                        self.state = 425
                        self.column_def() 
                    self.state = 430
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,35,self._ctx)

                self.state = 435
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 431
                    self.match(GrammarParser.COMMA)
                    self.state = 432
                    self.table_constraint()
                    self.state = 437
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 438
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 441
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.WITHOUT_:
                    self.state = 439
                    self.match(GrammarParser.WITHOUT_)
                    self.state = 440
                    localctx.row_ROW_ID = self.match(GrammarParser.IDENTIFIER)


                pass
            elif token in [GrammarParser.AS_]:
                self.state = 443
                self.match(GrammarParser.AS_)
                self.state = 444
                self.select_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def column_name(self):
            return self.getTypedRuleContext(GrammarParser.Column_nameContext,0)


        def type_name(self):
            return self.getTypedRuleContext(GrammarParser.Type_nameContext,0)


        def column_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_constraintContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_constraintContext,i)


        def getRuleIndex(self):
            return GrammarParser.RULE_column_def

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_def" ):
                return visitor.visitColumn_def(self)
            else:
                return visitor.visitChildren(self)




    def column_def(self):

        localctx = GrammarParser.Column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_column_def)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 447
            self.column_name()
            self.state = 449
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                self.state = 448
                self.type_name()


            self.state = 454
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 451
                    self.column_constraint() 
                self.state = 456
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.NameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.NameContext,i)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def signed_number(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Signed_numberContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Signed_numberContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_type_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitType_name" ):
                return visitor.visitType_name(self)
            else:
                return visitor.visitChildren(self)




    def type_name(self):

        localctx = GrammarParser.Type_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_type_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458 
            self._errHandler.sync(self)
            _alt = 1+1
            while _alt!=1 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1+1:
                    self.state = 457
                    self.name()

                else:
                    raise NoViableAltException(self)
                self.state = 460 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,41,self._ctx)

            self.state = 472
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                self.state = 462
                self.match(GrammarParser.OPEN_PAR)
                self.state = 463
                self.signed_number()
                self.state = 464
                self.match(GrammarParser.CLOSE_PAR)

            elif la_ == 2:
                self.state = 466
                self.match(GrammarParser.OPEN_PAR)
                self.state = 467
                self.signed_number()
                self.state = 468
                self.match(GrammarParser.COMMA)
                self.state = 469
                self.signed_number()
                self.state = 470
                self.match(GrammarParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CHECK_(self):
            return self.getToken(GrammarParser.CHECK_, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def DEFAULT_(self):
            return self.getToken(GrammarParser.DEFAULT_, 0)

        def COLLATE_(self):
            return self.getToken(GrammarParser.COLLATE_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(GrammarParser.Collation_nameContext,0)


        def foreign_key_clause(self):
            return self.getTypedRuleContext(GrammarParser.Foreign_key_clauseContext,0)


        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def CONSTRAINT_(self):
            return self.getToken(GrammarParser.CONSTRAINT_, 0)

        def name(self):
            return self.getTypedRuleContext(GrammarParser.NameContext,0)


        def PRIMARY_(self):
            return self.getToken(GrammarParser.PRIMARY_, 0)

        def KEY_(self):
            return self.getToken(GrammarParser.KEY_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def NULL_(self):
            return self.getToken(GrammarParser.NULL_, 0)

        def UNIQUE_(self):
            return self.getToken(GrammarParser.UNIQUE_, 0)

        def signed_number(self):
            return self.getTypedRuleContext(GrammarParser.Signed_numberContext,0)


        def literal_value(self):
            return self.getTypedRuleContext(GrammarParser.Literal_valueContext,0)


        def conflict_clause(self):
            return self.getTypedRuleContext(GrammarParser.Conflict_clauseContext,0)


        def GENERATED_(self):
            return self.getToken(GrammarParser.GENERATED_, 0)

        def ALWAYS_(self):
            return self.getToken(GrammarParser.ALWAYS_, 0)

        def STORED_(self):
            return self.getToken(GrammarParser.STORED_, 0)

        def VIRTUAL_(self):
            return self.getToken(GrammarParser.VIRTUAL_, 0)

        def asc_desc(self):
            return self.getTypedRuleContext(GrammarParser.Asc_descContext,0)


        def AUTOINCREMENT_(self):
            return self.getToken(GrammarParser.AUTOINCREMENT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_column_constraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_constraint" ):
                return visitor.visitColumn_constraint(self)
            else:
                return visitor.visitChildren(self)




    def column_constraint(self):

        localctx = GrammarParser.Column_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_column_constraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.CONSTRAINT_:
                self.state = 474
                self.match(GrammarParser.CONSTRAINT_)
                self.state = 475
                self.name()


            self.state = 525
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.PRIMARY_]:
                self.state = 478
                self.match(GrammarParser.PRIMARY_)
                self.state = 479
                self.match(GrammarParser.KEY_)
                self.state = 481
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ASC_ or _la==GrammarParser.DESC_:
                    self.state = 480
                    self.asc_desc()


                self.state = 484
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ON_:
                    self.state = 483
                    self.conflict_clause()


                self.state = 487
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.AUTOINCREMENT_:
                    self.state = 486
                    self.match(GrammarParser.AUTOINCREMENT_)


                pass
            elif token in [GrammarParser.NOT_, GrammarParser.UNIQUE_]:
                self.state = 492
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.NOT_]:
                    self.state = 489
                    self.match(GrammarParser.NOT_)
                    self.state = 490
                    self.match(GrammarParser.NULL_)
                    pass
                elif token in [GrammarParser.UNIQUE_]:
                    self.state = 491
                    self.match(GrammarParser.UNIQUE_)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 495
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ON_:
                    self.state = 494
                    self.conflict_clause()


                pass
            elif token in [GrammarParser.CHECK_]:
                self.state = 497
                self.match(GrammarParser.CHECK_)
                self.state = 498
                self.match(GrammarParser.OPEN_PAR)
                self.state = 499
                self.expr(0)
                self.state = 500
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.DEFAULT_]:
                self.state = 502
                self.match(GrammarParser.DEFAULT_)
                self.state = 509
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,49,self._ctx)
                if la_ == 1:
                    self.state = 503
                    self.signed_number()
                    pass

                elif la_ == 2:
                    self.state = 504
                    self.literal_value()
                    pass

                elif la_ == 3:
                    self.state = 505
                    self.match(GrammarParser.OPEN_PAR)
                    self.state = 506
                    self.expr(0)
                    self.state = 507
                    self.match(GrammarParser.CLOSE_PAR)
                    pass


                pass
            elif token in [GrammarParser.COLLATE_]:
                self.state = 511
                self.match(GrammarParser.COLLATE_)
                self.state = 512
                self.collation_name()
                pass
            elif token in [GrammarParser.REFERENCES_]:
                self.state = 513
                self.foreign_key_clause()
                pass
            elif token in [GrammarParser.AS_, GrammarParser.GENERATED_]:
                self.state = 516
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.GENERATED_:
                    self.state = 514
                    self.match(GrammarParser.GENERATED_)
                    self.state = 515
                    self.match(GrammarParser.ALWAYS_)


                self.state = 518
                self.match(GrammarParser.AS_)
                self.state = 519
                self.match(GrammarParser.OPEN_PAR)
                self.state = 520
                self.expr(0)
                self.state = 521
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 523
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.VIRTUAL_ or _la==GrammarParser.STORED_:
                    self.state = 522
                    _la = self._input.LA(1)
                    if not(_la==GrammarParser.VIRTUAL_ or _la==GrammarParser.STORED_):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(GrammarParser.NUMERIC_LITERAL, 0)

        def PLUS(self):
            return self.getToken(GrammarParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(GrammarParser.MINUS, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_signed_number

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSigned_number" ):
                return visitor.visitSigned_number(self)
            else:
                return visitor.visitChildren(self)




    def signed_number(self):

        localctx = GrammarParser.Signed_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_signed_number)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.PLUS or _la==GrammarParser.MINUS:
                self.state = 527
                _la = self._input.LA(1)
                if not(_la==GrammarParser.PLUS or _la==GrammarParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 530
            self.match(GrammarParser.NUMERIC_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def indexed_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Indexed_columnContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Indexed_columnContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def CHECK_(self):
            return self.getToken(GrammarParser.CHECK_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def FOREIGN_(self):
            return self.getToken(GrammarParser.FOREIGN_, 0)

        def KEY_(self):
            return self.getToken(GrammarParser.KEY_, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def foreign_key_clause(self):
            return self.getTypedRuleContext(GrammarParser.Foreign_key_clauseContext,0)


        def CONSTRAINT_(self):
            return self.getToken(GrammarParser.CONSTRAINT_, 0)

        def name(self):
            return self.getTypedRuleContext(GrammarParser.NameContext,0)


        def PRIMARY_(self):
            return self.getToken(GrammarParser.PRIMARY_, 0)

        def UNIQUE_(self):
            return self.getToken(GrammarParser.UNIQUE_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def conflict_clause(self):
            return self.getTypedRuleContext(GrammarParser.Conflict_clauseContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_table_constraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_constraint" ):
                return visitor.visitTable_constraint(self)
            else:
                return visitor.visitChildren(self)




    def table_constraint(self):

        localctx = GrammarParser.Table_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_table_constraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 534
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.CONSTRAINT_:
                self.state = 532
                self.match(GrammarParser.CONSTRAINT_)
                self.state = 533
                self.name()


            self.state = 573
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.PRIMARY_, GrammarParser.UNIQUE_]:
                self.state = 539
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.PRIMARY_]:
                    self.state = 536
                    self.match(GrammarParser.PRIMARY_)
                    self.state = 537
                    self.match(GrammarParser.KEY_)
                    pass
                elif token in [GrammarParser.UNIQUE_]:
                    self.state = 538
                    self.match(GrammarParser.UNIQUE_)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 541
                self.match(GrammarParser.OPEN_PAR)
                self.state = 542
                self.indexed_column()
                self.state = 547
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 543
                    self.match(GrammarParser.COMMA)
                    self.state = 544
                    self.indexed_column()
                    self.state = 549
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 550
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 552
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ON_:
                    self.state = 551
                    self.conflict_clause()


                pass
            elif token in [GrammarParser.CHECK_]:
                self.state = 554
                self.match(GrammarParser.CHECK_)
                self.state = 555
                self.match(GrammarParser.OPEN_PAR)
                self.state = 556
                self.expr(0)
                self.state = 557
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.FOREIGN_]:
                self.state = 559
                self.match(GrammarParser.FOREIGN_)
                self.state = 560
                self.match(GrammarParser.KEY_)
                self.state = 561
                self.match(GrammarParser.OPEN_PAR)
                self.state = 562
                self.column_name()
                self.state = 567
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 563
                    self.match(GrammarParser.COMMA)
                    self.state = 564
                    self.column_name()
                    self.state = 569
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 570
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 571
                self.foreign_key_clause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Foreign_key_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REFERENCES_(self):
            return self.getToken(GrammarParser.REFERENCES_, 0)

        def foreign_table(self):
            return self.getTypedRuleContext(GrammarParser.Foreign_tableContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def ON_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.ON_)
            else:
                return self.getToken(GrammarParser.ON_, i)

        def MATCH_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.MATCH_)
            else:
                return self.getToken(GrammarParser.MATCH_, i)

        def name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.NameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.NameContext,i)


        def DEFERRABLE_(self):
            return self.getToken(GrammarParser.DEFERRABLE_, 0)

        def DELETE_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.DELETE_)
            else:
                return self.getToken(GrammarParser.DELETE_, i)

        def UPDATE_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.UPDATE_)
            else:
                return self.getToken(GrammarParser.UPDATE_, i)

        def SET_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.SET_)
            else:
                return self.getToken(GrammarParser.SET_, i)

        def CASCADE_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.CASCADE_)
            else:
                return self.getToken(GrammarParser.CASCADE_, i)

        def RESTRICT_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.RESTRICT_)
            else:
                return self.getToken(GrammarParser.RESTRICT_, i)

        def NO_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.NO_)
            else:
                return self.getToken(GrammarParser.NO_, i)

        def ACTION_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.ACTION_)
            else:
                return self.getToken(GrammarParser.ACTION_, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def NULL_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.NULL_)
            else:
                return self.getToken(GrammarParser.NULL_, i)

        def DEFAULT_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.DEFAULT_)
            else:
                return self.getToken(GrammarParser.DEFAULT_, i)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def INITIALLY_(self):
            return self.getToken(GrammarParser.INITIALLY_, 0)

        def DEFERRED_(self):
            return self.getToken(GrammarParser.DEFERRED_, 0)

        def IMMEDIATE_(self):
            return self.getToken(GrammarParser.IMMEDIATE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_foreign_key_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForeign_key_clause" ):
                return visitor.visitForeign_key_clause(self)
            else:
                return visitor.visitChildren(self)




    def foreign_key_clause(self):

        localctx = GrammarParser.Foreign_key_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_foreign_key_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 575
            self.match(GrammarParser.REFERENCES_)
            self.state = 576
            self.foreign_table()
            self.state = 588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.OPEN_PAR:
                self.state = 577
                self.match(GrammarParser.OPEN_PAR)
                self.state = 578
                self.column_name()
                self.state = 583
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 579
                    self.match(GrammarParser.COMMA)
                    self.state = 580
                    self.column_name()
                    self.state = 585
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 586
                self.match(GrammarParser.CLOSE_PAR)


            self.state = 604
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.MATCH_ or _la==GrammarParser.ON_:
                self.state = 602
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.ON_]:
                    self.state = 590
                    self.match(GrammarParser.ON_)
                    self.state = 591
                    _la = self._input.LA(1)
                    if not(_la==GrammarParser.DELETE_ or _la==GrammarParser.UPDATE_):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 598
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [GrammarParser.SET_]:
                        self.state = 592
                        self.match(GrammarParser.SET_)
                        self.state = 593
                        _la = self._input.LA(1)
                        if not(_la==GrammarParser.DEFAULT_ or _la==GrammarParser.NULL_):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass
                    elif token in [GrammarParser.CASCADE_]:
                        self.state = 594
                        self.match(GrammarParser.CASCADE_)
                        pass
                    elif token in [GrammarParser.RESTRICT_]:
                        self.state = 595
                        self.match(GrammarParser.RESTRICT_)
                        pass
                    elif token in [GrammarParser.NO_]:
                        self.state = 596
                        self.match(GrammarParser.NO_)
                        self.state = 597
                        self.match(GrammarParser.ACTION_)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [GrammarParser.MATCH_]:
                    self.state = 600
                    self.match(GrammarParser.MATCH_)
                    self.state = 601
                    self.name()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 606
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 615
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                self.state = 608
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.NOT_:
                    self.state = 607
                    self.match(GrammarParser.NOT_)


                self.state = 610
                self.match(GrammarParser.DEFERRABLE_)
                self.state = 613
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.INITIALLY_:
                    self.state = 611
                    self.match(GrammarParser.INITIALLY_)
                    self.state = 612
                    _la = self._input.LA(1)
                    if not(_la==GrammarParser.DEFERRED_ or _la==GrammarParser.IMMEDIATE_):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conflict_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON_(self):
            return self.getToken(GrammarParser.ON_, 0)

        def CONFLICT_(self):
            return self.getToken(GrammarParser.CONFLICT_, 0)

        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def ABORT_(self):
            return self.getToken(GrammarParser.ABORT_, 0)

        def FAIL_(self):
            return self.getToken(GrammarParser.FAIL_, 0)

        def IGNORE_(self):
            return self.getToken(GrammarParser.IGNORE_, 0)

        def REPLACE_(self):
            return self.getToken(GrammarParser.REPLACE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_conflict_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConflict_clause" ):
                return visitor.visitConflict_clause(self)
            else:
                return visitor.visitChildren(self)




    def conflict_clause(self):

        localctx = GrammarParser.Conflict_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_conflict_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 617
            self.match(GrammarParser.ON_)
            self.state = 618
            self.match(GrammarParser.CONFLICT_)
            self.state = 619
            _la = self._input.LA(1)
            if not(_la==GrammarParser.ABORT_ or ((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & ((1 << (GrammarParser.FAIL_ - 72)) | (1 << (GrammarParser.IGNORE_ - 72)) | (1 << (GrammarParser.REPLACE_ - 72)) | (1 << (GrammarParser.ROLLBACK_ - 72)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_trigger_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_(self):
            return self.getToken(GrammarParser.CREATE_, 0)

        def TRIGGER_(self):
            return self.getToken(GrammarParser.TRIGGER_, 0)

        def trigger_name(self):
            return self.getTypedRuleContext(GrammarParser.Trigger_nameContext,0)


        def ON_(self):
            return self.getToken(GrammarParser.ON_, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def BEGIN_(self):
            return self.getToken(GrammarParser.BEGIN_, 0)

        def END_(self):
            return self.getToken(GrammarParser.END_, 0)

        def DELETE_(self):
            return self.getToken(GrammarParser.DELETE_, 0)

        def INSERT_(self):
            return self.getToken(GrammarParser.INSERT_, 0)

        def UPDATE_(self):
            return self.getToken(GrammarParser.UPDATE_, 0)

        def IF_(self):
            return self.getToken(GrammarParser.IF_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def BEFORE_(self):
            return self.getToken(GrammarParser.BEFORE_, 0)

        def AFTER_(self):
            return self.getToken(GrammarParser.AFTER_, 0)

        def INSTEAD_(self):
            return self.getToken(GrammarParser.INSTEAD_, 0)

        def OF_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.OF_)
            else:
                return self.getToken(GrammarParser.OF_, i)

        def FOR_(self):
            return self.getToken(GrammarParser.FOR_, 0)

        def EACH_(self):
            return self.getToken(GrammarParser.EACH_, 0)

        def ROW_(self):
            return self.getToken(GrammarParser.ROW_, 0)

        def WHEN_(self):
            return self.getToken(GrammarParser.WHEN_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def SCOL(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.SCOL)
            else:
                return self.getToken(GrammarParser.SCOL, i)

        def TEMP_(self):
            return self.getToken(GrammarParser.TEMP_, 0)

        def TEMPORARY_(self):
            return self.getToken(GrammarParser.TEMPORARY_, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def update_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Update_stmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Update_stmtContext,i)


        def insert_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Insert_stmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Insert_stmtContext,i)


        def delete_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Delete_stmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Delete_stmtContext,i)


        def select_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Select_stmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Select_stmtContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_create_trigger_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreate_trigger_stmt" ):
                return visitor.visitCreate_trigger_stmt(self)
            else:
                return visitor.visitChildren(self)




    def create_trigger_stmt(self):

        localctx = GrammarParser.Create_trigger_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_create_trigger_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 621
            self.match(GrammarParser.CREATE_)
            self.state = 623
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TEMP_ or _la==GrammarParser.TEMPORARY_:
                self.state = 622
                _la = self._input.LA(1)
                if not(_la==GrammarParser.TEMP_ or _la==GrammarParser.TEMPORARY_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 625
            self.match(GrammarParser.TRIGGER_)
            self.state = 629
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,69,self._ctx)
            if la_ == 1:
                self.state = 626
                self.match(GrammarParser.IF_)
                self.state = 627
                self.match(GrammarParser.NOT_)
                self.state = 628
                self.match(GrammarParser.EXISTS_)


            self.state = 634
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                self.state = 631
                self.schema_name()
                self.state = 632
                self.match(GrammarParser.DOT)


            self.state = 636
            self.trigger_name()
            self.state = 641
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.BEFORE_]:
                self.state = 637
                self.match(GrammarParser.BEFORE_)
                pass
            elif token in [GrammarParser.AFTER_]:
                self.state = 638
                self.match(GrammarParser.AFTER_)
                pass
            elif token in [GrammarParser.INSTEAD_]:
                self.state = 639
                self.match(GrammarParser.INSTEAD_)
                self.state = 640
                self.match(GrammarParser.OF_)
                pass
            elif token in [GrammarParser.DELETE_, GrammarParser.INSERT_, GrammarParser.UPDATE_]:
                pass
            else:
                pass
            self.state = 657
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.DELETE_]:
                self.state = 643
                self.match(GrammarParser.DELETE_)
                pass
            elif token in [GrammarParser.INSERT_]:
                self.state = 644
                self.match(GrammarParser.INSERT_)
                pass
            elif token in [GrammarParser.UPDATE_]:
                self.state = 645
                self.match(GrammarParser.UPDATE_)
                self.state = 655
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.OF_:
                    self.state = 646
                    self.match(GrammarParser.OF_)
                    self.state = 647
                    self.column_name()
                    self.state = 652
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 648
                        self.match(GrammarParser.COMMA)
                        self.state = 649
                        self.column_name()
                        self.state = 654
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                pass
            else:
                raise NoViableAltException(self)

            self.state = 659
            self.match(GrammarParser.ON_)
            self.state = 660
            self.table_name()
            self.state = 664
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.FOR_:
                self.state = 661
                self.match(GrammarParser.FOR_)
                self.state = 662
                self.match(GrammarParser.EACH_)
                self.state = 663
                self.match(GrammarParser.ROW_)


            self.state = 668
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WHEN_:
                self.state = 666
                self.match(GrammarParser.WHEN_)
                self.state = 667
                self.expr(0)


            self.state = 670
            self.match(GrammarParser.BEGIN_)
            self.state = 679 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 675
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,77,self._ctx)
                if la_ == 1:
                    self.state = 671
                    self.update_stmt()
                    pass

                elif la_ == 2:
                    self.state = 672
                    self.insert_stmt()
                    pass

                elif la_ == 3:
                    self.state = 673
                    self.delete_stmt()
                    pass

                elif la_ == 4:
                    self.state = 674
                    self.select_stmt()
                    pass


                self.state = 677
                self.match(GrammarParser.SCOL)
                self.state = 681 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==GrammarParser.DEFAULT_ or _la==GrammarParser.DELETE_ or ((((_la - 88)) & ~0x3f) == 0 and ((1 << (_la - 88)) & ((1 << (GrammarParser.INSERT_ - 88)) | (1 << (GrammarParser.REPLACE_ - 88)) | (1 << (GrammarParser.SELECT_ - 88)) | (1 << (GrammarParser.UPDATE_ - 88)) | (1 << (GrammarParser.VALUES_ - 88)) | (1 << (GrammarParser.WITH_ - 88)))) != 0)):
                    break

            self.state = 683
            self.match(GrammarParser.END_)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_view_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_(self):
            return self.getToken(GrammarParser.CREATE_, 0)

        def VIEW_(self):
            return self.getToken(GrammarParser.VIEW_, 0)

        def view_name(self):
            return self.getTypedRuleContext(GrammarParser.View_nameContext,0)


        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def IF_(self):
            return self.getToken(GrammarParser.IF_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def TEMP_(self):
            return self.getToken(GrammarParser.TEMP_, 0)

        def TEMPORARY_(self):
            return self.getToken(GrammarParser.TEMPORARY_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_create_view_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreate_view_stmt" ):
                return visitor.visitCreate_view_stmt(self)
            else:
                return visitor.visitChildren(self)




    def create_view_stmt(self):

        localctx = GrammarParser.Create_view_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_create_view_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 685
            self.match(GrammarParser.CREATE_)
            self.state = 687
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.TEMP_ or _la==GrammarParser.TEMPORARY_:
                self.state = 686
                _la = self._input.LA(1)
                if not(_la==GrammarParser.TEMP_ or _la==GrammarParser.TEMPORARY_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 689
            self.match(GrammarParser.VIEW_)
            self.state = 693
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,80,self._ctx)
            if la_ == 1:
                self.state = 690
                self.match(GrammarParser.IF_)
                self.state = 691
                self.match(GrammarParser.NOT_)
                self.state = 692
                self.match(GrammarParser.EXISTS_)


            self.state = 698
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                self.state = 695
                self.schema_name()
                self.state = 696
                self.match(GrammarParser.DOT)


            self.state = 700
            self.view_name()
            self.state = 712
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.OPEN_PAR:
                self.state = 701
                self.match(GrammarParser.OPEN_PAR)
                self.state = 702
                self.column_name()
                self.state = 707
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 703
                    self.match(GrammarParser.COMMA)
                    self.state = 704
                    self.column_name()
                    self.state = 709
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 710
                self.match(GrammarParser.CLOSE_PAR)


            self.state = 714
            self.match(GrammarParser.AS_)
            self.state = 715
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_virtual_table_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE_(self):
            return self.getToken(GrammarParser.CREATE_, 0)

        def VIRTUAL_(self):
            return self.getToken(GrammarParser.VIRTUAL_, 0)

        def TABLE_(self):
            return self.getToken(GrammarParser.TABLE_, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def USING_(self):
            return self.getToken(GrammarParser.USING_, 0)

        def module_name(self):
            return self.getTypedRuleContext(GrammarParser.Module_nameContext,0)


        def IF_(self):
            return self.getToken(GrammarParser.IF_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def module_argument(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Module_argumentContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Module_argumentContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_create_virtual_table_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCreate_virtual_table_stmt" ):
                return visitor.visitCreate_virtual_table_stmt(self)
            else:
                return visitor.visitChildren(self)




    def create_virtual_table_stmt(self):

        localctx = GrammarParser.Create_virtual_table_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_create_virtual_table_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 717
            self.match(GrammarParser.CREATE_)
            self.state = 718
            self.match(GrammarParser.VIRTUAL_)
            self.state = 719
            self.match(GrammarParser.TABLE_)
            self.state = 723
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,84,self._ctx)
            if la_ == 1:
                self.state = 720
                self.match(GrammarParser.IF_)
                self.state = 721
                self.match(GrammarParser.NOT_)
                self.state = 722
                self.match(GrammarParser.EXISTS_)


            self.state = 728
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,85,self._ctx)
            if la_ == 1:
                self.state = 725
                self.schema_name()
                self.state = 726
                self.match(GrammarParser.DOT)


            self.state = 730
            self.table_name()
            self.state = 731
            self.match(GrammarParser.USING_)
            self.state = 732
            self.module_name()
            self.state = 744
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.OPEN_PAR:
                self.state = 733
                self.match(GrammarParser.OPEN_PAR)
                self.state = 734
                self.module_argument()
                self.state = 739
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 735
                    self.match(GrammarParser.COMMA)
                    self.state = 736
                    self.module_argument()
                    self.state = 741
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 742
                self.match(GrammarParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class With_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_(self):
            return self.getToken(GrammarParser.WITH_, 0)

        def cte_table_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Cte_table_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Cte_table_nameContext,i)


        def AS_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.AS_)
            else:
                return self.getToken(GrammarParser.AS_, i)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.OPEN_PAR)
            else:
                return self.getToken(GrammarParser.OPEN_PAR, i)

        def select_stmt(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Select_stmtContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Select_stmtContext,i)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.CLOSE_PAR)
            else:
                return self.getToken(GrammarParser.CLOSE_PAR, i)

        def RECURSIVE_(self):
            return self.getToken(GrammarParser.RECURSIVE_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_with_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWith_clause" ):
                return visitor.visitWith_clause(self)
            else:
                return visitor.visitChildren(self)




    def with_clause(self):

        localctx = GrammarParser.With_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_with_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 746
            self.match(GrammarParser.WITH_)
            self.state = 748
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,88,self._ctx)
            if la_ == 1:
                self.state = 747
                self.match(GrammarParser.RECURSIVE_)


            self.state = 750
            self.cte_table_name()
            self.state = 751
            self.match(GrammarParser.AS_)
            self.state = 752
            self.match(GrammarParser.OPEN_PAR)
            self.state = 753
            self.select_stmt()
            self.state = 754
            self.match(GrammarParser.CLOSE_PAR)
            self.state = 764
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 755
                self.match(GrammarParser.COMMA)
                self.state = 756
                self.cte_table_name()
                self.state = 757
                self.match(GrammarParser.AS_)
                self.state = 758
                self.match(GrammarParser.OPEN_PAR)
                self.state = 759
                self.select_stmt()
                self.state = 760
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 766
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cte_table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_cte_table_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCte_table_name" ):
                return visitor.visitCte_table_name(self)
            else:
                return visitor.visitChildren(self)




    def cte_table_name(self):

        localctx = GrammarParser.Cte_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_cte_table_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 767
            self.table_name()
            self.state = 779
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.OPEN_PAR:
                self.state = 768
                self.match(GrammarParser.OPEN_PAR)
                self.state = 769
                self.column_name()
                self.state = 774
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 770
                    self.match(GrammarParser.COMMA)
                    self.state = 771
                    self.column_name()
                    self.state = 776
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 777
                self.match(GrammarParser.CLOSE_PAR)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Recursive_cteContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cte_table_name(self):
            return self.getTypedRuleContext(GrammarParser.Cte_table_nameContext,0)


        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def initial_select(self):
            return self.getTypedRuleContext(GrammarParser.Initial_selectContext,0)


        def UNION_(self):
            return self.getToken(GrammarParser.UNION_, 0)

        def recursive__select(self):
            return self.getTypedRuleContext(GrammarParser.Recursive__selectContext,0)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def ALL_(self):
            return self.getToken(GrammarParser.ALL_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_recursive_cte

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecursive_cte" ):
                return visitor.visitRecursive_cte(self)
            else:
                return visitor.visitChildren(self)




    def recursive_cte(self):

        localctx = GrammarParser.Recursive_cteContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_recursive_cte)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 781
            self.cte_table_name()
            self.state = 782
            self.match(GrammarParser.AS_)
            self.state = 783
            self.match(GrammarParser.OPEN_PAR)
            self.state = 784
            self.initial_select()
            self.state = 785
            self.match(GrammarParser.UNION_)
            self.state = 787
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ALL_:
                self.state = 786
                self.match(GrammarParser.ALL_)


            self.state = 789
            self.recursive__select()
            self.state = 790
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Common_table_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.OPEN_PAR)
            else:
                return self.getToken(GrammarParser.OPEN_PAR, i)

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.CLOSE_PAR)
            else:
                return self.getToken(GrammarParser.CLOSE_PAR, i)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_common_table_expression

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommon_table_expression" ):
                return visitor.visitCommon_table_expression(self)
            else:
                return visitor.visitChildren(self)




    def common_table_expression(self):

        localctx = GrammarParser.Common_table_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_common_table_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 792
            self.table_name()
            self.state = 804
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.OPEN_PAR:
                self.state = 793
                self.match(GrammarParser.OPEN_PAR)
                self.state = 794
                self.column_name()
                self.state = 799
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 795
                    self.match(GrammarParser.COMMA)
                    self.state = 796
                    self.column_name()
                    self.state = 801
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 802
                self.match(GrammarParser.CLOSE_PAR)


            self.state = 806
            self.match(GrammarParser.AS_)
            self.state = 807
            self.match(GrammarParser.OPEN_PAR)
            self.state = 808
            self.select_stmt()
            self.state = 809
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delete_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE_(self):
            return self.getToken(GrammarParser.DELETE_, 0)

        def FROM_(self):
            return self.getToken(GrammarParser.FROM_, 0)

        def qualified_table_name(self):
            return self.getTypedRuleContext(GrammarParser.Qualified_table_nameContext,0)


        def with_clause(self):
            return self.getTypedRuleContext(GrammarParser.With_clauseContext,0)


        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_delete_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelete_stmt" ):
                return visitor.visitDelete_stmt(self)
            else:
                return visitor.visitChildren(self)




    def delete_stmt(self):

        localctx = GrammarParser.Delete_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_delete_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 811
                self.with_clause()


            self.state = 814
            self.match(GrammarParser.DELETE_)
            self.state = 815
            self.match(GrammarParser.FROM_)
            self.state = 816
            self.qualified_table_name()
            self.state = 819
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WHERE_:
                self.state = 817
                self.match(GrammarParser.WHERE_)
                self.state = 818
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delete_stmt_limitedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DELETE_(self):
            return self.getToken(GrammarParser.DELETE_, 0)

        def FROM_(self):
            return self.getToken(GrammarParser.FROM_, 0)

        def qualified_table_name(self):
            return self.getTypedRuleContext(GrammarParser.Qualified_table_nameContext,0)


        def with_clause(self):
            return self.getTypedRuleContext(GrammarParser.With_clauseContext,0)


        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Limit_stmtContext,0)


        def order_by_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_delete_stmt_limited

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDelete_stmt_limited" ):
                return visitor.visitDelete_stmt_limited(self)
            else:
                return visitor.visitChildren(self)




    def delete_stmt_limited(self):

        localctx = GrammarParser.Delete_stmt_limitedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_delete_stmt_limited)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 822
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 821
                self.with_clause()


            self.state = 824
            self.match(GrammarParser.DELETE_)
            self.state = 825
            self.match(GrammarParser.FROM_)
            self.state = 826
            self.qualified_table_name()
            self.state = 829
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WHERE_:
                self.state = 827
                self.match(GrammarParser.WHERE_)
                self.state = 828
                self.expr(0)


            self.state = 835
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.LIMIT_ or _la==GrammarParser.ORDER_:
                self.state = 832
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ORDER_:
                    self.state = 831
                    self.order_by_stmt()


                self.state = 834
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Detach_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DETACH_(self):
            return self.getToken(GrammarParser.DETACH_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DATABASE_(self):
            return self.getToken(GrammarParser.DATABASE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_detach_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDetach_stmt" ):
                return visitor.visitDetach_stmt(self)
            else:
                return visitor.visitChildren(self)




    def detach_stmt(self):

        localctx = GrammarParser.Detach_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_detach_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 837
            self.match(GrammarParser.DETACH_)
            self.state = 839
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                self.state = 838
                self.match(GrammarParser.DATABASE_)


            self.state = 841
            self.schema_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def literal_value(self):
            return self.getTypedRuleContext(GrammarParser.Literal_valueContext,0)


        def BIND_PARAMETER(self):
            return self.getToken(GrammarParser.BIND_PARAMETER, 0)

        def column_name(self):
            return self.getTypedRuleContext(GrammarParser.Column_nameContext,0)


        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.DOT)
            else:
                return self.getToken(GrammarParser.DOT, i)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def unary_operator(self):
            return self.getTypedRuleContext(GrammarParser.Unary_operatorContext,0)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def function_name(self):
            return self.getTypedRuleContext(GrammarParser.Function_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def STAR(self):
            return self.getToken(GrammarParser.STAR, 0)

        def filter_clause(self):
            return self.getTypedRuleContext(GrammarParser.Filter_clauseContext,0)


        def over_clause(self):
            return self.getTypedRuleContext(GrammarParser.Over_clauseContext,0)


        def DISTINCT_(self):
            return self.getToken(GrammarParser.DISTINCT_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def CAST_(self):
            return self.getToken(GrammarParser.CAST_, 0)

        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def type_name(self):
            return self.getTypedRuleContext(GrammarParser.Type_nameContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def CASE_(self):
            return self.getToken(GrammarParser.CASE_, 0)

        def END_(self):
            return self.getToken(GrammarParser.END_, 0)

        def WHEN_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.WHEN_)
            else:
                return self.getToken(GrammarParser.WHEN_, i)

        def THEN_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.THEN_)
            else:
                return self.getToken(GrammarParser.THEN_, i)

        def ELSE_(self):
            return self.getToken(GrammarParser.ELSE_, 0)

        def raise_function(self):
            return self.getTypedRuleContext(GrammarParser.Raise_functionContext,0)


        def PIPE2(self):
            return self.getToken(GrammarParser.PIPE2, 0)

        def DIV(self):
            return self.getToken(GrammarParser.DIV, 0)

        def MOD(self):
            return self.getToken(GrammarParser.MOD, 0)

        def PLUS(self):
            return self.getToken(GrammarParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(GrammarParser.MINUS, 0)

        def LT2(self):
            return self.getToken(GrammarParser.LT2, 0)

        def GT2(self):
            return self.getToken(GrammarParser.GT2, 0)

        def AMP(self):
            return self.getToken(GrammarParser.AMP, 0)

        def PIPE(self):
            return self.getToken(GrammarParser.PIPE, 0)

        def LT(self):
            return self.getToken(GrammarParser.LT, 0)

        def LT_EQ(self):
            return self.getToken(GrammarParser.LT_EQ, 0)

        def GT(self):
            return self.getToken(GrammarParser.GT, 0)

        def GT_EQ(self):
            return self.getToken(GrammarParser.GT_EQ, 0)

        def ASSIGN(self):
            return self.getToken(GrammarParser.ASSIGN, 0)

        def EQ(self):
            return self.getToken(GrammarParser.EQ, 0)

        def NOT_EQ1(self):
            return self.getToken(GrammarParser.NOT_EQ1, 0)

        def NOT_EQ2(self):
            return self.getToken(GrammarParser.NOT_EQ2, 0)

        def IS_(self):
            return self.getToken(GrammarParser.IS_, 0)

        def IN_(self):
            return self.getToken(GrammarParser.IN_, 0)

        def LIKE_(self):
            return self.getToken(GrammarParser.LIKE_, 0)

        def GLOB_(self):
            return self.getToken(GrammarParser.GLOB_, 0)

        def MATCH_(self):
            return self.getToken(GrammarParser.MATCH_, 0)

        def REGEXP_(self):
            return self.getToken(GrammarParser.REGEXP_, 0)

        def AND_(self):
            return self.getToken(GrammarParser.AND_, 0)

        def OR_(self):
            return self.getToken(GrammarParser.OR_, 0)

        def BETWEEN_(self):
            return self.getToken(GrammarParser.BETWEEN_, 0)

        def COLLATE_(self):
            return self.getToken(GrammarParser.COLLATE_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(GrammarParser.Collation_nameContext,0)


        def ESCAPE_(self):
            return self.getToken(GrammarParser.ESCAPE_, 0)

        def ISNULL_(self):
            return self.getToken(GrammarParser.ISNULL_, 0)

        def NOTNULL_(self):
            return self.getToken(GrammarParser.NOTNULL_, 0)

        def NULL_(self):
            return self.getToken(GrammarParser.NULL_, 0)

        def table_function_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_function_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_expr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr" ):
                return visitor.visitExpr(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = GrammarParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 62
        self.enterRecursionRule(localctx, 62, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 931
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
            if la_ == 1:
                self.state = 844
                self.literal_value()
                pass

            elif la_ == 2:
                self.state = 845
                self.match(GrammarParser.BIND_PARAMETER)
                pass

            elif la_ == 3:
                self.state = 854
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
                if la_ == 1:
                    self.state = 849
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
                    if la_ == 1:
                        self.state = 846
                        self.schema_name()
                        self.state = 847
                        self.match(GrammarParser.DOT)


                    self.state = 851
                    self.table_name()
                    self.state = 852
                    self.match(GrammarParser.DOT)


                self.state = 856
                self.column_name()
                pass

            elif la_ == 4:
                self.state = 857
                self.unary_operator()
                self.state = 858
                self.expr(21)
                pass

            elif la_ == 5:
                self.state = 860
                self.function_name()
                self.state = 861
                self.match(GrammarParser.OPEN_PAR)
                self.state = 874
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.OPEN_PAR, GrammarParser.PLUS, GrammarParser.MINUS, GrammarParser.TILDE, GrammarParser.ABORT_, GrammarParser.ACTION_, GrammarParser.ADD_, GrammarParser.AFTER_, GrammarParser.ALL_, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.AND_, GrammarParser.AS_, GrammarParser.ASC_, GrammarParser.ATTACH_, GrammarParser.AUTOINCREMENT_, GrammarParser.BEFORE_, GrammarParser.BEGIN_, GrammarParser.BETWEEN_, GrammarParser.BY_, GrammarParser.CASCADE_, GrammarParser.CASE_, GrammarParser.CAST_, GrammarParser.CHECK_, GrammarParser.COLLATE_, GrammarParser.COLUMN_, GrammarParser.COMMIT_, GrammarParser.CONFLICT_, GrammarParser.CONSTRAINT_, GrammarParser.CREATE_, GrammarParser.CROSS_, GrammarParser.CURRENT_DATE_, GrammarParser.CURRENT_TIME_, GrammarParser.CURRENT_TIMESTAMP_, GrammarParser.DATABASE_, GrammarParser.DEFAULT_, GrammarParser.DEFERRABLE_, GrammarParser.DEFERRED_, GrammarParser.DELETE_, GrammarParser.DESC_, GrammarParser.DETACH_, GrammarParser.DISTINCT_, GrammarParser.DROP_, GrammarParser.EACH_, GrammarParser.ELSE_, GrammarParser.END_, GrammarParser.ESCAPE_, GrammarParser.EXCEPT_, GrammarParser.EXCLUSIVE_, GrammarParser.EXISTS_, GrammarParser.EXPLAIN_, GrammarParser.FAIL_, GrammarParser.FOR_, GrammarParser.FOREIGN_, GrammarParser.FROM_, GrammarParser.FULL_, GrammarParser.GLOB_, GrammarParser.GROUP_, GrammarParser.HAVING_, GrammarParser.IF_, GrammarParser.IGNORE_, GrammarParser.IMMEDIATE_, GrammarParser.IN_, GrammarParser.INDEX_, GrammarParser.INDEXED_, GrammarParser.INITIALLY_, GrammarParser.INNER_, GrammarParser.INSERT_, GrammarParser.INSTEAD_, GrammarParser.INTERSECT_, GrammarParser.INTO_, GrammarParser.IS_, GrammarParser.ISNULL_, GrammarParser.JOIN_, GrammarParser.KEY_, GrammarParser.LEFT_, GrammarParser.LIKE_, GrammarParser.LIMIT_, GrammarParser.MATCH_, GrammarParser.NATURAL_, GrammarParser.NO_, GrammarParser.NOT_, GrammarParser.NOTNULL_, GrammarParser.NULL_, GrammarParser.OF_, GrammarParser.OFFSET_, GrammarParser.ON_, GrammarParser.OR_, GrammarParser.ORDER_, GrammarParser.OUTER_, GrammarParser.PLAN_, GrammarParser.PRAGMA_, GrammarParser.PRIMARY_, GrammarParser.QUERY_, GrammarParser.RAISE_, GrammarParser.RECURSIVE_, GrammarParser.REFERENCES_, GrammarParser.REGEXP_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.RENAME_, GrammarParser.REPLACE_, GrammarParser.RESTRICT_, GrammarParser.RIGHT_, GrammarParser.ROLLBACK_, GrammarParser.ROW_, GrammarParser.ROWS_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.SET_, GrammarParser.TABLE_, GrammarParser.TEMP_, GrammarParser.TEMPORARY_, GrammarParser.THEN_, GrammarParser.TO_, GrammarParser.TRANSACTION_, GrammarParser.TRIGGER_, GrammarParser.UNION_, GrammarParser.UNIQUE_, GrammarParser.UPDATE_, GrammarParser.USING_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.VIEW_, GrammarParser.VIRTUAL_, GrammarParser.WHEN_, GrammarParser.WHERE_, GrammarParser.WITH_, GrammarParser.WITHOUT_, GrammarParser.FIRST_VALUE_, GrammarParser.OVER_, GrammarParser.PARTITION_, GrammarParser.RANGE_, GrammarParser.PRECEDING_, GrammarParser.UNBOUNDED_, GrammarParser.CURRENT_, GrammarParser.FOLLOWING_, GrammarParser.CUME_DIST_, GrammarParser.DENSE_RANK_, GrammarParser.LAG_, GrammarParser.LAST_VALUE_, GrammarParser.LEAD_, GrammarParser.NTH_VALUE_, GrammarParser.NTILE_, GrammarParser.PERCENT_RANK_, GrammarParser.RANK_, GrammarParser.ROW_NUMBER_, GrammarParser.GENERATED_, GrammarParser.ALWAYS_, GrammarParser.STORED_, GrammarParser.TRUE_, GrammarParser.FALSE_, GrammarParser.WINDOW_, GrammarParser.NULLS_, GrammarParser.FIRST_, GrammarParser.LAST_, GrammarParser.FILTER_, GrammarParser.GROUPS_, GrammarParser.EXCLUDE_, GrammarParser.IDENTIFIER, GrammarParser.NUMERIC_LITERAL, GrammarParser.BIND_PARAMETER, GrammarParser.STRING_LITERAL, GrammarParser.BLOB_LITERAL]:
                    self.state = 863
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
                    if la_ == 1:
                        self.state = 862
                        self.match(GrammarParser.DISTINCT_)


                    self.state = 865
                    self.expr(0)
                    self.state = 870
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 866
                        self.match(GrammarParser.COMMA)
                        self.state = 867
                        self.expr(0)
                        self.state = 872
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                elif token in [GrammarParser.STAR]:
                    self.state = 873
                    self.match(GrammarParser.STAR)
                    pass
                elif token in [GrammarParser.CLOSE_PAR]:
                    pass
                else:
                    pass
                self.state = 876
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 878
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                if la_ == 1:
                    self.state = 877
                    self.filter_clause()


                self.state = 881
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
                if la_ == 1:
                    self.state = 880
                    self.over_clause()


                pass

            elif la_ == 6:
                self.state = 883
                self.match(GrammarParser.OPEN_PAR)
                self.state = 884
                self.expr(0)
                self.state = 889
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 885
                    self.match(GrammarParser.COMMA)
                    self.state = 886
                    self.expr(0)
                    self.state = 891
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 892
                self.match(GrammarParser.CLOSE_PAR)
                pass

            elif la_ == 7:
                self.state = 894
                self.match(GrammarParser.CAST_)
                self.state = 895
                self.match(GrammarParser.OPEN_PAR)
                self.state = 896
                self.expr(0)
                self.state = 897
                self.match(GrammarParser.AS_)
                self.state = 898
                self.type_name()
                self.state = 899
                self.match(GrammarParser.CLOSE_PAR)
                pass

            elif la_ == 8:
                self.state = 905
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.EXISTS_ or _la==GrammarParser.NOT_:
                    self.state = 902
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GrammarParser.NOT_:
                        self.state = 901
                        self.match(GrammarParser.NOT_)


                    self.state = 904
                    self.match(GrammarParser.EXISTS_)


                self.state = 907
                self.match(GrammarParser.OPEN_PAR)
                self.state = 908
                self.select_stmt()
                self.state = 909
                self.match(GrammarParser.CLOSE_PAR)
                pass

            elif la_ == 9:
                self.state = 911
                self.match(GrammarParser.CASE_)
                self.state = 913
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,112,self._ctx)
                if la_ == 1:
                    self.state = 912
                    self.expr(0)


                self.state = 920 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 915
                    self.match(GrammarParser.WHEN_)
                    self.state = 916
                    self.expr(0)
                    self.state = 917
                    self.match(GrammarParser.THEN_)
                    self.state = 918
                    self.expr(0)
                    self.state = 922 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==GrammarParser.WHEN_):
                        break

                self.state = 926
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ELSE_:
                    self.state = 924
                    self.match(GrammarParser.ELSE_)
                    self.state = 925
                    self.expr(0)


                self.state = 928
                self.match(GrammarParser.END_)
                pass

            elif la_ == 10:
                self.state = 930
                self.raise_function()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1052
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,131,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1050
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,130,self._ctx)
                    if la_ == 1:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 933
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 934
                        self.match(GrammarParser.PIPE2)
                        self.state = 935
                        self.expr(21)
                        pass

                    elif la_ == 2:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 936
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 937
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.STAR) | (1 << GrammarParser.DIV) | (1 << GrammarParser.MOD))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 938
                        self.expr(20)
                        pass

                    elif la_ == 3:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 939
                        if not self.precpred(self._ctx, 18):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 18)")
                        self.state = 940
                        _la = self._input.LA(1)
                        if not(_la==GrammarParser.PLUS or _la==GrammarParser.MINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 941
                        self.expr(19)
                        pass

                    elif la_ == 4:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 942
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 943
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.LT2) | (1 << GrammarParser.GT2) | (1 << GrammarParser.AMP) | (1 << GrammarParser.PIPE))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 944
                        self.expr(18)
                        pass

                    elif la_ == 5:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 945
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 946
                        _la = self._input.LA(1)
                        if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.LT) | (1 << GrammarParser.LT_EQ) | (1 << GrammarParser.GT) | (1 << GrammarParser.GT_EQ))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 947
                        self.expr(17)
                        pass

                    elif la_ == 6:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 948
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 961
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                        if la_ == 1:
                            self.state = 949
                            self.match(GrammarParser.ASSIGN)
                            pass

                        elif la_ == 2:
                            self.state = 950
                            self.match(GrammarParser.EQ)
                            pass

                        elif la_ == 3:
                            self.state = 951
                            self.match(GrammarParser.NOT_EQ1)
                            pass

                        elif la_ == 4:
                            self.state = 952
                            self.match(GrammarParser.NOT_EQ2)
                            pass

                        elif la_ == 5:
                            self.state = 953
                            self.match(GrammarParser.IS_)
                            pass

                        elif la_ == 6:
                            self.state = 954
                            self.match(GrammarParser.IS_)
                            self.state = 955
                            self.match(GrammarParser.NOT_)
                            pass

                        elif la_ == 7:
                            self.state = 956
                            self.match(GrammarParser.IN_)
                            pass

                        elif la_ == 8:
                            self.state = 957
                            self.match(GrammarParser.LIKE_)
                            pass

                        elif la_ == 9:
                            self.state = 958
                            self.match(GrammarParser.GLOB_)
                            pass

                        elif la_ == 10:
                            self.state = 959
                            self.match(GrammarParser.MATCH_)
                            pass

                        elif la_ == 11:
                            self.state = 960
                            self.match(GrammarParser.REGEXP_)
                            pass


                        self.state = 963
                        self.expr(16)
                        pass

                    elif la_ == 7:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 964
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 965
                        self.match(GrammarParser.AND_)
                        self.state = 966
                        self.expr(15)
                        pass

                    elif la_ == 8:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 967
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 968
                        self.match(GrammarParser.OR_)
                        self.state = 969
                        self.expr(14)
                        pass

                    elif la_ == 9:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 970
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 971
                        self.match(GrammarParser.IS_)
                        self.state = 973
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,117,self._ctx)
                        if la_ == 1:
                            self.state = 972
                            self.match(GrammarParser.NOT_)


                        self.state = 975
                        self.expr(7)
                        pass

                    elif la_ == 10:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 976
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 978
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GrammarParser.NOT_:
                            self.state = 977
                            self.match(GrammarParser.NOT_)


                        self.state = 980
                        self.match(GrammarParser.BETWEEN_)
                        self.state = 981
                        self.expr(0)
                        self.state = 982
                        self.match(GrammarParser.AND_)
                        self.state = 983
                        self.expr(6)
                        pass

                    elif la_ == 11:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 985
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 986
                        self.match(GrammarParser.COLLATE_)
                        self.state = 987
                        self.collation_name()
                        pass

                    elif la_ == 12:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 988
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 990
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GrammarParser.NOT_:
                            self.state = 989
                            self.match(GrammarParser.NOT_)


                        self.state = 992
                        _la = self._input.LA(1)
                        if not(((((_la - 77)) & ~0x3f) == 0 and ((1 << (_la - 77)) & ((1 << (GrammarParser.GLOB_ - 77)) | (1 << (GrammarParser.LIKE_ - 77)) | (1 << (GrammarParser.MATCH_ - 77)) | (1 << (GrammarParser.REGEXP_ - 77)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 993
                        self.expr(0)
                        self.state = 996
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,120,self._ctx)
                        if la_ == 1:
                            self.state = 994
                            self.match(GrammarParser.ESCAPE_)
                            self.state = 995
                            self.expr(0)


                        pass

                    elif la_ == 13:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 998
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 1003
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [GrammarParser.ISNULL_]:
                            self.state = 999
                            self.match(GrammarParser.ISNULL_)
                            pass
                        elif token in [GrammarParser.NOTNULL_]:
                            self.state = 1000
                            self.match(GrammarParser.NOTNULL_)
                            pass
                        elif token in [GrammarParser.NOT_]:
                            self.state = 1001
                            self.match(GrammarParser.NOT_)
                            self.state = 1002
                            self.match(GrammarParser.NULL_)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 14:
                        localctx = GrammarParser.ExprContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                        self.state = 1005
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 1007
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==GrammarParser.NOT_:
                            self.state = 1006
                            self.match(GrammarParser.NOT_)


                        self.state = 1009
                        self.match(GrammarParser.IN_)
                        self.state = 1048
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                        if la_ == 1:
                            self.state = 1010
                            self.match(GrammarParser.OPEN_PAR)
                            self.state = 1020
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,124,self._ctx)
                            if la_ == 1:
                                self.state = 1011
                                self.select_stmt()

                            elif la_ == 2:
                                self.state = 1012
                                self.expr(0)
                                self.state = 1017
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)
                                while _la==GrammarParser.COMMA:
                                    self.state = 1013
                                    self.match(GrammarParser.COMMA)
                                    self.state = 1014
                                    self.expr(0)
                                    self.state = 1019
                                    self._errHandler.sync(self)
                                    _la = self._input.LA(1)



                            self.state = 1022
                            self.match(GrammarParser.CLOSE_PAR)
                            pass

                        elif la_ == 2:
                            self.state = 1026
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,125,self._ctx)
                            if la_ == 1:
                                self.state = 1023
                                self.schema_name()
                                self.state = 1024
                                self.match(GrammarParser.DOT)


                            self.state = 1028
                            self.table_name()
                            pass

                        elif la_ == 3:
                            self.state = 1032
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,126,self._ctx)
                            if la_ == 1:
                                self.state = 1029
                                self.schema_name()
                                self.state = 1030
                                self.match(GrammarParser.DOT)


                            self.state = 1034
                            self.table_function_name()
                            self.state = 1035
                            self.match(GrammarParser.OPEN_PAR)
                            self.state = 1044
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.OPEN_PAR) | (1 << GrammarParser.PLUS) | (1 << GrammarParser.MINUS) | (1 << GrammarParser.TILDE) | (1 << GrammarParser.ABORT_) | (1 << GrammarParser.ACTION_) | (1 << GrammarParser.ADD_) | (1 << GrammarParser.AFTER_) | (1 << GrammarParser.ALL_) | (1 << GrammarParser.ALTER_) | (1 << GrammarParser.ANALYZE_) | (1 << GrammarParser.AND_) | (1 << GrammarParser.AS_) | (1 << GrammarParser.ASC_) | (1 << GrammarParser.ATTACH_) | (1 << GrammarParser.AUTOINCREMENT_) | (1 << GrammarParser.BEFORE_) | (1 << GrammarParser.BEGIN_) | (1 << GrammarParser.BETWEEN_) | (1 << GrammarParser.BY_) | (1 << GrammarParser.CASCADE_) | (1 << GrammarParser.CASE_) | (1 << GrammarParser.CAST_) | (1 << GrammarParser.CHECK_) | (1 << GrammarParser.COLLATE_) | (1 << GrammarParser.COLUMN_) | (1 << GrammarParser.COMMIT_) | (1 << GrammarParser.CONFLICT_) | (1 << GrammarParser.CONSTRAINT_) | (1 << GrammarParser.CREATE_) | (1 << GrammarParser.CROSS_) | (1 << GrammarParser.CURRENT_DATE_) | (1 << GrammarParser.CURRENT_TIME_) | (1 << GrammarParser.CURRENT_TIMESTAMP_) | (1 << GrammarParser.DATABASE_) | (1 << GrammarParser.DEFAULT_) | (1 << GrammarParser.DEFERRABLE_) | (1 << GrammarParser.DEFERRED_) | (1 << GrammarParser.DELETE_) | (1 << GrammarParser.DESC_) | (1 << GrammarParser.DETACH_) | (1 << GrammarParser.DISTINCT_) | (1 << GrammarParser.DROP_))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GrammarParser.EACH_ - 64)) | (1 << (GrammarParser.ELSE_ - 64)) | (1 << (GrammarParser.END_ - 64)) | (1 << (GrammarParser.ESCAPE_ - 64)) | (1 << (GrammarParser.EXCEPT_ - 64)) | (1 << (GrammarParser.EXCLUSIVE_ - 64)) | (1 << (GrammarParser.EXISTS_ - 64)) | (1 << (GrammarParser.EXPLAIN_ - 64)) | (1 << (GrammarParser.FAIL_ - 64)) | (1 << (GrammarParser.FOR_ - 64)) | (1 << (GrammarParser.FOREIGN_ - 64)) | (1 << (GrammarParser.FROM_ - 64)) | (1 << (GrammarParser.FULL_ - 64)) | (1 << (GrammarParser.GLOB_ - 64)) | (1 << (GrammarParser.GROUP_ - 64)) | (1 << (GrammarParser.HAVING_ - 64)) | (1 << (GrammarParser.IF_ - 64)) | (1 << (GrammarParser.IGNORE_ - 64)) | (1 << (GrammarParser.IMMEDIATE_ - 64)) | (1 << (GrammarParser.IN_ - 64)) | (1 << (GrammarParser.INDEX_ - 64)) | (1 << (GrammarParser.INDEXED_ - 64)) | (1 << (GrammarParser.INITIALLY_ - 64)) | (1 << (GrammarParser.INNER_ - 64)) | (1 << (GrammarParser.INSERT_ - 64)) | (1 << (GrammarParser.INSTEAD_ - 64)) | (1 << (GrammarParser.INTERSECT_ - 64)) | (1 << (GrammarParser.INTO_ - 64)) | (1 << (GrammarParser.IS_ - 64)) | (1 << (GrammarParser.ISNULL_ - 64)) | (1 << (GrammarParser.JOIN_ - 64)) | (1 << (GrammarParser.KEY_ - 64)) | (1 << (GrammarParser.LEFT_ - 64)) | (1 << (GrammarParser.LIKE_ - 64)) | (1 << (GrammarParser.LIMIT_ - 64)) | (1 << (GrammarParser.MATCH_ - 64)) | (1 << (GrammarParser.NATURAL_ - 64)) | (1 << (GrammarParser.NO_ - 64)) | (1 << (GrammarParser.NOT_ - 64)) | (1 << (GrammarParser.NOTNULL_ - 64)) | (1 << (GrammarParser.NULL_ - 64)) | (1 << (GrammarParser.OF_ - 64)) | (1 << (GrammarParser.OFFSET_ - 64)) | (1 << (GrammarParser.ON_ - 64)) | (1 << (GrammarParser.OR_ - 64)) | (1 << (GrammarParser.ORDER_ - 64)) | (1 << (GrammarParser.OUTER_ - 64)) | (1 << (GrammarParser.PLAN_ - 64)) | (1 << (GrammarParser.PRAGMA_ - 64)) | (1 << (GrammarParser.PRIMARY_ - 64)) | (1 << (GrammarParser.QUERY_ - 64)) | (1 << (GrammarParser.RAISE_ - 64)) | (1 << (GrammarParser.RECURSIVE_ - 64)) | (1 << (GrammarParser.REFERENCES_ - 64)) | (1 << (GrammarParser.REGEXP_ - 64)) | (1 << (GrammarParser.REINDEX_ - 64)) | (1 << (GrammarParser.RELEASE_ - 64)) | (1 << (GrammarParser.RENAME_ - 64)) | (1 << (GrammarParser.REPLACE_ - 64)) | (1 << (GrammarParser.RESTRICT_ - 64)) | (1 << (GrammarParser.RIGHT_ - 64)) | (1 << (GrammarParser.ROLLBACK_ - 64)) | (1 << (GrammarParser.ROW_ - 64)) | (1 << (GrammarParser.ROWS_ - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (GrammarParser.SAVEPOINT_ - 128)) | (1 << (GrammarParser.SELECT_ - 128)) | (1 << (GrammarParser.SET_ - 128)) | (1 << (GrammarParser.TABLE_ - 128)) | (1 << (GrammarParser.TEMP_ - 128)) | (1 << (GrammarParser.TEMPORARY_ - 128)) | (1 << (GrammarParser.THEN_ - 128)) | (1 << (GrammarParser.TO_ - 128)) | (1 << (GrammarParser.TRANSACTION_ - 128)) | (1 << (GrammarParser.TRIGGER_ - 128)) | (1 << (GrammarParser.UNION_ - 128)) | (1 << (GrammarParser.UNIQUE_ - 128)) | (1 << (GrammarParser.UPDATE_ - 128)) | (1 << (GrammarParser.USING_ - 128)) | (1 << (GrammarParser.VACUUM_ - 128)) | (1 << (GrammarParser.VALUES_ - 128)) | (1 << (GrammarParser.VIEW_ - 128)) | (1 << (GrammarParser.VIRTUAL_ - 128)) | (1 << (GrammarParser.WHEN_ - 128)) | (1 << (GrammarParser.WHERE_ - 128)) | (1 << (GrammarParser.WITH_ - 128)) | (1 << (GrammarParser.WITHOUT_ - 128)) | (1 << (GrammarParser.FIRST_VALUE_ - 128)) | (1 << (GrammarParser.OVER_ - 128)) | (1 << (GrammarParser.PARTITION_ - 128)) | (1 << (GrammarParser.RANGE_ - 128)) | (1 << (GrammarParser.PRECEDING_ - 128)) | (1 << (GrammarParser.UNBOUNDED_ - 128)) | (1 << (GrammarParser.CURRENT_ - 128)) | (1 << (GrammarParser.FOLLOWING_ - 128)) | (1 << (GrammarParser.CUME_DIST_ - 128)) | (1 << (GrammarParser.DENSE_RANK_ - 128)) | (1 << (GrammarParser.LAG_ - 128)) | (1 << (GrammarParser.LAST_VALUE_ - 128)) | (1 << (GrammarParser.LEAD_ - 128)) | (1 << (GrammarParser.NTH_VALUE_ - 128)) | (1 << (GrammarParser.NTILE_ - 128)) | (1 << (GrammarParser.PERCENT_RANK_ - 128)) | (1 << (GrammarParser.RANK_ - 128)) | (1 << (GrammarParser.ROW_NUMBER_ - 128)) | (1 << (GrammarParser.GENERATED_ - 128)) | (1 << (GrammarParser.ALWAYS_ - 128)) | (1 << (GrammarParser.STORED_ - 128)) | (1 << (GrammarParser.TRUE_ - 128)) | (1 << (GrammarParser.FALSE_ - 128)) | (1 << (GrammarParser.WINDOW_ - 128)) | (1 << (GrammarParser.NULLS_ - 128)) | (1 << (GrammarParser.FIRST_ - 128)) | (1 << (GrammarParser.LAST_ - 128)) | (1 << (GrammarParser.FILTER_ - 128)) | (1 << (GrammarParser.GROUPS_ - 128)) | (1 << (GrammarParser.EXCLUDE_ - 128)) | (1 << (GrammarParser.IDENTIFIER - 128)) | (1 << (GrammarParser.NUMERIC_LITERAL - 128)) | (1 << (GrammarParser.BIND_PARAMETER - 128)) | (1 << (GrammarParser.STRING_LITERAL - 128)) | (1 << (GrammarParser.BLOB_LITERAL - 128)))) != 0):
                                self.state = 1036
                                self.expr(0)
                                self.state = 1041
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)
                                while _la==GrammarParser.COMMA:
                                    self.state = 1037
                                    self.match(GrammarParser.COMMA)
                                    self.state = 1038
                                    self.expr(0)
                                    self.state = 1043
                                    self._errHandler.sync(self)
                                    _la = self._input.LA(1)



                            self.state = 1046
                            self.match(GrammarParser.CLOSE_PAR)
                            pass


                        pass

             
                self.state = 1054
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,131,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Raise_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAISE_(self):
            return self.getToken(GrammarParser.RAISE_, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def IGNORE_(self):
            return self.getToken(GrammarParser.IGNORE_, 0)

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def error_message(self):
            return self.getTypedRuleContext(GrammarParser.Error_messageContext,0)


        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def ABORT_(self):
            return self.getToken(GrammarParser.ABORT_, 0)

        def FAIL_(self):
            return self.getToken(GrammarParser.FAIL_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_raise_function

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRaise_function" ):
                return visitor.visitRaise_function(self)
            else:
                return visitor.visitChildren(self)




    def raise_function(self):

        localctx = GrammarParser.Raise_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_raise_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1055
            self.match(GrammarParser.RAISE_)
            self.state = 1056
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1061
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.IGNORE_]:
                self.state = 1057
                self.match(GrammarParser.IGNORE_)
                pass
            elif token in [GrammarParser.ABORT_, GrammarParser.FAIL_, GrammarParser.ROLLBACK_]:
                self.state = 1058
                _la = self._input.LA(1)
                if not(_la==GrammarParser.ABORT_ or _la==GrammarParser.FAIL_ or _la==GrammarParser.ROLLBACK_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1059
                self.match(GrammarParser.COMMA)
                self.state = 1060
                self.error_message()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1063
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Literal_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMERIC_LITERAL(self):
            return self.getToken(GrammarParser.NUMERIC_LITERAL, 0)

        def STRING_LITERAL(self):
            return self.getToken(GrammarParser.STRING_LITERAL, 0)

        def BLOB_LITERAL(self):
            return self.getToken(GrammarParser.BLOB_LITERAL, 0)

        def NULL_(self):
            return self.getToken(GrammarParser.NULL_, 0)

        def TRUE_(self):
            return self.getToken(GrammarParser.TRUE_, 0)

        def FALSE_(self):
            return self.getToken(GrammarParser.FALSE_, 0)

        def CURRENT_TIME_(self):
            return self.getToken(GrammarParser.CURRENT_TIME_, 0)

        def CURRENT_DATE_(self):
            return self.getToken(GrammarParser.CURRENT_DATE_, 0)

        def CURRENT_TIMESTAMP_(self):
            return self.getToken(GrammarParser.CURRENT_TIMESTAMP_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_literal_value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLiteral_value" ):
                return visitor.visitLiteral_value(self)
            else:
                return visitor.visitChildren(self)




    def literal_value(self):

        localctx = GrammarParser.Literal_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_literal_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1065
            _la = self._input.LA(1)
            if not(((((_la - 52)) & ~0x3f) == 0 and ((1 << (_la - 52)) & ((1 << (GrammarParser.CURRENT_DATE_ - 52)) | (1 << (GrammarParser.CURRENT_TIME_ - 52)) | (1 << (GrammarParser.CURRENT_TIMESTAMP_ - 52)) | (1 << (GrammarParser.NULL_ - 52)))) != 0) or ((((_la - 171)) & ~0x3f) == 0 and ((1 << (_la - 171)) & ((1 << (GrammarParser.TRUE_ - 171)) | (1 << (GrammarParser.FALSE_ - 171)) | (1 << (GrammarParser.NUMERIC_LITERAL - 171)) | (1 << (GrammarParser.STRING_LITERAL - 171)) | (1 << (GrammarParser.BLOB_LITERAL - 171)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTO_(self):
            return self.getToken(GrammarParser.INTO_, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def INSERT_(self):
            return self.getToken(GrammarParser.INSERT_, 0)

        def REPLACE_(self):
            return self.getToken(GrammarParser.REPLACE_, 0)

        def OR_(self):
            return self.getToken(GrammarParser.OR_, 0)

        def with_clause(self):
            return self.getTypedRuleContext(GrammarParser.With_clauseContext,0)


        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def ABORT_(self):
            return self.getToken(GrammarParser.ABORT_, 0)

        def FAIL_(self):
            return self.getToken(GrammarParser.FAIL_, 0)

        def IGNORE_(self):
            return self.getToken(GrammarParser.IGNORE_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def table_alias(self):
            return self.getTypedRuleContext(GrammarParser.Table_aliasContext,0)


        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.OPEN_PAR)
            else:
                return self.getToken(GrammarParser.OPEN_PAR, i)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.CLOSE_PAR)
            else:
                return self.getToken(GrammarParser.CLOSE_PAR, i)

        def VALUES_(self):
            return self.getToken(GrammarParser.VALUES_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def upsert_clause(self):
            return self.getTypedRuleContext(GrammarParser.Upsert_clauseContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def DEFAULT_(self):
            return self.getToken(GrammarParser.DEFAULT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_insert_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInsert_stmt" ):
                return visitor.visitInsert_stmt(self)
            else:
                return visitor.visitChildren(self)




    def insert_stmt(self):

        localctx = GrammarParser.Insert_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_insert_stmt)
        self._la = 0 # Token type
        try:
            self.state = 1137
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.INSERT_, GrammarParser.REPLACE_, GrammarParser.WITH_]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1068
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.WITH_:
                    self.state = 1067
                    self.with_clause()


                self.state = 1075
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,134,self._ctx)
                if la_ == 1:
                    self.state = 1070
                    self.match(GrammarParser.INSERT_)
                    pass

                elif la_ == 2:
                    self.state = 1071
                    self.match(GrammarParser.REPLACE_)
                    pass

                elif la_ == 3:
                    self.state = 1072
                    self.match(GrammarParser.INSERT_)
                    self.state = 1073
                    self.match(GrammarParser.OR_)
                    self.state = 1074
                    _la = self._input.LA(1)
                    if not(_la==GrammarParser.ABORT_ or ((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & ((1 << (GrammarParser.FAIL_ - 72)) | (1 << (GrammarParser.IGNORE_ - 72)) | (1 << (GrammarParser.REPLACE_ - 72)) | (1 << (GrammarParser.ROLLBACK_ - 72)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    pass


                self.state = 1077
                self.match(GrammarParser.INTO_)
                self.state = 1081
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,135,self._ctx)
                if la_ == 1:
                    self.state = 1078
                    self.schema_name()
                    self.state = 1079
                    self.match(GrammarParser.DOT)


                self.state = 1083
                self.table_name()
                self.state = 1086
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.AS_:
                    self.state = 1084
                    self.match(GrammarParser.AS_)
                    self.state = 1085
                    self.table_alias()


                self.state = 1099
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.OPEN_PAR:
                    self.state = 1088
                    self.match(GrammarParser.OPEN_PAR)
                    self.state = 1089
                    self.column_name()
                    self.state = 1094
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1090
                        self.match(GrammarParser.COMMA)
                        self.state = 1091
                        self.column_name()
                        self.state = 1096
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1097
                    self.match(GrammarParser.CLOSE_PAR)


                self.state = 1130
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,142,self._ctx)
                if la_ == 1:
                    self.state = 1101
                    self.match(GrammarParser.VALUES_)
                    self.state = 1102
                    self.match(GrammarParser.OPEN_PAR)
                    self.state = 1103
                    self.expr(0)
                    self.state = 1108
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1104
                        self.match(GrammarParser.COMMA)
                        self.state = 1105
                        self.expr(0)
                        self.state = 1110
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1111
                    self.match(GrammarParser.CLOSE_PAR)
                    self.state = 1126
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1112
                        self.match(GrammarParser.COMMA)
                        self.state = 1113
                        self.match(GrammarParser.OPEN_PAR)
                        self.state = 1114
                        self.expr(0)
                        self.state = 1119
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==GrammarParser.COMMA:
                            self.state = 1115
                            self.match(GrammarParser.COMMA)
                            self.state = 1116
                            self.expr(0)
                            self.state = 1121
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 1122
                        self.match(GrammarParser.CLOSE_PAR)
                        self.state = 1128
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass

                elif la_ == 2:
                    self.state = 1129
                    self.select_stmt()
                    pass


                self.state = 1133
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ON_:
                    self.state = 1132
                    self.upsert_clause()


                pass
            elif token in [GrammarParser.DEFAULT_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1135
                self.match(GrammarParser.DEFAULT_)
                self.state = 1136
                self.match(GrammarParser.VALUES_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Upsert_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON_(self):
            return self.getToken(GrammarParser.ON_, 0)

        def CONFLICT_(self):
            return self.getToken(GrammarParser.CONFLICT_, 0)

        def DO_(self):
            return self.getToken(GrammarParser.DO_, 0)

        def NOTHING_(self):
            return self.getToken(GrammarParser.NOTHING_, 0)

        def UPDATE_(self):
            return self.getToken(GrammarParser.UPDATE_, 0)

        def SET_(self):
            return self.getToken(GrammarParser.SET_, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def indexed_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Indexed_columnContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Indexed_columnContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def EQ(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.EQ)
            else:
                return self.getToken(GrammarParser.EQ, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def WHERE_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.WHERE_)
            else:
                return self.getToken(GrammarParser.WHERE_, i)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def column_name_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_name_listContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_name_listContext,i)


        def getRuleIndex(self):
            return GrammarParser.RULE_upsert_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpsert_clause" ):
                return visitor.visitUpsert_clause(self)
            else:
                return visitor.visitChildren(self)




    def upsert_clause(self):

        localctx = GrammarParser.Upsert_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_upsert_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1139
            self.match(GrammarParser.ON_)
            self.state = 1140
            self.match(GrammarParser.CONFLICT_)
            self.state = 1155
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.OPEN_PAR:
                self.state = 1141
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1142
                self.indexed_column()
                self.state = 1147
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1143
                    self.match(GrammarParser.COMMA)
                    self.state = 1144
                    self.indexed_column()
                    self.state = 1149
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1150
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1153
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.WHERE_:
                    self.state = 1151
                    self.match(GrammarParser.WHERE_)
                    self.state = 1152
                    self.expr(0)




            self.state = 1157
            self.match(GrammarParser.DO_)
            self.state = 1184
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.NOTHING_]:
                self.state = 1158
                self.match(GrammarParser.NOTHING_)
                pass
            elif token in [GrammarParser.UPDATE_]:
                self.state = 1159
                self.match(GrammarParser.UPDATE_)
                self.state = 1160
                self.match(GrammarParser.SET_)

                self.state = 1163
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
                if la_ == 1:
                    self.state = 1161
                    self.column_name()
                    pass

                elif la_ == 2:
                    self.state = 1162
                    self.column_name_list()
                    pass


                self.state = 1165
                self.match(GrammarParser.EQ)
                self.state = 1166
                self.expr(0)
                self.state = 1177
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1167
                    self.match(GrammarParser.COMMA)
                    self.state = 1170
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,149,self._ctx)
                    if la_ == 1:
                        self.state = 1168
                        self.column_name()
                        pass

                    elif la_ == 2:
                        self.state = 1169
                        self.column_name_list()
                        pass


                    self.state = 1172
                    self.match(GrammarParser.EQ)
                    self.state = 1173
                    self.expr(0)
                    self.state = 1179
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1182
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.WHERE_:
                    self.state = 1180
                    self.match(GrammarParser.WHERE_)
                    self.state = 1181
                    self.expr(0)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PRAGMA_(self):
            return self.getToken(GrammarParser.PRAGMA_, 0)

        def pragma_name(self):
            return self.getTypedRuleContext(GrammarParser.Pragma_nameContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def ASSIGN(self):
            return self.getToken(GrammarParser.ASSIGN, 0)

        def pragma_value(self):
            return self.getTypedRuleContext(GrammarParser.Pragma_valueContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_pragma_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_stmt" ):
                return visitor.visitPragma_stmt(self)
            else:
                return visitor.visitChildren(self)




    def pragma_stmt(self):

        localctx = GrammarParser.Pragma_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_pragma_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1186
            self.match(GrammarParser.PRAGMA_)
            self.state = 1190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,153,self._ctx)
            if la_ == 1:
                self.state = 1187
                self.schema_name()
                self.state = 1188
                self.match(GrammarParser.DOT)


            self.state = 1192
            self.pragma_name()
            self.state = 1199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.ASSIGN]:
                self.state = 1193
                self.match(GrammarParser.ASSIGN)
                self.state = 1194
                self.pragma_value()
                pass
            elif token in [GrammarParser.OPEN_PAR]:
                self.state = 1195
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1196
                self.pragma_value()
                self.state = 1197
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.EOF, GrammarParser.SCOL, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.ATTACH_, GrammarParser.BEGIN_, GrammarParser.COMMIT_, GrammarParser.CREATE_, GrammarParser.DEFAULT_, GrammarParser.DELETE_, GrammarParser.DETACH_, GrammarParser.END_, GrammarParser.EXPLAIN_, GrammarParser.INSERT_, GrammarParser.PRAGMA_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.REPLACE_, GrammarParser.ROLLBACK_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.UPDATE_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.WITH_]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def signed_number(self):
            return self.getTypedRuleContext(GrammarParser.Signed_numberContext,0)


        def name(self):
            return self.getTypedRuleContext(GrammarParser.NameContext,0)


        def STRING_LITERAL(self):
            return self.getToken(GrammarParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_pragma_value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_value" ):
                return visitor.visitPragma_value(self)
            else:
                return visitor.visitChildren(self)




    def pragma_value(self):

        localctx = GrammarParser.Pragma_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_pragma_value)
        try:
            self.state = 1204
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,155,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1201
                self.signed_number()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1202
                self.name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1203
                self.match(GrammarParser.STRING_LITERAL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Reindex_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REINDEX_(self):
            return self.getToken(GrammarParser.REINDEX_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(GrammarParser.Collation_nameContext,0)


        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def index_name(self):
            return self.getTypedRuleContext(GrammarParser.Index_nameContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_reindex_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitReindex_stmt" ):
                return visitor.visitReindex_stmt(self)
            else:
                return visitor.visitChildren(self)




    def reindex_stmt(self):

        localctx = GrammarParser.Reindex_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_reindex_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1206
            self.match(GrammarParser.REINDEX_)
            self.state = 1217
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,158,self._ctx)
            if la_ == 1:
                self.state = 1207
                self.collation_name()

            elif la_ == 2:
                self.state = 1211
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
                if la_ == 1:
                    self.state = 1208
                    self.schema_name()
                    self.state = 1209
                    self.match(GrammarParser.DOT)


                self.state = 1215
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,157,self._ctx)
                if la_ == 1:
                    self.state = 1213
                    self.table_name()
                    pass

                elif la_ == 2:
                    self.state = 1214
                    self.index_name()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_core(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Select_coreContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Select_coreContext,i)


        def common_table_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Common_table_stmtContext,0)


        def compound_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Compound_operatorContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Compound_operatorContext,i)


        def order_by_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_stmtContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Limit_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_select_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelect_stmt" ):
                return visitor.visitSelect_stmt(self)
            else:
                return visitor.visitChildren(self)




    def select_stmt(self):

        localctx = GrammarParser.Select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1220
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 1219
                self.common_table_stmt()


            self.state = 1222
            self.select_core()
            self.state = 1228
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,160,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 1223
                    self.compound_operator()
                    self.state = 1224
                    self.select_core() 
                self.state = 1230
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,160,self._ctx)

            self.state = 1232
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ORDER_:
                self.state = 1231
                self.order_by_stmt()


            self.state = 1235
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.LIMIT_:
                self.state = 1234
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_or_subquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Table_or_subqueryContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Table_or_subqueryContext,i)


        def join_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Join_operatorContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Join_operatorContext,i)


        def join_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Join_constraintContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Join_constraintContext,i)


        def getRuleIndex(self):
            return GrammarParser.RULE_join_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoin_clause" ):
                return visitor.visitJoin_clause(self)
            else:
                return visitor.visitChildren(self)




    def join_clause(self):

        localctx = GrammarParser.Join_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_join_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1237
            self.table_or_subquery()
            self.state = 1245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA or _la==GrammarParser.CROSS_ or ((((_la - 87)) & ~0x3f) == 0 and ((1 << (_la - 87)) & ((1 << (GrammarParser.INNER_ - 87)) | (1 << (GrammarParser.JOIN_ - 87)) | (1 << (GrammarParser.LEFT_ - 87)) | (1 << (GrammarParser.NATURAL_ - 87)))) != 0):
                self.state = 1238
                self.join_operator()
                self.state = 1239
                self.table_or_subquery()
                self.state = 1241
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
                if la_ == 1:
                    self.state = 1240
                    self.join_constraint()


                self.state = 1247
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_coreContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT_(self):
            return self.getToken(GrammarParser.SELECT_, 0)

        def result_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Result_columnContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Result_columnContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def FROM_(self):
            return self.getToken(GrammarParser.FROM_, 0)

        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def GROUP_(self):
            return self.getToken(GrammarParser.GROUP_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def WINDOW_(self):
            return self.getToken(GrammarParser.WINDOW_, 0)

        def window_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Window_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Window_nameContext,i)


        def AS_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.AS_)
            else:
                return self.getToken(GrammarParser.AS_, i)

        def window_defn(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Window_defnContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Window_defnContext,i)


        def DISTINCT_(self):
            return self.getToken(GrammarParser.DISTINCT_, 0)

        def ALL_(self):
            return self.getToken(GrammarParser.ALL_, 0)

        def table_or_subquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Table_or_subqueryContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Table_or_subqueryContext,i)


        def join_clause(self):
            return self.getTypedRuleContext(GrammarParser.Join_clauseContext,0)


        def HAVING_(self):
            return self.getToken(GrammarParser.HAVING_, 0)

        def VALUES_(self):
            return self.getToken(GrammarParser.VALUES_, 0)

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.OPEN_PAR)
            else:
                return self.getToken(GrammarParser.OPEN_PAR, i)

        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.CLOSE_PAR)
            else:
                return self.getToken(GrammarParser.CLOSE_PAR, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_select_core

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSelect_core" ):
                return visitor.visitSelect_core(self)
            else:
                return visitor.visitChildren(self)




    def select_core(self):

        localctx = GrammarParser.Select_coreContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_select_core)
        self._la = 0 # Token type
        try:
            self.state = 1338
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.SELECT_]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1248
                self.match(GrammarParser.SELECT_)
                self.state = 1250
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,165,self._ctx)
                if la_ == 1:
                    self.state = 1249
                    _la = self._input.LA(1)
                    if not(_la==GrammarParser.ALL_ or _la==GrammarParser.DISTINCT_):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1252
                self.result_column()
                self.state = 1257
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1253
                    self.match(GrammarParser.COMMA)
                    self.state = 1254
                    self.result_column()
                    self.state = 1259
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1272
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.FROM_:
                    self.state = 1260
                    self.match(GrammarParser.FROM_)
                    self.state = 1270
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,168,self._ctx)
                    if la_ == 1:
                        self.state = 1261
                        self.table_or_subquery()
                        self.state = 1266
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==GrammarParser.COMMA:
                            self.state = 1262
                            self.match(GrammarParser.COMMA)
                            self.state = 1263
                            self.table_or_subquery()
                            self.state = 1268
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        pass

                    elif la_ == 2:
                        self.state = 1269
                        self.join_clause()
                        pass




                self.state = 1276
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.WHERE_:
                    self.state = 1274
                    self.match(GrammarParser.WHERE_)
                    self.state = 1275
                    self.expr(0)


                self.state = 1292
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.GROUP_:
                    self.state = 1278
                    self.match(GrammarParser.GROUP_)
                    self.state = 1279
                    self.match(GrammarParser.BY_)
                    self.state = 1280
                    self.expr(0)
                    self.state = 1285
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1281
                        self.match(GrammarParser.COMMA)
                        self.state = 1282
                        self.expr(0)
                        self.state = 1287
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1290
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GrammarParser.HAVING_:
                        self.state = 1288
                        self.match(GrammarParser.HAVING_)
                        self.state = 1289
                        self.expr(0)




                self.state = 1308
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.WINDOW_:
                    self.state = 1294
                    self.match(GrammarParser.WINDOW_)
                    self.state = 1295
                    self.window_name()
                    self.state = 1296
                    self.match(GrammarParser.AS_)
                    self.state = 1297
                    self.window_defn()
                    self.state = 1305
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1298
                        self.match(GrammarParser.COMMA)
                        self.state = 1299
                        self.window_name()
                        self.state = 1300
                        self.match(GrammarParser.AS_)
                        self.state = 1301
                        self.window_defn()
                        self.state = 1307
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                pass
            elif token in [GrammarParser.VALUES_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1310
                self.match(GrammarParser.VALUES_)
                self.state = 1311
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1312
                self.expr(0)
                self.state = 1317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1313
                    self.match(GrammarParser.COMMA)
                    self.state = 1314
                    self.expr(0)
                    self.state = 1319
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1320
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1335
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1321
                    self.match(GrammarParser.COMMA)
                    self.state = 1322
                    self.match(GrammarParser.OPEN_PAR)
                    self.state = 1323
                    self.expr(0)
                    self.state = 1328
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1324
                        self.match(GrammarParser.COMMA)
                        self.state = 1325
                        self.expr(0)
                        self.state = 1330
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1331
                    self.match(GrammarParser.CLOSE_PAR)
                    self.state = 1337
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Factored_select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_factored_select_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFactored_select_stmt" ):
                return visitor.visitFactored_select_stmt(self)
            else:
                return visitor.visitChildren(self)




    def factored_select_stmt(self):

        localctx = GrammarParser.Factored_select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_factored_select_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1340
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_core(self):
            return self.getTypedRuleContext(GrammarParser.Select_coreContext,0)


        def common_table_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Common_table_stmtContext,0)


        def order_by_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_stmtContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Limit_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_simple_select_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_select_stmt" ):
                return visitor.visitSimple_select_stmt(self)
            else:
                return visitor.visitChildren(self)




    def simple_select_stmt(self):

        localctx = GrammarParser.Simple_select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_simple_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1343
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 1342
                self.common_table_stmt()


            self.state = 1345
            self.select_core()
            self.state = 1347
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ORDER_:
                self.state = 1346
                self.order_by_stmt()


            self.state = 1350
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.LIMIT_:
                self.state = 1349
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compound_select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_core(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Select_coreContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Select_coreContext,i)


        def common_table_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Common_table_stmtContext,0)


        def order_by_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_stmtContext,0)


        def limit_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Limit_stmtContext,0)


        def UNION_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.UNION_)
            else:
                return self.getToken(GrammarParser.UNION_, i)

        def INTERSECT_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.INTERSECT_)
            else:
                return self.getToken(GrammarParser.INTERSECT_, i)

        def EXCEPT_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.EXCEPT_)
            else:
                return self.getToken(GrammarParser.EXCEPT_, i)

        def ALL_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.ALL_)
            else:
                return self.getToken(GrammarParser.ALL_, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_compound_select_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompound_select_stmt" ):
                return visitor.visitCompound_select_stmt(self)
            else:
                return visitor.visitChildren(self)




    def compound_select_stmt(self):

        localctx = GrammarParser.Compound_select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_compound_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 1352
                self.common_table_stmt()


            self.state = 1355
            self.select_core()
            self.state = 1365 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1362
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.UNION_]:
                    self.state = 1356
                    self.match(GrammarParser.UNION_)
                    self.state = 1358
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GrammarParser.ALL_:
                        self.state = 1357
                        self.match(GrammarParser.ALL_)


                    pass
                elif token in [GrammarParser.INTERSECT_]:
                    self.state = 1360
                    self.match(GrammarParser.INTERSECT_)
                    pass
                elif token in [GrammarParser.EXCEPT_]:
                    self.state = 1361
                    self.match(GrammarParser.EXCEPT_)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1364
                self.select_core()
                self.state = 1367 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==GrammarParser.EXCEPT_ or _la==GrammarParser.INTERSECT_ or _la==GrammarParser.UNION_):
                    break

            self.state = 1370
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ORDER_:
                self.state = 1369
                self.order_by_stmt()


            self.state = 1373
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.LIMIT_:
                self.state = 1372
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_or_subqueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def table_alias(self):
            return self.getTypedRuleContext(GrammarParser.Table_aliasContext,0)


        def INDEXED_(self):
            return self.getToken(GrammarParser.INDEXED_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def index_name(self):
            return self.getTypedRuleContext(GrammarParser.Index_nameContext,0)


        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def table_function_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_function_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def table_or_subquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Table_or_subqueryContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Table_or_subqueryContext,i)


        def join_clause(self):
            return self.getTypedRuleContext(GrammarParser.Join_clauseContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_table_or_subquery

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_or_subquery" ):
                return visitor.visitTable_or_subquery(self)
            else:
                return visitor.visitChildren(self)




    def table_or_subquery(self):

        localctx = GrammarParser.Table_or_subqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_table_or_subquery)
        self._la = 0 # Token type
        try:
            self.state = 1439
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1378
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,189,self._ctx)
                if la_ == 1:
                    self.state = 1375
                    self.schema_name()
                    self.state = 1376
                    self.match(GrammarParser.DOT)


                self.state = 1380
                self.table_name()
                self.state = 1385
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,191,self._ctx)
                if la_ == 1:
                    self.state = 1382
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
                    if la_ == 1:
                        self.state = 1381
                        self.match(GrammarParser.AS_)


                    self.state = 1384
                    self.table_alias()


                self.state = 1392
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.INDEXED_]:
                    self.state = 1387
                    self.match(GrammarParser.INDEXED_)
                    self.state = 1388
                    self.match(GrammarParser.BY_)
                    self.state = 1389
                    self.index_name()
                    pass
                elif token in [GrammarParser.NOT_]:
                    self.state = 1390
                    self.match(GrammarParser.NOT_)
                    self.state = 1391
                    self.match(GrammarParser.INDEXED_)
                    pass
                elif token in [GrammarParser.EOF, GrammarParser.SCOL, GrammarParser.CLOSE_PAR, GrammarParser.COMMA, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.ATTACH_, GrammarParser.BEGIN_, GrammarParser.COMMIT_, GrammarParser.CREATE_, GrammarParser.CROSS_, GrammarParser.DEFAULT_, GrammarParser.DELETE_, GrammarParser.DETACH_, GrammarParser.END_, GrammarParser.EXCEPT_, GrammarParser.EXPLAIN_, GrammarParser.GROUP_, GrammarParser.INNER_, GrammarParser.INSERT_, GrammarParser.INTERSECT_, GrammarParser.JOIN_, GrammarParser.LEFT_, GrammarParser.LIMIT_, GrammarParser.NATURAL_, GrammarParser.ON_, GrammarParser.ORDER_, GrammarParser.PRAGMA_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.REPLACE_, GrammarParser.ROLLBACK_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.UNION_, GrammarParser.UPDATE_, GrammarParser.USING_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.WHERE_, GrammarParser.WITH_, GrammarParser.WINDOW_]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1397
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,193,self._ctx)
                if la_ == 1:
                    self.state = 1394
                    self.schema_name()
                    self.state = 1395
                    self.match(GrammarParser.DOT)


                self.state = 1399
                self.table_function_name()
                self.state = 1400
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1401
                self.expr(0)
                self.state = 1406
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1402
                    self.match(GrammarParser.COMMA)
                    self.state = 1403
                    self.expr(0)
                    self.state = 1408
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1409
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1414
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
                if la_ == 1:
                    self.state = 1411
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,195,self._ctx)
                    if la_ == 1:
                        self.state = 1410
                        self.match(GrammarParser.AS_)


                    self.state = 1413
                    self.table_alias()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1416
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1426
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,198,self._ctx)
                if la_ == 1:
                    self.state = 1417
                    self.table_or_subquery()
                    self.state = 1422
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1418
                        self.match(GrammarParser.COMMA)
                        self.state = 1419
                        self.table_or_subquery()
                        self.state = 1424
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass

                elif la_ == 2:
                    self.state = 1425
                    self.join_clause()
                    pass


                self.state = 1428
                self.match(GrammarParser.CLOSE_PAR)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1430
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1431
                self.select_stmt()
                self.state = 1432
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1437
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,200,self._ctx)
                if la_ == 1:
                    self.state = 1434
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,199,self._ctx)
                    if la_ == 1:
                        self.state = 1433
                        self.match(GrammarParser.AS_)


                    self.state = 1436
                    self.table_alias()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Result_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STAR(self):
            return self.getToken(GrammarParser.STAR, 0)

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def column_alias(self):
            return self.getTypedRuleContext(GrammarParser.Column_aliasContext,0)


        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_result_column

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitResult_column" ):
                return visitor.visitResult_column(self)
            else:
                return visitor.visitChildren(self)




    def result_column(self):

        localctx = GrammarParser.Result_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_result_column)
        self._la = 0 # Token type
        try:
            self.state = 1453
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,204,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1441
                self.match(GrammarParser.STAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1442
                self.table_name()
                self.state = 1443
                self.match(GrammarParser.DOT)
                self.state = 1444
                self.match(GrammarParser.STAR)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1446
                self.expr(0)
                self.state = 1451
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.AS_ or _la==GrammarParser.IDENTIFIER or _la==GrammarParser.STRING_LITERAL:
                    self.state = 1448
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GrammarParser.AS_:
                        self.state = 1447
                        self.match(GrammarParser.AS_)


                    self.state = 1450
                    self.column_alias()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def JOIN_(self):
            return self.getToken(GrammarParser.JOIN_, 0)

        def NATURAL_(self):
            return self.getToken(GrammarParser.NATURAL_, 0)

        def LEFT_(self):
            return self.getToken(GrammarParser.LEFT_, 0)

        def INNER_(self):
            return self.getToken(GrammarParser.INNER_, 0)

        def CROSS_(self):
            return self.getToken(GrammarParser.CROSS_, 0)

        def OUTER_(self):
            return self.getToken(GrammarParser.OUTER_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_join_operator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoin_operator" ):
                return visitor.visitJoin_operator(self)
            else:
                return visitor.visitChildren(self)




    def join_operator(self):

        localctx = GrammarParser.Join_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_join_operator)
        self._la = 0 # Token type
        try:
            self.state = 1468
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.COMMA]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1455
                self.match(GrammarParser.COMMA)
                pass
            elif token in [GrammarParser.CROSS_, GrammarParser.INNER_, GrammarParser.JOIN_, GrammarParser.LEFT_, GrammarParser.NATURAL_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1457
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.NATURAL_:
                    self.state = 1456
                    self.match(GrammarParser.NATURAL_)


                self.state = 1465
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [GrammarParser.LEFT_]:
                    self.state = 1459
                    self.match(GrammarParser.LEFT_)
                    self.state = 1461
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==GrammarParser.OUTER_:
                        self.state = 1460
                        self.match(GrammarParser.OUTER_)


                    pass
                elif token in [GrammarParser.INNER_]:
                    self.state = 1463
                    self.match(GrammarParser.INNER_)
                    pass
                elif token in [GrammarParser.CROSS_]:
                    self.state = 1464
                    self.match(GrammarParser.CROSS_)
                    pass
                elif token in [GrammarParser.JOIN_]:
                    pass
                else:
                    pass
                self.state = 1467
                self.match(GrammarParser.JOIN_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Join_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON_(self):
            return self.getToken(GrammarParser.ON_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def USING_(self):
            return self.getToken(GrammarParser.USING_, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_join_constraint

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitJoin_constraint" ):
                return visitor.visitJoin_constraint(self)
            else:
                return visitor.visitChildren(self)




    def join_constraint(self):

        localctx = GrammarParser.Join_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_join_constraint)
        self._la = 0 # Token type
        try:
            self.state = 1484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.ON_]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1470
                self.match(GrammarParser.ON_)
                self.state = 1471
                self.expr(0)
                pass
            elif token in [GrammarParser.USING_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1472
                self.match(GrammarParser.USING_)
                self.state = 1473
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1474
                self.column_name()
                self.state = 1479
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1475
                    self.match(GrammarParser.COMMA)
                    self.state = 1476
                    self.column_name()
                    self.state = 1481
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1482
                self.match(GrammarParser.CLOSE_PAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Compound_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UNION_(self):
            return self.getToken(GrammarParser.UNION_, 0)

        def ALL_(self):
            return self.getToken(GrammarParser.ALL_, 0)

        def INTERSECT_(self):
            return self.getToken(GrammarParser.INTERSECT_, 0)

        def EXCEPT_(self):
            return self.getToken(GrammarParser.EXCEPT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_compound_operator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCompound_operator" ):
                return visitor.visitCompound_operator(self)
            else:
                return visitor.visitChildren(self)




    def compound_operator(self):

        localctx = GrammarParser.Compound_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_compound_operator)
        self._la = 0 # Token type
        try:
            self.state = 1492
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.UNION_]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1486
                self.match(GrammarParser.UNION_)
                self.state = 1488
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ALL_:
                    self.state = 1487
                    self.match(GrammarParser.ALL_)


                pass
            elif token in [GrammarParser.INTERSECT_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1490
                self.match(GrammarParser.INTERSECT_)
                pass
            elif token in [GrammarParser.EXCEPT_]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1491
                self.match(GrammarParser.EXCEPT_)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_(self):
            return self.getToken(GrammarParser.UPDATE_, 0)

        def qualified_table_name(self):
            return self.getTypedRuleContext(GrammarParser.Qualified_table_nameContext,0)


        def SET_(self):
            return self.getToken(GrammarParser.SET_, 0)

        def ASSIGN(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.ASSIGN)
            else:
                return self.getToken(GrammarParser.ASSIGN, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def column_name_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_name_listContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_name_listContext,i)


        def with_clause(self):
            return self.getTypedRuleContext(GrammarParser.With_clauseContext,0)


        def OR_(self):
            return self.getToken(GrammarParser.OR_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def ABORT_(self):
            return self.getToken(GrammarParser.ABORT_, 0)

        def REPLACE_(self):
            return self.getToken(GrammarParser.REPLACE_, 0)

        def FAIL_(self):
            return self.getToken(GrammarParser.FAIL_, 0)

        def IGNORE_(self):
            return self.getToken(GrammarParser.IGNORE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_update_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdate_stmt" ):
                return visitor.visitUpdate_stmt(self)
            else:
                return visitor.visitChildren(self)




    def update_stmt(self):

        localctx = GrammarParser.Update_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_update_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1495
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 1494
                self.with_clause()


            self.state = 1497
            self.match(GrammarParser.UPDATE_)
            self.state = 1500
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,214,self._ctx)
            if la_ == 1:
                self.state = 1498
                self.match(GrammarParser.OR_)
                self.state = 1499
                _la = self._input.LA(1)
                if not(_la==GrammarParser.ABORT_ or ((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & ((1 << (GrammarParser.FAIL_ - 72)) | (1 << (GrammarParser.IGNORE_ - 72)) | (1 << (GrammarParser.REPLACE_ - 72)) | (1 << (GrammarParser.ROLLBACK_ - 72)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1502
            self.qualified_table_name()
            self.state = 1503
            self.match(GrammarParser.SET_)
            self.state = 1506
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,215,self._ctx)
            if la_ == 1:
                self.state = 1504
                self.column_name()
                pass

            elif la_ == 2:
                self.state = 1505
                self.column_name_list()
                pass


            self.state = 1508
            self.match(GrammarParser.ASSIGN)
            self.state = 1509
            self.expr(0)
            self.state = 1520
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1510
                self.match(GrammarParser.COMMA)
                self.state = 1513
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,216,self._ctx)
                if la_ == 1:
                    self.state = 1511
                    self.column_name()
                    pass

                elif la_ == 2:
                    self.state = 1512
                    self.column_name_list()
                    pass


                self.state = 1515
                self.match(GrammarParser.ASSIGN)
                self.state = 1516
                self.expr(0)
                self.state = 1522
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WHERE_:
                self.state = 1523
                self.match(GrammarParser.WHERE_)
                self.state = 1524
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_name_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_column_name_list

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_name_list" ):
                return visitor.visitColumn_name_list(self)
            else:
                return visitor.visitChildren(self)




    def column_name_list(self):

        localctx = GrammarParser.Column_name_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_column_name_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1527
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1528
            self.column_name()
            self.state = 1533
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1529
                self.match(GrammarParser.COMMA)
                self.state = 1530
                self.column_name()
                self.state = 1535
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1536
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_stmt_limitedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def UPDATE_(self):
            return self.getToken(GrammarParser.UPDATE_, 0)

        def qualified_table_name(self):
            return self.getTypedRuleContext(GrammarParser.Qualified_table_nameContext,0)


        def SET_(self):
            return self.getToken(GrammarParser.SET_, 0)

        def ASSIGN(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.ASSIGN)
            else:
                return self.getToken(GrammarParser.ASSIGN, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def column_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_nameContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_nameContext,i)


        def column_name_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Column_name_listContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Column_name_listContext,i)


        def with_clause(self):
            return self.getTypedRuleContext(GrammarParser.With_clauseContext,0)


        def OR_(self):
            return self.getToken(GrammarParser.OR_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def limit_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Limit_stmtContext,0)


        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def ABORT_(self):
            return self.getToken(GrammarParser.ABORT_, 0)

        def REPLACE_(self):
            return self.getToken(GrammarParser.REPLACE_, 0)

        def FAIL_(self):
            return self.getToken(GrammarParser.FAIL_, 0)

        def IGNORE_(self):
            return self.getToken(GrammarParser.IGNORE_, 0)

        def order_by_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_update_stmt_limited

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdate_stmt_limited" ):
                return visitor.visitUpdate_stmt_limited(self)
            else:
                return visitor.visitChildren(self)




    def update_stmt_limited(self):

        localctx = GrammarParser.Update_stmt_limitedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_update_stmt_limited)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1539
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WITH_:
                self.state = 1538
                self.with_clause()


            self.state = 1541
            self.match(GrammarParser.UPDATE_)
            self.state = 1544
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,221,self._ctx)
            if la_ == 1:
                self.state = 1542
                self.match(GrammarParser.OR_)
                self.state = 1543
                _la = self._input.LA(1)
                if not(_la==GrammarParser.ABORT_ or ((((_la - 72)) & ~0x3f) == 0 and ((1 << (_la - 72)) & ((1 << (GrammarParser.FAIL_ - 72)) | (1 << (GrammarParser.IGNORE_ - 72)) | (1 << (GrammarParser.REPLACE_ - 72)) | (1 << (GrammarParser.ROLLBACK_ - 72)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 1546
            self.qualified_table_name()
            self.state = 1547
            self.match(GrammarParser.SET_)
            self.state = 1550
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
            if la_ == 1:
                self.state = 1548
                self.column_name()
                pass

            elif la_ == 2:
                self.state = 1549
                self.column_name_list()
                pass


            self.state = 1552
            self.match(GrammarParser.ASSIGN)
            self.state = 1553
            self.expr(0)
            self.state = 1564
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1554
                self.match(GrammarParser.COMMA)
                self.state = 1557
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,223,self._ctx)
                if la_ == 1:
                    self.state = 1555
                    self.column_name()
                    pass

                elif la_ == 2:
                    self.state = 1556
                    self.column_name_list()
                    pass


                self.state = 1559
                self.match(GrammarParser.ASSIGN)
                self.state = 1560
                self.expr(0)
                self.state = 1566
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1569
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.WHERE_:
                self.state = 1567
                self.match(GrammarParser.WHERE_)
                self.state = 1568
                self.expr(0)


            self.state = 1575
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.LIMIT_ or _la==GrammarParser.ORDER_:
                self.state = 1572
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ORDER_:
                    self.state = 1571
                    self.order_by_stmt()


                self.state = 1574
                self.limit_stmt()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qualified_table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_name(self):
            return self.getTypedRuleContext(GrammarParser.Table_nameContext,0)


        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def DOT(self):
            return self.getToken(GrammarParser.DOT, 0)

        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def alias(self):
            return self.getTypedRuleContext(GrammarParser.AliasContext,0)


        def INDEXED_(self):
            return self.getToken(GrammarParser.INDEXED_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def index_name(self):
            return self.getTypedRuleContext(GrammarParser.Index_nameContext,0)


        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_qualified_table_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQualified_table_name" ):
                return visitor.visitQualified_table_name(self)
            else:
                return visitor.visitChildren(self)




    def qualified_table_name(self):

        localctx = GrammarParser.Qualified_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_qualified_table_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1580
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,228,self._ctx)
            if la_ == 1:
                self.state = 1577
                self.schema_name()
                self.state = 1578
                self.match(GrammarParser.DOT)


            self.state = 1582
            self.table_name()
            self.state = 1585
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.AS_:
                self.state = 1583
                self.match(GrammarParser.AS_)
                self.state = 1584
                self.alias()


            self.state = 1592
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.INDEXED_]:
                self.state = 1587
                self.match(GrammarParser.INDEXED_)
                self.state = 1588
                self.match(GrammarParser.BY_)
                self.state = 1589
                self.index_name()
                pass
            elif token in [GrammarParser.NOT_]:
                self.state = 1590
                self.match(GrammarParser.NOT_)
                self.state = 1591
                self.match(GrammarParser.INDEXED_)
                pass
            elif token in [GrammarParser.EOF, GrammarParser.SCOL, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.ATTACH_, GrammarParser.BEGIN_, GrammarParser.COMMIT_, GrammarParser.CREATE_, GrammarParser.DEFAULT_, GrammarParser.DELETE_, GrammarParser.DETACH_, GrammarParser.END_, GrammarParser.EXPLAIN_, GrammarParser.INSERT_, GrammarParser.LIMIT_, GrammarParser.ORDER_, GrammarParser.PRAGMA_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.REPLACE_, GrammarParser.ROLLBACK_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.SET_, GrammarParser.UPDATE_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.WHERE_, GrammarParser.WITH_]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Vacuum_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VACUUM_(self):
            return self.getToken(GrammarParser.VACUUM_, 0)

        def schema_name(self):
            return self.getTypedRuleContext(GrammarParser.Schema_nameContext,0)


        def INTO_(self):
            return self.getToken(GrammarParser.INTO_, 0)

        def filename(self):
            return self.getTypedRuleContext(GrammarParser.FilenameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_vacuum_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVacuum_stmt" ):
                return visitor.visitVacuum_stmt(self)
            else:
                return visitor.visitChildren(self)




    def vacuum_stmt(self):

        localctx = GrammarParser.Vacuum_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_vacuum_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1594
            self.match(GrammarParser.VACUUM_)
            self.state = 1596
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,231,self._ctx)
            if la_ == 1:
                self.state = 1595
                self.schema_name()


            self.state = 1600
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.INTO_:
                self.state = 1598
                self.match(GrammarParser.INTO_)
                self.state = 1599
                self.filename()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Filter_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILTER_(self):
            return self.getToken(GrammarParser.FILTER_, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_filter_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilter_clause" ):
                return visitor.visitFilter_clause(self)
            else:
                return visitor.visitChildren(self)




    def filter_clause(self):

        localctx = GrammarParser.Filter_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_filter_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1602
            self.match(GrammarParser.FILTER_)
            self.state = 1603
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1604
            self.match(GrammarParser.WHERE_)
            self.state = 1605
            self.expr(0)
            self.state = 1606
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_defnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def ORDER_(self):
            return self.getToken(GrammarParser.ORDER_, 0)

        def BY_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.BY_)
            else:
                return self.getToken(GrammarParser.BY_, i)

        def ordering_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Ordering_termContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Ordering_termContext,i)


        def base_window_name(self):
            return self.getTypedRuleContext(GrammarParser.Base_window_nameContext,0)


        def PARTITION_(self):
            return self.getToken(GrammarParser.PARTITION_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def frame_spec(self):
            return self.getTypedRuleContext(GrammarParser.Frame_specContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_window_defn

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindow_defn" ):
                return visitor.visitWindow_defn(self)
            else:
                return visitor.visitChildren(self)




    def window_defn(self):

        localctx = GrammarParser.Window_defnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_window_defn)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1608
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1610
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
            if la_ == 1:
                self.state = 1609
                self.base_window_name()


            self.state = 1622
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.PARTITION_:
                self.state = 1612
                self.match(GrammarParser.PARTITION_)
                self.state = 1613
                self.match(GrammarParser.BY_)
                self.state = 1614
                self.expr(0)
                self.state = 1619
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1615
                    self.match(GrammarParser.COMMA)
                    self.state = 1616
                    self.expr(0)
                    self.state = 1621
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 1624
            self.match(GrammarParser.ORDER_)
            self.state = 1625
            self.match(GrammarParser.BY_)
            self.state = 1626
            self.ordering_term()
            self.state = 1631
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1627
                self.match(GrammarParser.COMMA)
                self.state = 1628
                self.ordering_term()
                self.state = 1633
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 1635
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (GrammarParser.ROWS_ - 127)) | (1 << (GrammarParser.RANGE_ - 127)) | (1 << (GrammarParser.GROUPS_ - 127)))) != 0):
                self.state = 1634
                self.frame_spec()


            self.state = 1637
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Over_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER_(self):
            return self.getToken(GrammarParser.OVER_, 0)

        def window_name(self):
            return self.getTypedRuleContext(GrammarParser.Window_nameContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def base_window_name(self):
            return self.getTypedRuleContext(GrammarParser.Base_window_nameContext,0)


        def PARTITION_(self):
            return self.getToken(GrammarParser.PARTITION_, 0)

        def BY_(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.BY_)
            else:
                return self.getToken(GrammarParser.BY_, i)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def ORDER_(self):
            return self.getToken(GrammarParser.ORDER_, 0)

        def ordering_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Ordering_termContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Ordering_termContext,i)


        def frame_spec(self):
            return self.getTypedRuleContext(GrammarParser.Frame_specContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_over_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOver_clause" ):
                return visitor.visitOver_clause(self)
            else:
                return visitor.visitChildren(self)




    def over_clause(self):

        localctx = GrammarParser.Over_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_over_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1639
            self.match(GrammarParser.OVER_)
            self.state = 1673
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,244,self._ctx)
            if la_ == 1:
                self.state = 1640
                self.window_name()
                pass

            elif la_ == 2:
                self.state = 1641
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1643
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,238,self._ctx)
                if la_ == 1:
                    self.state = 1642
                    self.base_window_name()


                self.state = 1655
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1645
                    self.match(GrammarParser.PARTITION_)
                    self.state = 1646
                    self.match(GrammarParser.BY_)
                    self.state = 1647
                    self.expr(0)
                    self.state = 1652
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1648
                        self.match(GrammarParser.COMMA)
                        self.state = 1649
                        self.expr(0)
                        self.state = 1654
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ORDER_:
                    self.state = 1657
                    self.match(GrammarParser.ORDER_)
                    self.state = 1658
                    self.match(GrammarParser.BY_)
                    self.state = 1659
                    self.ordering_term()
                    self.state = 1664
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==GrammarParser.COMMA:
                        self.state = 1660
                        self.match(GrammarParser.COMMA)
                        self.state = 1661
                        self.ordering_term()
                        self.state = 1666
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 1670
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (GrammarParser.ROWS_ - 127)) | (1 << (GrammarParser.RANGE_ - 127)) | (1 << (GrammarParser.GROUPS_ - 127)))) != 0):
                    self.state = 1669
                    self.frame_spec()


                self.state = 1672
                self.match(GrammarParser.CLOSE_PAR)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def frame_clause(self):
            return self.getTypedRuleContext(GrammarParser.Frame_clauseContext,0)


        def EXCLUDE_(self):
            return self.getToken(GrammarParser.EXCLUDE_, 0)

        def CURRENT_(self):
            return self.getToken(GrammarParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(GrammarParser.ROW_, 0)

        def GROUP_(self):
            return self.getToken(GrammarParser.GROUP_, 0)

        def TIES_(self):
            return self.getToken(GrammarParser.TIES_, 0)

        def NO_(self):
            return self.getToken(GrammarParser.NO_, 0)

        def OTHERS_(self):
            return self.getToken(GrammarParser.OTHERS_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_frame_spec

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrame_spec" ):
                return visitor.visitFrame_spec(self)
            else:
                return visitor.visitChildren(self)




    def frame_spec(self):

        localctx = GrammarParser.Frame_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_frame_spec)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1675
            self.frame_clause()
            self.state = 1683
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.EXCLUDE_]:
                self.state = 1676
                self.match(GrammarParser.EXCLUDE_)

                self.state = 1677
                self.match(GrammarParser.NO_)
                self.state = 1678
                self.match(GrammarParser.OTHERS_)
                pass
            elif token in [GrammarParser.CURRENT_]:
                self.state = 1679
                self.match(GrammarParser.CURRENT_)
                self.state = 1680
                self.match(GrammarParser.ROW_)
                pass
            elif token in [GrammarParser.GROUP_]:
                self.state = 1681
                self.match(GrammarParser.GROUP_)
                pass
            elif token in [GrammarParser.TIES_]:
                self.state = 1682
                self.match(GrammarParser.TIES_)
                pass
            elif token in [GrammarParser.CLOSE_PAR]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANGE_(self):
            return self.getToken(GrammarParser.RANGE_, 0)

        def ROWS_(self):
            return self.getToken(GrammarParser.ROWS_, 0)

        def GROUPS_(self):
            return self.getToken(GrammarParser.GROUPS_, 0)

        def frame_single(self):
            return self.getTypedRuleContext(GrammarParser.Frame_singleContext,0)


        def BETWEEN_(self):
            return self.getToken(GrammarParser.BETWEEN_, 0)

        def frame_left(self):
            return self.getTypedRuleContext(GrammarParser.Frame_leftContext,0)


        def AND_(self):
            return self.getToken(GrammarParser.AND_, 0)

        def frame_right(self):
            return self.getTypedRuleContext(GrammarParser.Frame_rightContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_frame_clause

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrame_clause" ):
                return visitor.visitFrame_clause(self)
            else:
                return visitor.visitChildren(self)




    def frame_clause(self):

        localctx = GrammarParser.Frame_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_frame_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1685
            _la = self._input.LA(1)
            if not(((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (GrammarParser.ROWS_ - 127)) | (1 << (GrammarParser.RANGE_ - 127)) | (1 << (GrammarParser.GROUPS_ - 127)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1692
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,246,self._ctx)
            if la_ == 1:
                self.state = 1686
                self.frame_single()
                pass

            elif la_ == 2:
                self.state = 1687
                self.match(GrammarParser.BETWEEN_)
                self.state = 1688
                self.frame_left()
                self.state = 1689
                self.match(GrammarParser.AND_)
                self.state = 1690
                self.frame_right()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_function_invocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def simple_func(self):
            return self.getTypedRuleContext(GrammarParser.Simple_funcContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def STAR(self):
            return self.getToken(GrammarParser.STAR, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_simple_function_invocation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_function_invocation" ):
                return visitor.visitSimple_function_invocation(self)
            else:
                return visitor.visitChildren(self)




    def simple_function_invocation(self):

        localctx = GrammarParser.Simple_function_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_simple_function_invocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1694
            self.simple_func()
            self.state = 1695
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1705
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.OPEN_PAR, GrammarParser.PLUS, GrammarParser.MINUS, GrammarParser.TILDE, GrammarParser.ABORT_, GrammarParser.ACTION_, GrammarParser.ADD_, GrammarParser.AFTER_, GrammarParser.ALL_, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.AND_, GrammarParser.AS_, GrammarParser.ASC_, GrammarParser.ATTACH_, GrammarParser.AUTOINCREMENT_, GrammarParser.BEFORE_, GrammarParser.BEGIN_, GrammarParser.BETWEEN_, GrammarParser.BY_, GrammarParser.CASCADE_, GrammarParser.CASE_, GrammarParser.CAST_, GrammarParser.CHECK_, GrammarParser.COLLATE_, GrammarParser.COLUMN_, GrammarParser.COMMIT_, GrammarParser.CONFLICT_, GrammarParser.CONSTRAINT_, GrammarParser.CREATE_, GrammarParser.CROSS_, GrammarParser.CURRENT_DATE_, GrammarParser.CURRENT_TIME_, GrammarParser.CURRENT_TIMESTAMP_, GrammarParser.DATABASE_, GrammarParser.DEFAULT_, GrammarParser.DEFERRABLE_, GrammarParser.DEFERRED_, GrammarParser.DELETE_, GrammarParser.DESC_, GrammarParser.DETACH_, GrammarParser.DISTINCT_, GrammarParser.DROP_, GrammarParser.EACH_, GrammarParser.ELSE_, GrammarParser.END_, GrammarParser.ESCAPE_, GrammarParser.EXCEPT_, GrammarParser.EXCLUSIVE_, GrammarParser.EXISTS_, GrammarParser.EXPLAIN_, GrammarParser.FAIL_, GrammarParser.FOR_, GrammarParser.FOREIGN_, GrammarParser.FROM_, GrammarParser.FULL_, GrammarParser.GLOB_, GrammarParser.GROUP_, GrammarParser.HAVING_, GrammarParser.IF_, GrammarParser.IGNORE_, GrammarParser.IMMEDIATE_, GrammarParser.IN_, GrammarParser.INDEX_, GrammarParser.INDEXED_, GrammarParser.INITIALLY_, GrammarParser.INNER_, GrammarParser.INSERT_, GrammarParser.INSTEAD_, GrammarParser.INTERSECT_, GrammarParser.INTO_, GrammarParser.IS_, GrammarParser.ISNULL_, GrammarParser.JOIN_, GrammarParser.KEY_, GrammarParser.LEFT_, GrammarParser.LIKE_, GrammarParser.LIMIT_, GrammarParser.MATCH_, GrammarParser.NATURAL_, GrammarParser.NO_, GrammarParser.NOT_, GrammarParser.NOTNULL_, GrammarParser.NULL_, GrammarParser.OF_, GrammarParser.OFFSET_, GrammarParser.ON_, GrammarParser.OR_, GrammarParser.ORDER_, GrammarParser.OUTER_, GrammarParser.PLAN_, GrammarParser.PRAGMA_, GrammarParser.PRIMARY_, GrammarParser.QUERY_, GrammarParser.RAISE_, GrammarParser.RECURSIVE_, GrammarParser.REFERENCES_, GrammarParser.REGEXP_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.RENAME_, GrammarParser.REPLACE_, GrammarParser.RESTRICT_, GrammarParser.RIGHT_, GrammarParser.ROLLBACK_, GrammarParser.ROW_, GrammarParser.ROWS_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.SET_, GrammarParser.TABLE_, GrammarParser.TEMP_, GrammarParser.TEMPORARY_, GrammarParser.THEN_, GrammarParser.TO_, GrammarParser.TRANSACTION_, GrammarParser.TRIGGER_, GrammarParser.UNION_, GrammarParser.UNIQUE_, GrammarParser.UPDATE_, GrammarParser.USING_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.VIEW_, GrammarParser.VIRTUAL_, GrammarParser.WHEN_, GrammarParser.WHERE_, GrammarParser.WITH_, GrammarParser.WITHOUT_, GrammarParser.FIRST_VALUE_, GrammarParser.OVER_, GrammarParser.PARTITION_, GrammarParser.RANGE_, GrammarParser.PRECEDING_, GrammarParser.UNBOUNDED_, GrammarParser.CURRENT_, GrammarParser.FOLLOWING_, GrammarParser.CUME_DIST_, GrammarParser.DENSE_RANK_, GrammarParser.LAG_, GrammarParser.LAST_VALUE_, GrammarParser.LEAD_, GrammarParser.NTH_VALUE_, GrammarParser.NTILE_, GrammarParser.PERCENT_RANK_, GrammarParser.RANK_, GrammarParser.ROW_NUMBER_, GrammarParser.GENERATED_, GrammarParser.ALWAYS_, GrammarParser.STORED_, GrammarParser.TRUE_, GrammarParser.FALSE_, GrammarParser.WINDOW_, GrammarParser.NULLS_, GrammarParser.FIRST_, GrammarParser.LAST_, GrammarParser.FILTER_, GrammarParser.GROUPS_, GrammarParser.EXCLUDE_, GrammarParser.IDENTIFIER, GrammarParser.NUMERIC_LITERAL, GrammarParser.BIND_PARAMETER, GrammarParser.STRING_LITERAL, GrammarParser.BLOB_LITERAL]:
                self.state = 1696
                self.expr(0)
                self.state = 1701
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1697
                    self.match(GrammarParser.COMMA)
                    self.state = 1698
                    self.expr(0)
                    self.state = 1703
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [GrammarParser.STAR]:
                self.state = 1704
                self.match(GrammarParser.STAR)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1707
            self.match(GrammarParser.CLOSE_PAR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Aggregate_function_invocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aggregate_func(self):
            return self.getTypedRuleContext(GrammarParser.Aggregate_funcContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def STAR(self):
            return self.getToken(GrammarParser.STAR, 0)

        def filter_clause(self):
            return self.getTypedRuleContext(GrammarParser.Filter_clauseContext,0)


        def DISTINCT_(self):
            return self.getToken(GrammarParser.DISTINCT_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_aggregate_function_invocation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregate_function_invocation" ):
                return visitor.visitAggregate_function_invocation(self)
            else:
                return visitor.visitChildren(self)




    def aggregate_function_invocation(self):

        localctx = GrammarParser.Aggregate_function_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_aggregate_function_invocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1709
            self.aggregate_func()
            self.state = 1710
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1723
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.OPEN_PAR, GrammarParser.PLUS, GrammarParser.MINUS, GrammarParser.TILDE, GrammarParser.ABORT_, GrammarParser.ACTION_, GrammarParser.ADD_, GrammarParser.AFTER_, GrammarParser.ALL_, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.AND_, GrammarParser.AS_, GrammarParser.ASC_, GrammarParser.ATTACH_, GrammarParser.AUTOINCREMENT_, GrammarParser.BEFORE_, GrammarParser.BEGIN_, GrammarParser.BETWEEN_, GrammarParser.BY_, GrammarParser.CASCADE_, GrammarParser.CASE_, GrammarParser.CAST_, GrammarParser.CHECK_, GrammarParser.COLLATE_, GrammarParser.COLUMN_, GrammarParser.COMMIT_, GrammarParser.CONFLICT_, GrammarParser.CONSTRAINT_, GrammarParser.CREATE_, GrammarParser.CROSS_, GrammarParser.CURRENT_DATE_, GrammarParser.CURRENT_TIME_, GrammarParser.CURRENT_TIMESTAMP_, GrammarParser.DATABASE_, GrammarParser.DEFAULT_, GrammarParser.DEFERRABLE_, GrammarParser.DEFERRED_, GrammarParser.DELETE_, GrammarParser.DESC_, GrammarParser.DETACH_, GrammarParser.DISTINCT_, GrammarParser.DROP_, GrammarParser.EACH_, GrammarParser.ELSE_, GrammarParser.END_, GrammarParser.ESCAPE_, GrammarParser.EXCEPT_, GrammarParser.EXCLUSIVE_, GrammarParser.EXISTS_, GrammarParser.EXPLAIN_, GrammarParser.FAIL_, GrammarParser.FOR_, GrammarParser.FOREIGN_, GrammarParser.FROM_, GrammarParser.FULL_, GrammarParser.GLOB_, GrammarParser.GROUP_, GrammarParser.HAVING_, GrammarParser.IF_, GrammarParser.IGNORE_, GrammarParser.IMMEDIATE_, GrammarParser.IN_, GrammarParser.INDEX_, GrammarParser.INDEXED_, GrammarParser.INITIALLY_, GrammarParser.INNER_, GrammarParser.INSERT_, GrammarParser.INSTEAD_, GrammarParser.INTERSECT_, GrammarParser.INTO_, GrammarParser.IS_, GrammarParser.ISNULL_, GrammarParser.JOIN_, GrammarParser.KEY_, GrammarParser.LEFT_, GrammarParser.LIKE_, GrammarParser.LIMIT_, GrammarParser.MATCH_, GrammarParser.NATURAL_, GrammarParser.NO_, GrammarParser.NOT_, GrammarParser.NOTNULL_, GrammarParser.NULL_, GrammarParser.OF_, GrammarParser.OFFSET_, GrammarParser.ON_, GrammarParser.OR_, GrammarParser.ORDER_, GrammarParser.OUTER_, GrammarParser.PLAN_, GrammarParser.PRAGMA_, GrammarParser.PRIMARY_, GrammarParser.QUERY_, GrammarParser.RAISE_, GrammarParser.RECURSIVE_, GrammarParser.REFERENCES_, GrammarParser.REGEXP_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.RENAME_, GrammarParser.REPLACE_, GrammarParser.RESTRICT_, GrammarParser.RIGHT_, GrammarParser.ROLLBACK_, GrammarParser.ROW_, GrammarParser.ROWS_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.SET_, GrammarParser.TABLE_, GrammarParser.TEMP_, GrammarParser.TEMPORARY_, GrammarParser.THEN_, GrammarParser.TO_, GrammarParser.TRANSACTION_, GrammarParser.TRIGGER_, GrammarParser.UNION_, GrammarParser.UNIQUE_, GrammarParser.UPDATE_, GrammarParser.USING_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.VIEW_, GrammarParser.VIRTUAL_, GrammarParser.WHEN_, GrammarParser.WHERE_, GrammarParser.WITH_, GrammarParser.WITHOUT_, GrammarParser.FIRST_VALUE_, GrammarParser.OVER_, GrammarParser.PARTITION_, GrammarParser.RANGE_, GrammarParser.PRECEDING_, GrammarParser.UNBOUNDED_, GrammarParser.CURRENT_, GrammarParser.FOLLOWING_, GrammarParser.CUME_DIST_, GrammarParser.DENSE_RANK_, GrammarParser.LAG_, GrammarParser.LAST_VALUE_, GrammarParser.LEAD_, GrammarParser.NTH_VALUE_, GrammarParser.NTILE_, GrammarParser.PERCENT_RANK_, GrammarParser.RANK_, GrammarParser.ROW_NUMBER_, GrammarParser.GENERATED_, GrammarParser.ALWAYS_, GrammarParser.STORED_, GrammarParser.TRUE_, GrammarParser.FALSE_, GrammarParser.WINDOW_, GrammarParser.NULLS_, GrammarParser.FIRST_, GrammarParser.LAST_, GrammarParser.FILTER_, GrammarParser.GROUPS_, GrammarParser.EXCLUDE_, GrammarParser.IDENTIFIER, GrammarParser.NUMERIC_LITERAL, GrammarParser.BIND_PARAMETER, GrammarParser.STRING_LITERAL, GrammarParser.BLOB_LITERAL]:
                self.state = 1712
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,249,self._ctx)
                if la_ == 1:
                    self.state = 1711
                    self.match(GrammarParser.DISTINCT_)


                self.state = 1714
                self.expr(0)
                self.state = 1719
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1715
                    self.match(GrammarParser.COMMA)
                    self.state = 1716
                    self.expr(0)
                    self.state = 1721
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [GrammarParser.STAR]:
                self.state = 1722
                self.match(GrammarParser.STAR)
                pass
            elif token in [GrammarParser.CLOSE_PAR]:
                pass
            else:
                pass
            self.state = 1725
            self.match(GrammarParser.CLOSE_PAR)
            self.state = 1727
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.FILTER_:
                self.state = 1726
                self.filter_clause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_function_invocationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def window_function(self):
            return self.getTypedRuleContext(GrammarParser.Window_functionContext,0)


        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def OVER_(self):
            return self.getToken(GrammarParser.OVER_, 0)

        def window_defn(self):
            return self.getTypedRuleContext(GrammarParser.Window_defnContext,0)


        def window_name(self):
            return self.getTypedRuleContext(GrammarParser.Window_nameContext,0)


        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def STAR(self):
            return self.getToken(GrammarParser.STAR, 0)

        def filter_clause(self):
            return self.getTypedRuleContext(GrammarParser.Filter_clauseContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_window_function_invocation

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindow_function_invocation" ):
                return visitor.visitWindow_function_invocation(self)
            else:
                return visitor.visitChildren(self)




    def window_function_invocation(self):

        localctx = GrammarParser.Window_function_invocationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_window_function_invocation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1729
            self.window_function()
            self.state = 1730
            self.match(GrammarParser.OPEN_PAR)
            self.state = 1740
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.OPEN_PAR, GrammarParser.PLUS, GrammarParser.MINUS, GrammarParser.TILDE, GrammarParser.ABORT_, GrammarParser.ACTION_, GrammarParser.ADD_, GrammarParser.AFTER_, GrammarParser.ALL_, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.AND_, GrammarParser.AS_, GrammarParser.ASC_, GrammarParser.ATTACH_, GrammarParser.AUTOINCREMENT_, GrammarParser.BEFORE_, GrammarParser.BEGIN_, GrammarParser.BETWEEN_, GrammarParser.BY_, GrammarParser.CASCADE_, GrammarParser.CASE_, GrammarParser.CAST_, GrammarParser.CHECK_, GrammarParser.COLLATE_, GrammarParser.COLUMN_, GrammarParser.COMMIT_, GrammarParser.CONFLICT_, GrammarParser.CONSTRAINT_, GrammarParser.CREATE_, GrammarParser.CROSS_, GrammarParser.CURRENT_DATE_, GrammarParser.CURRENT_TIME_, GrammarParser.CURRENT_TIMESTAMP_, GrammarParser.DATABASE_, GrammarParser.DEFAULT_, GrammarParser.DEFERRABLE_, GrammarParser.DEFERRED_, GrammarParser.DELETE_, GrammarParser.DESC_, GrammarParser.DETACH_, GrammarParser.DISTINCT_, GrammarParser.DROP_, GrammarParser.EACH_, GrammarParser.ELSE_, GrammarParser.END_, GrammarParser.ESCAPE_, GrammarParser.EXCEPT_, GrammarParser.EXCLUSIVE_, GrammarParser.EXISTS_, GrammarParser.EXPLAIN_, GrammarParser.FAIL_, GrammarParser.FOR_, GrammarParser.FOREIGN_, GrammarParser.FROM_, GrammarParser.FULL_, GrammarParser.GLOB_, GrammarParser.GROUP_, GrammarParser.HAVING_, GrammarParser.IF_, GrammarParser.IGNORE_, GrammarParser.IMMEDIATE_, GrammarParser.IN_, GrammarParser.INDEX_, GrammarParser.INDEXED_, GrammarParser.INITIALLY_, GrammarParser.INNER_, GrammarParser.INSERT_, GrammarParser.INSTEAD_, GrammarParser.INTERSECT_, GrammarParser.INTO_, GrammarParser.IS_, GrammarParser.ISNULL_, GrammarParser.JOIN_, GrammarParser.KEY_, GrammarParser.LEFT_, GrammarParser.LIKE_, GrammarParser.LIMIT_, GrammarParser.MATCH_, GrammarParser.NATURAL_, GrammarParser.NO_, GrammarParser.NOT_, GrammarParser.NOTNULL_, GrammarParser.NULL_, GrammarParser.OF_, GrammarParser.OFFSET_, GrammarParser.ON_, GrammarParser.OR_, GrammarParser.ORDER_, GrammarParser.OUTER_, GrammarParser.PLAN_, GrammarParser.PRAGMA_, GrammarParser.PRIMARY_, GrammarParser.QUERY_, GrammarParser.RAISE_, GrammarParser.RECURSIVE_, GrammarParser.REFERENCES_, GrammarParser.REGEXP_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.RENAME_, GrammarParser.REPLACE_, GrammarParser.RESTRICT_, GrammarParser.RIGHT_, GrammarParser.ROLLBACK_, GrammarParser.ROW_, GrammarParser.ROWS_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.SET_, GrammarParser.TABLE_, GrammarParser.TEMP_, GrammarParser.TEMPORARY_, GrammarParser.THEN_, GrammarParser.TO_, GrammarParser.TRANSACTION_, GrammarParser.TRIGGER_, GrammarParser.UNION_, GrammarParser.UNIQUE_, GrammarParser.UPDATE_, GrammarParser.USING_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.VIEW_, GrammarParser.VIRTUAL_, GrammarParser.WHEN_, GrammarParser.WHERE_, GrammarParser.WITH_, GrammarParser.WITHOUT_, GrammarParser.FIRST_VALUE_, GrammarParser.OVER_, GrammarParser.PARTITION_, GrammarParser.RANGE_, GrammarParser.PRECEDING_, GrammarParser.UNBOUNDED_, GrammarParser.CURRENT_, GrammarParser.FOLLOWING_, GrammarParser.CUME_DIST_, GrammarParser.DENSE_RANK_, GrammarParser.LAG_, GrammarParser.LAST_VALUE_, GrammarParser.LEAD_, GrammarParser.NTH_VALUE_, GrammarParser.NTILE_, GrammarParser.PERCENT_RANK_, GrammarParser.RANK_, GrammarParser.ROW_NUMBER_, GrammarParser.GENERATED_, GrammarParser.ALWAYS_, GrammarParser.STORED_, GrammarParser.TRUE_, GrammarParser.FALSE_, GrammarParser.WINDOW_, GrammarParser.NULLS_, GrammarParser.FIRST_, GrammarParser.LAST_, GrammarParser.FILTER_, GrammarParser.GROUPS_, GrammarParser.EXCLUDE_, GrammarParser.IDENTIFIER, GrammarParser.NUMERIC_LITERAL, GrammarParser.BIND_PARAMETER, GrammarParser.STRING_LITERAL, GrammarParser.BLOB_LITERAL]:
                self.state = 1731
                self.expr(0)
                self.state = 1736
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==GrammarParser.COMMA:
                    self.state = 1732
                    self.match(GrammarParser.COMMA)
                    self.state = 1733
                    self.expr(0)
                    self.state = 1738
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [GrammarParser.STAR]:
                self.state = 1739
                self.match(GrammarParser.STAR)
                pass
            elif token in [GrammarParser.CLOSE_PAR]:
                pass
            else:
                pass
            self.state = 1742
            self.match(GrammarParser.CLOSE_PAR)
            self.state = 1744
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.FILTER_:
                self.state = 1743
                self.filter_clause()


            self.state = 1746
            self.match(GrammarParser.OVER_)
            self.state = 1749
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,256,self._ctx)
            if la_ == 1:
                self.state = 1747
                self.window_defn()
                pass

            elif la_ == 2:
                self.state = 1748
                self.window_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Common_table_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH_(self):
            return self.getToken(GrammarParser.WITH_, 0)

        def common_table_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Common_table_expressionContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Common_table_expressionContext,i)


        def RECURSIVE_(self):
            return self.getToken(GrammarParser.RECURSIVE_, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_common_table_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCommon_table_stmt" ):
                return visitor.visitCommon_table_stmt(self)
            else:
                return visitor.visitChildren(self)




    def common_table_stmt(self):

        localctx = GrammarParser.Common_table_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_common_table_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1751
            self.match(GrammarParser.WITH_)
            self.state = 1753
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
            if la_ == 1:
                self.state = 1752
                self.match(GrammarParser.RECURSIVE_)


            self.state = 1755
            self.common_table_expression()
            self.state = 1760
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1756
                self.match(GrammarParser.COMMA)
                self.state = 1757
                self.common_table_expression()
                self.state = 1762
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_(self):
            return self.getToken(GrammarParser.ORDER_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def ordering_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Ordering_termContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Ordering_termContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_order_by_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrder_by_stmt" ):
                return visitor.visitOrder_by_stmt(self)
            else:
                return visitor.visitChildren(self)




    def order_by_stmt(self):

        localctx = GrammarParser.Order_by_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_order_by_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1763
            self.match(GrammarParser.ORDER_)
            self.state = 1764
            self.match(GrammarParser.BY_)
            self.state = 1765
            self.ordering_term()
            self.state = 1770
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1766
                self.match(GrammarParser.COMMA)
                self.state = 1767
                self.ordering_term()
                self.state = 1772
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Limit_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LIMIT_(self):
            return self.getToken(GrammarParser.LIMIT_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def OFFSET_(self):
            return self.getToken(GrammarParser.OFFSET_, 0)

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_limit_stmt

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitLimit_stmt" ):
                return visitor.visitLimit_stmt(self)
            else:
                return visitor.visitChildren(self)




    def limit_stmt(self):

        localctx = GrammarParser.Limit_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_limit_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1773
            self.match(GrammarParser.LIMIT_)
            self.state = 1774
            self.expr(0)
            self.state = 1777
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.COMMA or _la==GrammarParser.OFFSET_:
                self.state = 1775
                _la = self._input.LA(1)
                if not(_la==GrammarParser.COMMA or _la==GrammarParser.OFFSET_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1776
                self.expr(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ordering_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def COLLATE_(self):
            return self.getToken(GrammarParser.COLLATE_, 0)

        def collation_name(self):
            return self.getTypedRuleContext(GrammarParser.Collation_nameContext,0)


        def asc_desc(self):
            return self.getTypedRuleContext(GrammarParser.Asc_descContext,0)


        def NULLS_(self):
            return self.getToken(GrammarParser.NULLS_, 0)

        def FIRST_(self):
            return self.getToken(GrammarParser.FIRST_, 0)

        def LAST_(self):
            return self.getToken(GrammarParser.LAST_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_ordering_term

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrdering_term" ):
                return visitor.visitOrdering_term(self)
            else:
                return visitor.visitChildren(self)




    def ordering_term(self):

        localctx = GrammarParser.Ordering_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_ordering_term)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1779
            self.expr(0)
            self.state = 1782
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.COLLATE_:
                self.state = 1780
                self.match(GrammarParser.COLLATE_)
                self.state = 1781
                self.collation_name()


            self.state = 1785
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ASC_ or _la==GrammarParser.DESC_:
                self.state = 1784
                self.asc_desc()


            self.state = 1789
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.NULLS_:
                self.state = 1787
                self.match(GrammarParser.NULLS_)
                self.state = 1788
                _la = self._input.LA(1)
                if not(_la==GrammarParser.FIRST_ or _la==GrammarParser.LAST_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Asc_descContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASC_(self):
            return self.getToken(GrammarParser.ASC_, 0)

        def DESC_(self):
            return self.getToken(GrammarParser.DESC_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_asc_desc

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAsc_desc" ):
                return visitor.visitAsc_desc(self)
            else:
                return visitor.visitChildren(self)




    def asc_desc(self):

        localctx = GrammarParser.Asc_descContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_asc_desc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1791
            _la = self._input.LA(1)
            if not(_la==GrammarParser.ASC_ or _la==GrammarParser.DESC_):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_leftContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def PRECEDING_(self):
            return self.getToken(GrammarParser.PRECEDING_, 0)

        def FOLLOWING_(self):
            return self.getToken(GrammarParser.FOLLOWING_, 0)

        def CURRENT_(self):
            return self.getToken(GrammarParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(GrammarParser.ROW_, 0)

        def UNBOUNDED_(self):
            return self.getToken(GrammarParser.UNBOUNDED_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_frame_left

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrame_left" ):
                return visitor.visitFrame_left(self)
            else:
                return visitor.visitChildren(self)




    def frame_left(self):

        localctx = GrammarParser.Frame_leftContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_frame_left)
        try:
            self.state = 1803
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,264,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1793
                self.expr(0)
                self.state = 1794
                self.match(GrammarParser.PRECEDING_)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1796
                self.expr(0)
                self.state = 1797
                self.match(GrammarParser.FOLLOWING_)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1799
                self.match(GrammarParser.CURRENT_)
                self.state = 1800
                self.match(GrammarParser.ROW_)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1801
                self.match(GrammarParser.UNBOUNDED_)
                self.state = 1802
                self.match(GrammarParser.PRECEDING_)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_rightContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def PRECEDING_(self):
            return self.getToken(GrammarParser.PRECEDING_, 0)

        def FOLLOWING_(self):
            return self.getToken(GrammarParser.FOLLOWING_, 0)

        def CURRENT_(self):
            return self.getToken(GrammarParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(GrammarParser.ROW_, 0)

        def UNBOUNDED_(self):
            return self.getToken(GrammarParser.UNBOUNDED_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_frame_right

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrame_right" ):
                return visitor.visitFrame_right(self)
            else:
                return visitor.visitChildren(self)




    def frame_right(self):

        localctx = GrammarParser.Frame_rightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_frame_right)
        try:
            self.state = 1815
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,265,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1805
                self.expr(0)
                self.state = 1806
                self.match(GrammarParser.PRECEDING_)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1808
                self.expr(0)
                self.state = 1809
                self.match(GrammarParser.FOLLOWING_)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1811
                self.match(GrammarParser.CURRENT_)
                self.state = 1812
                self.match(GrammarParser.ROW_)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1813
                self.match(GrammarParser.UNBOUNDED_)
                self.state = 1814
                self.match(GrammarParser.FOLLOWING_)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_singleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def PRECEDING_(self):
            return self.getToken(GrammarParser.PRECEDING_, 0)

        def UNBOUNDED_(self):
            return self.getToken(GrammarParser.UNBOUNDED_, 0)

        def CURRENT_(self):
            return self.getToken(GrammarParser.CURRENT_, 0)

        def ROW_(self):
            return self.getToken(GrammarParser.ROW_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_frame_single

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFrame_single" ):
                return visitor.visitFrame_single(self)
            else:
                return visitor.visitChildren(self)




    def frame_single(self):

        localctx = GrammarParser.Frame_singleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_frame_single)
        try:
            self.state = 1824
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,266,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1817
                self.expr(0)
                self.state = 1818
                self.match(GrammarParser.PRECEDING_)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1820
                self.match(GrammarParser.UNBOUNDED_)
                self.state = 1821
                self.match(GrammarParser.PRECEDING_)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1822
                self.match(GrammarParser.CURRENT_)
                self.state = 1823
                self.match(GrammarParser.ROW_)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.OPEN_PAR)
            else:
                return self.getToken(GrammarParser.OPEN_PAR, i)

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def CLOSE_PAR(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.CLOSE_PAR)
            else:
                return self.getToken(GrammarParser.CLOSE_PAR, i)

        def OVER_(self):
            return self.getToken(GrammarParser.OVER_, 0)

        def order_by_expr_asc_desc(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_expr_asc_descContext,0)


        def FIRST_VALUE_(self):
            return self.getToken(GrammarParser.FIRST_VALUE_, 0)

        def LAST_VALUE_(self):
            return self.getToken(GrammarParser.LAST_VALUE_, 0)

        def partition_by(self):
            return self.getTypedRuleContext(GrammarParser.Partition_byContext,0)


        def frame_clause(self):
            return self.getTypedRuleContext(GrammarParser.Frame_clauseContext,0)


        def CUME_DIST_(self):
            return self.getToken(GrammarParser.CUME_DIST_, 0)

        def PERCENT_RANK_(self):
            return self.getToken(GrammarParser.PERCENT_RANK_, 0)

        def order_by_expr(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_exprContext,0)


        def DENSE_RANK_(self):
            return self.getToken(GrammarParser.DENSE_RANK_, 0)

        def RANK_(self):
            return self.getToken(GrammarParser.RANK_, 0)

        def ROW_NUMBER_(self):
            return self.getToken(GrammarParser.ROW_NUMBER_, 0)

        def LAG_(self):
            return self.getToken(GrammarParser.LAG_, 0)

        def LEAD_(self):
            return self.getToken(GrammarParser.LEAD_, 0)

        def of_OF_fset(self):
            return self.getTypedRuleContext(GrammarParser.Of_OF_fsetContext,0)


        def default_DEFAULT__value(self):
            return self.getTypedRuleContext(GrammarParser.Default_DEFAULT__valueContext,0)


        def NTH_VALUE_(self):
            return self.getToken(GrammarParser.NTH_VALUE_, 0)

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def signed_number(self):
            return self.getTypedRuleContext(GrammarParser.Signed_numberContext,0)


        def NTILE_(self):
            return self.getToken(GrammarParser.NTILE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_window_function

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindow_function" ):
                return visitor.visitWindow_function(self)
            else:
                return visitor.visitChildren(self)




    def window_function(self):

        localctx = GrammarParser.Window_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_window_function)
        self._la = 0 # Token type
        try:
            self.state = 1911
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.FIRST_VALUE_, GrammarParser.LAST_VALUE_]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1826
                _la = self._input.LA(1)
                if not(_la==GrammarParser.FIRST_VALUE_ or _la==GrammarParser.LAST_VALUE_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1827
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1828
                self.expr(0)
                self.state = 1829
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1830
                self.match(GrammarParser.OVER_)
                self.state = 1831
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1833
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1832
                    self.partition_by()


                self.state = 1835
                self.order_by_expr_asc_desc()
                self.state = 1837
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (GrammarParser.ROWS_ - 127)) | (1 << (GrammarParser.RANGE_ - 127)) | (1 << (GrammarParser.GROUPS_ - 127)))) != 0):
                    self.state = 1836
                    self.frame_clause()


                self.state = 1839
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.CUME_DIST_, GrammarParser.PERCENT_RANK_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1841
                _la = self._input.LA(1)
                if not(_la==GrammarParser.CUME_DIST_ or _la==GrammarParser.PERCENT_RANK_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1842
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1843
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1844
                self.match(GrammarParser.OVER_)
                self.state = 1845
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1847
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1846
                    self.partition_by()


                self.state = 1850
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ORDER_:
                    self.state = 1849
                    self.order_by_expr()


                self.state = 1852
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.DENSE_RANK_, GrammarParser.RANK_, GrammarParser.ROW_NUMBER_]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1853
                _la = self._input.LA(1)
                if not(((((_la - 159)) & ~0x3f) == 0 and ((1 << (_la - 159)) & ((1 << (GrammarParser.DENSE_RANK_ - 159)) | (1 << (GrammarParser.RANK_ - 159)) | (1 << (GrammarParser.ROW_NUMBER_ - 159)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1854
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1855
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1856
                self.match(GrammarParser.OVER_)
                self.state = 1857
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1859
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1858
                    self.partition_by()


                self.state = 1861
                self.order_by_expr_asc_desc()
                self.state = 1862
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.LAG_, GrammarParser.LEAD_]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1864
                _la = self._input.LA(1)
                if not(_la==GrammarParser.LAG_ or _la==GrammarParser.LEAD_):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1865
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1866
                self.expr(0)
                self.state = 1868
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,272,self._ctx)
                if la_ == 1:
                    self.state = 1867
                    self.of_OF_fset()


                self.state = 1871
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.COMMA:
                    self.state = 1870
                    self.default_DEFAULT__value()


                self.state = 1873
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1874
                self.match(GrammarParser.OVER_)
                self.state = 1875
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1877
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1876
                    self.partition_by()


                self.state = 1879
                self.order_by_expr_asc_desc()
                self.state = 1880
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.NTH_VALUE_]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1882
                self.match(GrammarParser.NTH_VALUE_)
                self.state = 1883
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1884
                self.expr(0)
                self.state = 1885
                self.match(GrammarParser.COMMA)
                self.state = 1886
                self.signed_number()
                self.state = 1887
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1888
                self.match(GrammarParser.OVER_)
                self.state = 1889
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1891
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1890
                    self.partition_by()


                self.state = 1893
                self.order_by_expr_asc_desc()
                self.state = 1895
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 127)) & ~0x3f) == 0 and ((1 << (_la - 127)) & ((1 << (GrammarParser.ROWS_ - 127)) | (1 << (GrammarParser.RANGE_ - 127)) | (1 << (GrammarParser.GROUPS_ - 127)))) != 0):
                    self.state = 1894
                    self.frame_clause()


                self.state = 1897
                self.match(GrammarParser.CLOSE_PAR)
                pass
            elif token in [GrammarParser.NTILE_]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1899
                self.match(GrammarParser.NTILE_)
                self.state = 1900
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1901
                self.expr(0)
                self.state = 1902
                self.match(GrammarParser.CLOSE_PAR)
                self.state = 1903
                self.match(GrammarParser.OVER_)
                self.state = 1904
                self.match(GrammarParser.OPEN_PAR)
                self.state = 1906
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.PARTITION_:
                    self.state = 1905
                    self.partition_by()


                self.state = 1908
                self.order_by_expr_asc_desc()
                self.state = 1909
                self.match(GrammarParser.CLOSE_PAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Of_OF_fsetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def signed_number(self):
            return self.getTypedRuleContext(GrammarParser.Signed_numberContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_of_OF_fset

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOf_OF_fset" ):
                return visitor.visitOf_OF_fset(self)
            else:
                return visitor.visitChildren(self)




    def of_OF_fset(self):

        localctx = GrammarParser.Of_OF_fsetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_of_OF_fset)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1913
            self.match(GrammarParser.COMMA)
            self.state = 1914
            self.signed_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Default_DEFAULT__valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMA(self):
            return self.getToken(GrammarParser.COMMA, 0)

        def signed_number(self):
            return self.getTypedRuleContext(GrammarParser.Signed_numberContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_default_DEFAULT__value

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDefault_DEFAULT__value" ):
                return visitor.visitDefault_DEFAULT__value(self)
            else:
                return visitor.visitChildren(self)




    def default_DEFAULT__value(self):

        localctx = GrammarParser.Default_DEFAULT__valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_default_DEFAULT__value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1916
            self.match(GrammarParser.COMMA)
            self.state = 1917
            self.signed_number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_byContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION_(self):
            return self.getToken(GrammarParser.PARTITION_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def getRuleIndex(self):
            return GrammarParser.RULE_partition_by

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPartition_by" ):
                return visitor.visitPartition_by(self)
            else:
                return visitor.visitChildren(self)




    def partition_by(self):

        localctx = GrammarParser.Partition_byContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_partition_by)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1919
            self.match(GrammarParser.PARTITION_)
            self.state = 1920
            self.match(GrammarParser.BY_)
            self.state = 1922 
            self._errHandler.sync(self)
            _alt = 1
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 1921
                    self.expr(0)

                else:
                    raise NoViableAltException(self)
                self.state = 1924 
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,279,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_exprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_(self):
            return self.getToken(GrammarParser.ORDER_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def getRuleIndex(self):
            return GrammarParser.RULE_order_by_expr

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrder_by_expr" ):
                return visitor.visitOrder_by_expr(self)
            else:
                return visitor.visitChildren(self)




    def order_by_expr(self):

        localctx = GrammarParser.Order_by_exprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_order_by_expr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1926
            self.match(GrammarParser.ORDER_)
            self.state = 1927
            self.match(GrammarParser.BY_)
            self.state = 1929 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 1928
                self.expr(0)
                self.state = 1931 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.OPEN_PAR) | (1 << GrammarParser.PLUS) | (1 << GrammarParser.MINUS) | (1 << GrammarParser.TILDE) | (1 << GrammarParser.ABORT_) | (1 << GrammarParser.ACTION_) | (1 << GrammarParser.ADD_) | (1 << GrammarParser.AFTER_) | (1 << GrammarParser.ALL_) | (1 << GrammarParser.ALTER_) | (1 << GrammarParser.ANALYZE_) | (1 << GrammarParser.AND_) | (1 << GrammarParser.AS_) | (1 << GrammarParser.ASC_) | (1 << GrammarParser.ATTACH_) | (1 << GrammarParser.AUTOINCREMENT_) | (1 << GrammarParser.BEFORE_) | (1 << GrammarParser.BEGIN_) | (1 << GrammarParser.BETWEEN_) | (1 << GrammarParser.BY_) | (1 << GrammarParser.CASCADE_) | (1 << GrammarParser.CASE_) | (1 << GrammarParser.CAST_) | (1 << GrammarParser.CHECK_) | (1 << GrammarParser.COLLATE_) | (1 << GrammarParser.COLUMN_) | (1 << GrammarParser.COMMIT_) | (1 << GrammarParser.CONFLICT_) | (1 << GrammarParser.CONSTRAINT_) | (1 << GrammarParser.CREATE_) | (1 << GrammarParser.CROSS_) | (1 << GrammarParser.CURRENT_DATE_) | (1 << GrammarParser.CURRENT_TIME_) | (1 << GrammarParser.CURRENT_TIMESTAMP_) | (1 << GrammarParser.DATABASE_) | (1 << GrammarParser.DEFAULT_) | (1 << GrammarParser.DEFERRABLE_) | (1 << GrammarParser.DEFERRED_) | (1 << GrammarParser.DELETE_) | (1 << GrammarParser.DESC_) | (1 << GrammarParser.DETACH_) | (1 << GrammarParser.DISTINCT_) | (1 << GrammarParser.DROP_))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GrammarParser.EACH_ - 64)) | (1 << (GrammarParser.ELSE_ - 64)) | (1 << (GrammarParser.END_ - 64)) | (1 << (GrammarParser.ESCAPE_ - 64)) | (1 << (GrammarParser.EXCEPT_ - 64)) | (1 << (GrammarParser.EXCLUSIVE_ - 64)) | (1 << (GrammarParser.EXISTS_ - 64)) | (1 << (GrammarParser.EXPLAIN_ - 64)) | (1 << (GrammarParser.FAIL_ - 64)) | (1 << (GrammarParser.FOR_ - 64)) | (1 << (GrammarParser.FOREIGN_ - 64)) | (1 << (GrammarParser.FROM_ - 64)) | (1 << (GrammarParser.FULL_ - 64)) | (1 << (GrammarParser.GLOB_ - 64)) | (1 << (GrammarParser.GROUP_ - 64)) | (1 << (GrammarParser.HAVING_ - 64)) | (1 << (GrammarParser.IF_ - 64)) | (1 << (GrammarParser.IGNORE_ - 64)) | (1 << (GrammarParser.IMMEDIATE_ - 64)) | (1 << (GrammarParser.IN_ - 64)) | (1 << (GrammarParser.INDEX_ - 64)) | (1 << (GrammarParser.INDEXED_ - 64)) | (1 << (GrammarParser.INITIALLY_ - 64)) | (1 << (GrammarParser.INNER_ - 64)) | (1 << (GrammarParser.INSERT_ - 64)) | (1 << (GrammarParser.INSTEAD_ - 64)) | (1 << (GrammarParser.INTERSECT_ - 64)) | (1 << (GrammarParser.INTO_ - 64)) | (1 << (GrammarParser.IS_ - 64)) | (1 << (GrammarParser.ISNULL_ - 64)) | (1 << (GrammarParser.JOIN_ - 64)) | (1 << (GrammarParser.KEY_ - 64)) | (1 << (GrammarParser.LEFT_ - 64)) | (1 << (GrammarParser.LIKE_ - 64)) | (1 << (GrammarParser.LIMIT_ - 64)) | (1 << (GrammarParser.MATCH_ - 64)) | (1 << (GrammarParser.NATURAL_ - 64)) | (1 << (GrammarParser.NO_ - 64)) | (1 << (GrammarParser.NOT_ - 64)) | (1 << (GrammarParser.NOTNULL_ - 64)) | (1 << (GrammarParser.NULL_ - 64)) | (1 << (GrammarParser.OF_ - 64)) | (1 << (GrammarParser.OFFSET_ - 64)) | (1 << (GrammarParser.ON_ - 64)) | (1 << (GrammarParser.OR_ - 64)) | (1 << (GrammarParser.ORDER_ - 64)) | (1 << (GrammarParser.OUTER_ - 64)) | (1 << (GrammarParser.PLAN_ - 64)) | (1 << (GrammarParser.PRAGMA_ - 64)) | (1 << (GrammarParser.PRIMARY_ - 64)) | (1 << (GrammarParser.QUERY_ - 64)) | (1 << (GrammarParser.RAISE_ - 64)) | (1 << (GrammarParser.RECURSIVE_ - 64)) | (1 << (GrammarParser.REFERENCES_ - 64)) | (1 << (GrammarParser.REGEXP_ - 64)) | (1 << (GrammarParser.REINDEX_ - 64)) | (1 << (GrammarParser.RELEASE_ - 64)) | (1 << (GrammarParser.RENAME_ - 64)) | (1 << (GrammarParser.REPLACE_ - 64)) | (1 << (GrammarParser.RESTRICT_ - 64)) | (1 << (GrammarParser.RIGHT_ - 64)) | (1 << (GrammarParser.ROLLBACK_ - 64)) | (1 << (GrammarParser.ROW_ - 64)) | (1 << (GrammarParser.ROWS_ - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (GrammarParser.SAVEPOINT_ - 128)) | (1 << (GrammarParser.SELECT_ - 128)) | (1 << (GrammarParser.SET_ - 128)) | (1 << (GrammarParser.TABLE_ - 128)) | (1 << (GrammarParser.TEMP_ - 128)) | (1 << (GrammarParser.TEMPORARY_ - 128)) | (1 << (GrammarParser.THEN_ - 128)) | (1 << (GrammarParser.TO_ - 128)) | (1 << (GrammarParser.TRANSACTION_ - 128)) | (1 << (GrammarParser.TRIGGER_ - 128)) | (1 << (GrammarParser.UNION_ - 128)) | (1 << (GrammarParser.UNIQUE_ - 128)) | (1 << (GrammarParser.UPDATE_ - 128)) | (1 << (GrammarParser.USING_ - 128)) | (1 << (GrammarParser.VACUUM_ - 128)) | (1 << (GrammarParser.VALUES_ - 128)) | (1 << (GrammarParser.VIEW_ - 128)) | (1 << (GrammarParser.VIRTUAL_ - 128)) | (1 << (GrammarParser.WHEN_ - 128)) | (1 << (GrammarParser.WHERE_ - 128)) | (1 << (GrammarParser.WITH_ - 128)) | (1 << (GrammarParser.WITHOUT_ - 128)) | (1 << (GrammarParser.FIRST_VALUE_ - 128)) | (1 << (GrammarParser.OVER_ - 128)) | (1 << (GrammarParser.PARTITION_ - 128)) | (1 << (GrammarParser.RANGE_ - 128)) | (1 << (GrammarParser.PRECEDING_ - 128)) | (1 << (GrammarParser.UNBOUNDED_ - 128)) | (1 << (GrammarParser.CURRENT_ - 128)) | (1 << (GrammarParser.FOLLOWING_ - 128)) | (1 << (GrammarParser.CUME_DIST_ - 128)) | (1 << (GrammarParser.DENSE_RANK_ - 128)) | (1 << (GrammarParser.LAG_ - 128)) | (1 << (GrammarParser.LAST_VALUE_ - 128)) | (1 << (GrammarParser.LEAD_ - 128)) | (1 << (GrammarParser.NTH_VALUE_ - 128)) | (1 << (GrammarParser.NTILE_ - 128)) | (1 << (GrammarParser.PERCENT_RANK_ - 128)) | (1 << (GrammarParser.RANK_ - 128)) | (1 << (GrammarParser.ROW_NUMBER_ - 128)) | (1 << (GrammarParser.GENERATED_ - 128)) | (1 << (GrammarParser.ALWAYS_ - 128)) | (1 << (GrammarParser.STORED_ - 128)) | (1 << (GrammarParser.TRUE_ - 128)) | (1 << (GrammarParser.FALSE_ - 128)) | (1 << (GrammarParser.WINDOW_ - 128)) | (1 << (GrammarParser.NULLS_ - 128)) | (1 << (GrammarParser.FIRST_ - 128)) | (1 << (GrammarParser.LAST_ - 128)) | (1 << (GrammarParser.FILTER_ - 128)) | (1 << (GrammarParser.GROUPS_ - 128)) | (1 << (GrammarParser.EXCLUDE_ - 128)) | (1 << (GrammarParser.IDENTIFIER - 128)) | (1 << (GrammarParser.NUMERIC_LITERAL - 128)) | (1 << (GrammarParser.BIND_PARAMETER - 128)) | (1 << (GrammarParser.STRING_LITERAL - 128)) | (1 << (GrammarParser.BLOB_LITERAL - 128)))) != 0)):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_by_expr_asc_descContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER_(self):
            return self.getToken(GrammarParser.ORDER_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def order_by_expr_asc_desc(self):
            return self.getTypedRuleContext(GrammarParser.Order_by_expr_asc_descContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_order_by_expr_asc_desc

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOrder_by_expr_asc_desc" ):
                return visitor.visitOrder_by_expr_asc_desc(self)
            else:
                return visitor.visitChildren(self)




    def order_by_expr_asc_desc(self):

        localctx = GrammarParser.Order_by_expr_asc_descContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_order_by_expr_asc_desc)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1933
            self.match(GrammarParser.ORDER_)
            self.state = 1934
            self.match(GrammarParser.BY_)
            self.state = 1935
            self.order_by_expr_asc_desc()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Expr_asc_descContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.ExprContext)
            else:
                return self.getTypedRuleContext(GrammarParser.ExprContext,i)


        def asc_desc(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(GrammarParser.Asc_descContext)
            else:
                return self.getTypedRuleContext(GrammarParser.Asc_descContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(GrammarParser.COMMA)
            else:
                return self.getToken(GrammarParser.COMMA, i)

        def getRuleIndex(self):
            return GrammarParser.RULE_expr_asc_desc

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExpr_asc_desc" ):
                return visitor.visitExpr_asc_desc(self)
            else:
                return visitor.visitChildren(self)




    def expr_asc_desc(self):

        localctx = GrammarParser.Expr_asc_descContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_expr_asc_desc)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1937
            self.expr(0)
            self.state = 1939
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==GrammarParser.ASC_ or _la==GrammarParser.DESC_:
                self.state = 1938
                self.asc_desc()


            self.state = 1948
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==GrammarParser.COMMA:
                self.state = 1941
                self.match(GrammarParser.COMMA)
                self.state = 1942
                self.expr(0)
                self.state = 1944
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==GrammarParser.ASC_ or _la==GrammarParser.DESC_:
                    self.state = 1943
                    self.asc_desc()


                self.state = 1950
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Initial_selectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_initial_select

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInitial_select" ):
                return visitor.visitInitial_select(self)
            else:
                return visitor.visitChildren(self)




    def initial_select(self):

        localctx = GrammarParser.Initial_selectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_initial_select)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1951
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Recursive__selectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(GrammarParser.Select_stmtContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_recursive__select

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRecursive__select" ):
                return visitor.visitRecursive__select(self)
            else:
                return visitor.visitChildren(self)




    def recursive__select(self):

        localctx = GrammarParser.Recursive__selectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_recursive__select)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1953
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unary_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MINUS(self):
            return self.getToken(GrammarParser.MINUS, 0)

        def PLUS(self):
            return self.getToken(GrammarParser.PLUS, 0)

        def TILDE(self):
            return self.getToken(GrammarParser.TILDE, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_unary_operator

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUnary_operator" ):
                return visitor.visitUnary_operator(self)
            else:
                return visitor.visitChildren(self)




    def unary_operator(self):

        localctx = GrammarParser.Unary_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_unary_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1955
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.PLUS) | (1 << GrammarParser.MINUS) | (1 << GrammarParser.TILDE))) != 0) or _la==GrammarParser.NOT_):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Error_messageContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def STRING_LITERAL(self):
            return self.getToken(GrammarParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_error_message

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitError_message" ):
                return visitor.visitError_message(self)
            else:
                return visitor.visitChildren(self)




    def error_message(self):

        localctx = GrammarParser.Error_messageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_error_message)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1957
            self.match(GrammarParser.STRING_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_argumentContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def expr(self):
            return self.getTypedRuleContext(GrammarParser.ExprContext,0)


        def column_def(self):
            return self.getTypedRuleContext(GrammarParser.Column_defContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_module_argument

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_argument" ):
                return visitor.visitModule_argument(self)
            else:
                return visitor.visitChildren(self)




    def module_argument(self):

        localctx = GrammarParser.Module_argumentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_module_argument)
        try:
            self.state = 1961
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,284,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1959
                self.expr(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1960
                self.column_def()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_aliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(GrammarParser.IDENTIFIER, 0)

        def STRING_LITERAL(self):
            return self.getToken(GrammarParser.STRING_LITERAL, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_column_alias

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_alias" ):
                return visitor.visitColumn_alias(self)
            else:
                return visitor.visitChildren(self)




    def column_alias(self):

        localctx = GrammarParser.Column_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_column_alias)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1963
            _la = self._input.LA(1)
            if not(_la==GrammarParser.IDENTIFIER or _la==GrammarParser.STRING_LITERAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class KeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABORT_(self):
            return self.getToken(GrammarParser.ABORT_, 0)

        def ACTION_(self):
            return self.getToken(GrammarParser.ACTION_, 0)

        def ADD_(self):
            return self.getToken(GrammarParser.ADD_, 0)

        def AFTER_(self):
            return self.getToken(GrammarParser.AFTER_, 0)

        def ALL_(self):
            return self.getToken(GrammarParser.ALL_, 0)

        def ALTER_(self):
            return self.getToken(GrammarParser.ALTER_, 0)

        def ANALYZE_(self):
            return self.getToken(GrammarParser.ANALYZE_, 0)

        def AND_(self):
            return self.getToken(GrammarParser.AND_, 0)

        def AS_(self):
            return self.getToken(GrammarParser.AS_, 0)

        def ASC_(self):
            return self.getToken(GrammarParser.ASC_, 0)

        def ATTACH_(self):
            return self.getToken(GrammarParser.ATTACH_, 0)

        def AUTOINCREMENT_(self):
            return self.getToken(GrammarParser.AUTOINCREMENT_, 0)

        def BEFORE_(self):
            return self.getToken(GrammarParser.BEFORE_, 0)

        def BEGIN_(self):
            return self.getToken(GrammarParser.BEGIN_, 0)

        def BETWEEN_(self):
            return self.getToken(GrammarParser.BETWEEN_, 0)

        def BY_(self):
            return self.getToken(GrammarParser.BY_, 0)

        def CASCADE_(self):
            return self.getToken(GrammarParser.CASCADE_, 0)

        def CASE_(self):
            return self.getToken(GrammarParser.CASE_, 0)

        def CAST_(self):
            return self.getToken(GrammarParser.CAST_, 0)

        def CHECK_(self):
            return self.getToken(GrammarParser.CHECK_, 0)

        def COLLATE_(self):
            return self.getToken(GrammarParser.COLLATE_, 0)

        def COLUMN_(self):
            return self.getToken(GrammarParser.COLUMN_, 0)

        def COMMIT_(self):
            return self.getToken(GrammarParser.COMMIT_, 0)

        def CONFLICT_(self):
            return self.getToken(GrammarParser.CONFLICT_, 0)

        def CONSTRAINT_(self):
            return self.getToken(GrammarParser.CONSTRAINT_, 0)

        def CREATE_(self):
            return self.getToken(GrammarParser.CREATE_, 0)

        def CROSS_(self):
            return self.getToken(GrammarParser.CROSS_, 0)

        def CURRENT_DATE_(self):
            return self.getToken(GrammarParser.CURRENT_DATE_, 0)

        def CURRENT_TIME_(self):
            return self.getToken(GrammarParser.CURRENT_TIME_, 0)

        def CURRENT_TIMESTAMP_(self):
            return self.getToken(GrammarParser.CURRENT_TIMESTAMP_, 0)

        def DATABASE_(self):
            return self.getToken(GrammarParser.DATABASE_, 0)

        def DEFAULT_(self):
            return self.getToken(GrammarParser.DEFAULT_, 0)

        def DEFERRABLE_(self):
            return self.getToken(GrammarParser.DEFERRABLE_, 0)

        def DEFERRED_(self):
            return self.getToken(GrammarParser.DEFERRED_, 0)

        def DELETE_(self):
            return self.getToken(GrammarParser.DELETE_, 0)

        def DESC_(self):
            return self.getToken(GrammarParser.DESC_, 0)

        def DETACH_(self):
            return self.getToken(GrammarParser.DETACH_, 0)

        def DISTINCT_(self):
            return self.getToken(GrammarParser.DISTINCT_, 0)

        def DROP_(self):
            return self.getToken(GrammarParser.DROP_, 0)

        def EACH_(self):
            return self.getToken(GrammarParser.EACH_, 0)

        def ELSE_(self):
            return self.getToken(GrammarParser.ELSE_, 0)

        def END_(self):
            return self.getToken(GrammarParser.END_, 0)

        def ESCAPE_(self):
            return self.getToken(GrammarParser.ESCAPE_, 0)

        def EXCEPT_(self):
            return self.getToken(GrammarParser.EXCEPT_, 0)

        def EXCLUSIVE_(self):
            return self.getToken(GrammarParser.EXCLUSIVE_, 0)

        def EXISTS_(self):
            return self.getToken(GrammarParser.EXISTS_, 0)

        def EXPLAIN_(self):
            return self.getToken(GrammarParser.EXPLAIN_, 0)

        def FAIL_(self):
            return self.getToken(GrammarParser.FAIL_, 0)

        def FOR_(self):
            return self.getToken(GrammarParser.FOR_, 0)

        def FOREIGN_(self):
            return self.getToken(GrammarParser.FOREIGN_, 0)

        def FROM_(self):
            return self.getToken(GrammarParser.FROM_, 0)

        def FULL_(self):
            return self.getToken(GrammarParser.FULL_, 0)

        def GLOB_(self):
            return self.getToken(GrammarParser.GLOB_, 0)

        def GROUP_(self):
            return self.getToken(GrammarParser.GROUP_, 0)

        def HAVING_(self):
            return self.getToken(GrammarParser.HAVING_, 0)

        def IF_(self):
            return self.getToken(GrammarParser.IF_, 0)

        def IGNORE_(self):
            return self.getToken(GrammarParser.IGNORE_, 0)

        def IMMEDIATE_(self):
            return self.getToken(GrammarParser.IMMEDIATE_, 0)

        def IN_(self):
            return self.getToken(GrammarParser.IN_, 0)

        def INDEX_(self):
            return self.getToken(GrammarParser.INDEX_, 0)

        def INDEXED_(self):
            return self.getToken(GrammarParser.INDEXED_, 0)

        def INITIALLY_(self):
            return self.getToken(GrammarParser.INITIALLY_, 0)

        def INNER_(self):
            return self.getToken(GrammarParser.INNER_, 0)

        def INSERT_(self):
            return self.getToken(GrammarParser.INSERT_, 0)

        def INSTEAD_(self):
            return self.getToken(GrammarParser.INSTEAD_, 0)

        def INTERSECT_(self):
            return self.getToken(GrammarParser.INTERSECT_, 0)

        def INTO_(self):
            return self.getToken(GrammarParser.INTO_, 0)

        def IS_(self):
            return self.getToken(GrammarParser.IS_, 0)

        def ISNULL_(self):
            return self.getToken(GrammarParser.ISNULL_, 0)

        def JOIN_(self):
            return self.getToken(GrammarParser.JOIN_, 0)

        def KEY_(self):
            return self.getToken(GrammarParser.KEY_, 0)

        def LEFT_(self):
            return self.getToken(GrammarParser.LEFT_, 0)

        def LIKE_(self):
            return self.getToken(GrammarParser.LIKE_, 0)

        def LIMIT_(self):
            return self.getToken(GrammarParser.LIMIT_, 0)

        def MATCH_(self):
            return self.getToken(GrammarParser.MATCH_, 0)

        def NATURAL_(self):
            return self.getToken(GrammarParser.NATURAL_, 0)

        def NO_(self):
            return self.getToken(GrammarParser.NO_, 0)

        def NOT_(self):
            return self.getToken(GrammarParser.NOT_, 0)

        def NOTNULL_(self):
            return self.getToken(GrammarParser.NOTNULL_, 0)

        def NULL_(self):
            return self.getToken(GrammarParser.NULL_, 0)

        def OF_(self):
            return self.getToken(GrammarParser.OF_, 0)

        def OFFSET_(self):
            return self.getToken(GrammarParser.OFFSET_, 0)

        def ON_(self):
            return self.getToken(GrammarParser.ON_, 0)

        def OR_(self):
            return self.getToken(GrammarParser.OR_, 0)

        def ORDER_(self):
            return self.getToken(GrammarParser.ORDER_, 0)

        def OUTER_(self):
            return self.getToken(GrammarParser.OUTER_, 0)

        def PLAN_(self):
            return self.getToken(GrammarParser.PLAN_, 0)

        def PRAGMA_(self):
            return self.getToken(GrammarParser.PRAGMA_, 0)

        def PRIMARY_(self):
            return self.getToken(GrammarParser.PRIMARY_, 0)

        def QUERY_(self):
            return self.getToken(GrammarParser.QUERY_, 0)

        def RAISE_(self):
            return self.getToken(GrammarParser.RAISE_, 0)

        def RECURSIVE_(self):
            return self.getToken(GrammarParser.RECURSIVE_, 0)

        def REFERENCES_(self):
            return self.getToken(GrammarParser.REFERENCES_, 0)

        def REGEXP_(self):
            return self.getToken(GrammarParser.REGEXP_, 0)

        def REINDEX_(self):
            return self.getToken(GrammarParser.REINDEX_, 0)

        def RELEASE_(self):
            return self.getToken(GrammarParser.RELEASE_, 0)

        def RENAME_(self):
            return self.getToken(GrammarParser.RENAME_, 0)

        def REPLACE_(self):
            return self.getToken(GrammarParser.REPLACE_, 0)

        def RESTRICT_(self):
            return self.getToken(GrammarParser.RESTRICT_, 0)

        def RIGHT_(self):
            return self.getToken(GrammarParser.RIGHT_, 0)

        def ROLLBACK_(self):
            return self.getToken(GrammarParser.ROLLBACK_, 0)

        def ROW_(self):
            return self.getToken(GrammarParser.ROW_, 0)

        def ROWS_(self):
            return self.getToken(GrammarParser.ROWS_, 0)

        def SAVEPOINT_(self):
            return self.getToken(GrammarParser.SAVEPOINT_, 0)

        def SELECT_(self):
            return self.getToken(GrammarParser.SELECT_, 0)

        def SET_(self):
            return self.getToken(GrammarParser.SET_, 0)

        def TABLE_(self):
            return self.getToken(GrammarParser.TABLE_, 0)

        def TEMP_(self):
            return self.getToken(GrammarParser.TEMP_, 0)

        def TEMPORARY_(self):
            return self.getToken(GrammarParser.TEMPORARY_, 0)

        def THEN_(self):
            return self.getToken(GrammarParser.THEN_, 0)

        def TO_(self):
            return self.getToken(GrammarParser.TO_, 0)

        def TRANSACTION_(self):
            return self.getToken(GrammarParser.TRANSACTION_, 0)

        def TRIGGER_(self):
            return self.getToken(GrammarParser.TRIGGER_, 0)

        def UNION_(self):
            return self.getToken(GrammarParser.UNION_, 0)

        def UNIQUE_(self):
            return self.getToken(GrammarParser.UNIQUE_, 0)

        def UPDATE_(self):
            return self.getToken(GrammarParser.UPDATE_, 0)

        def USING_(self):
            return self.getToken(GrammarParser.USING_, 0)

        def VACUUM_(self):
            return self.getToken(GrammarParser.VACUUM_, 0)

        def VALUES_(self):
            return self.getToken(GrammarParser.VALUES_, 0)

        def VIEW_(self):
            return self.getToken(GrammarParser.VIEW_, 0)

        def VIRTUAL_(self):
            return self.getToken(GrammarParser.VIRTUAL_, 0)

        def WHEN_(self):
            return self.getToken(GrammarParser.WHEN_, 0)

        def WHERE_(self):
            return self.getToken(GrammarParser.WHERE_, 0)

        def WITH_(self):
            return self.getToken(GrammarParser.WITH_, 0)

        def WITHOUT_(self):
            return self.getToken(GrammarParser.WITHOUT_, 0)

        def FIRST_VALUE_(self):
            return self.getToken(GrammarParser.FIRST_VALUE_, 0)

        def OVER_(self):
            return self.getToken(GrammarParser.OVER_, 0)

        def PARTITION_(self):
            return self.getToken(GrammarParser.PARTITION_, 0)

        def RANGE_(self):
            return self.getToken(GrammarParser.RANGE_, 0)

        def PRECEDING_(self):
            return self.getToken(GrammarParser.PRECEDING_, 0)

        def UNBOUNDED_(self):
            return self.getToken(GrammarParser.UNBOUNDED_, 0)

        def CURRENT_(self):
            return self.getToken(GrammarParser.CURRENT_, 0)

        def FOLLOWING_(self):
            return self.getToken(GrammarParser.FOLLOWING_, 0)

        def CUME_DIST_(self):
            return self.getToken(GrammarParser.CUME_DIST_, 0)

        def DENSE_RANK_(self):
            return self.getToken(GrammarParser.DENSE_RANK_, 0)

        def LAG_(self):
            return self.getToken(GrammarParser.LAG_, 0)

        def LAST_VALUE_(self):
            return self.getToken(GrammarParser.LAST_VALUE_, 0)

        def LEAD_(self):
            return self.getToken(GrammarParser.LEAD_, 0)

        def NTH_VALUE_(self):
            return self.getToken(GrammarParser.NTH_VALUE_, 0)

        def NTILE_(self):
            return self.getToken(GrammarParser.NTILE_, 0)

        def PERCENT_RANK_(self):
            return self.getToken(GrammarParser.PERCENT_RANK_, 0)

        def RANK_(self):
            return self.getToken(GrammarParser.RANK_, 0)

        def ROW_NUMBER_(self):
            return self.getToken(GrammarParser.ROW_NUMBER_, 0)

        def GENERATED_(self):
            return self.getToken(GrammarParser.GENERATED_, 0)

        def ALWAYS_(self):
            return self.getToken(GrammarParser.ALWAYS_, 0)

        def STORED_(self):
            return self.getToken(GrammarParser.STORED_, 0)

        def TRUE_(self):
            return self.getToken(GrammarParser.TRUE_, 0)

        def FALSE_(self):
            return self.getToken(GrammarParser.FALSE_, 0)

        def WINDOW_(self):
            return self.getToken(GrammarParser.WINDOW_, 0)

        def NULLS_(self):
            return self.getToken(GrammarParser.NULLS_, 0)

        def FIRST_(self):
            return self.getToken(GrammarParser.FIRST_, 0)

        def LAST_(self):
            return self.getToken(GrammarParser.LAST_, 0)

        def FILTER_(self):
            return self.getToken(GrammarParser.FILTER_, 0)

        def GROUPS_(self):
            return self.getToken(GrammarParser.GROUPS_, 0)

        def EXCLUDE_(self):
            return self.getToken(GrammarParser.EXCLUDE_, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_keyword

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitKeyword" ):
                return visitor.visitKeyword(self)
            else:
                return visitor.visitChildren(self)




    def keyword(self):

        localctx = GrammarParser.KeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_keyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1965
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << GrammarParser.ABORT_) | (1 << GrammarParser.ACTION_) | (1 << GrammarParser.ADD_) | (1 << GrammarParser.AFTER_) | (1 << GrammarParser.ALL_) | (1 << GrammarParser.ALTER_) | (1 << GrammarParser.ANALYZE_) | (1 << GrammarParser.AND_) | (1 << GrammarParser.AS_) | (1 << GrammarParser.ASC_) | (1 << GrammarParser.ATTACH_) | (1 << GrammarParser.AUTOINCREMENT_) | (1 << GrammarParser.BEFORE_) | (1 << GrammarParser.BEGIN_) | (1 << GrammarParser.BETWEEN_) | (1 << GrammarParser.BY_) | (1 << GrammarParser.CASCADE_) | (1 << GrammarParser.CASE_) | (1 << GrammarParser.CAST_) | (1 << GrammarParser.CHECK_) | (1 << GrammarParser.COLLATE_) | (1 << GrammarParser.COLUMN_) | (1 << GrammarParser.COMMIT_) | (1 << GrammarParser.CONFLICT_) | (1 << GrammarParser.CONSTRAINT_) | (1 << GrammarParser.CREATE_) | (1 << GrammarParser.CROSS_) | (1 << GrammarParser.CURRENT_DATE_) | (1 << GrammarParser.CURRENT_TIME_) | (1 << GrammarParser.CURRENT_TIMESTAMP_) | (1 << GrammarParser.DATABASE_) | (1 << GrammarParser.DEFAULT_) | (1 << GrammarParser.DEFERRABLE_) | (1 << GrammarParser.DEFERRED_) | (1 << GrammarParser.DELETE_) | (1 << GrammarParser.DESC_) | (1 << GrammarParser.DETACH_) | (1 << GrammarParser.DISTINCT_) | (1 << GrammarParser.DROP_))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (GrammarParser.EACH_ - 64)) | (1 << (GrammarParser.ELSE_ - 64)) | (1 << (GrammarParser.END_ - 64)) | (1 << (GrammarParser.ESCAPE_ - 64)) | (1 << (GrammarParser.EXCEPT_ - 64)) | (1 << (GrammarParser.EXCLUSIVE_ - 64)) | (1 << (GrammarParser.EXISTS_ - 64)) | (1 << (GrammarParser.EXPLAIN_ - 64)) | (1 << (GrammarParser.FAIL_ - 64)) | (1 << (GrammarParser.FOR_ - 64)) | (1 << (GrammarParser.FOREIGN_ - 64)) | (1 << (GrammarParser.FROM_ - 64)) | (1 << (GrammarParser.FULL_ - 64)) | (1 << (GrammarParser.GLOB_ - 64)) | (1 << (GrammarParser.GROUP_ - 64)) | (1 << (GrammarParser.HAVING_ - 64)) | (1 << (GrammarParser.IF_ - 64)) | (1 << (GrammarParser.IGNORE_ - 64)) | (1 << (GrammarParser.IMMEDIATE_ - 64)) | (1 << (GrammarParser.IN_ - 64)) | (1 << (GrammarParser.INDEX_ - 64)) | (1 << (GrammarParser.INDEXED_ - 64)) | (1 << (GrammarParser.INITIALLY_ - 64)) | (1 << (GrammarParser.INNER_ - 64)) | (1 << (GrammarParser.INSERT_ - 64)) | (1 << (GrammarParser.INSTEAD_ - 64)) | (1 << (GrammarParser.INTERSECT_ - 64)) | (1 << (GrammarParser.INTO_ - 64)) | (1 << (GrammarParser.IS_ - 64)) | (1 << (GrammarParser.ISNULL_ - 64)) | (1 << (GrammarParser.JOIN_ - 64)) | (1 << (GrammarParser.KEY_ - 64)) | (1 << (GrammarParser.LEFT_ - 64)) | (1 << (GrammarParser.LIKE_ - 64)) | (1 << (GrammarParser.LIMIT_ - 64)) | (1 << (GrammarParser.MATCH_ - 64)) | (1 << (GrammarParser.NATURAL_ - 64)) | (1 << (GrammarParser.NO_ - 64)) | (1 << (GrammarParser.NOT_ - 64)) | (1 << (GrammarParser.NOTNULL_ - 64)) | (1 << (GrammarParser.NULL_ - 64)) | (1 << (GrammarParser.OF_ - 64)) | (1 << (GrammarParser.OFFSET_ - 64)) | (1 << (GrammarParser.ON_ - 64)) | (1 << (GrammarParser.OR_ - 64)) | (1 << (GrammarParser.ORDER_ - 64)) | (1 << (GrammarParser.OUTER_ - 64)) | (1 << (GrammarParser.PLAN_ - 64)) | (1 << (GrammarParser.PRAGMA_ - 64)) | (1 << (GrammarParser.PRIMARY_ - 64)) | (1 << (GrammarParser.QUERY_ - 64)) | (1 << (GrammarParser.RAISE_ - 64)) | (1 << (GrammarParser.RECURSIVE_ - 64)) | (1 << (GrammarParser.REFERENCES_ - 64)) | (1 << (GrammarParser.REGEXP_ - 64)) | (1 << (GrammarParser.REINDEX_ - 64)) | (1 << (GrammarParser.RELEASE_ - 64)) | (1 << (GrammarParser.RENAME_ - 64)) | (1 << (GrammarParser.REPLACE_ - 64)) | (1 << (GrammarParser.RESTRICT_ - 64)) | (1 << (GrammarParser.RIGHT_ - 64)) | (1 << (GrammarParser.ROLLBACK_ - 64)) | (1 << (GrammarParser.ROW_ - 64)) | (1 << (GrammarParser.ROWS_ - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (GrammarParser.SAVEPOINT_ - 128)) | (1 << (GrammarParser.SELECT_ - 128)) | (1 << (GrammarParser.SET_ - 128)) | (1 << (GrammarParser.TABLE_ - 128)) | (1 << (GrammarParser.TEMP_ - 128)) | (1 << (GrammarParser.TEMPORARY_ - 128)) | (1 << (GrammarParser.THEN_ - 128)) | (1 << (GrammarParser.TO_ - 128)) | (1 << (GrammarParser.TRANSACTION_ - 128)) | (1 << (GrammarParser.TRIGGER_ - 128)) | (1 << (GrammarParser.UNION_ - 128)) | (1 << (GrammarParser.UNIQUE_ - 128)) | (1 << (GrammarParser.UPDATE_ - 128)) | (1 << (GrammarParser.USING_ - 128)) | (1 << (GrammarParser.VACUUM_ - 128)) | (1 << (GrammarParser.VALUES_ - 128)) | (1 << (GrammarParser.VIEW_ - 128)) | (1 << (GrammarParser.VIRTUAL_ - 128)) | (1 << (GrammarParser.WHEN_ - 128)) | (1 << (GrammarParser.WHERE_ - 128)) | (1 << (GrammarParser.WITH_ - 128)) | (1 << (GrammarParser.WITHOUT_ - 128)) | (1 << (GrammarParser.FIRST_VALUE_ - 128)) | (1 << (GrammarParser.OVER_ - 128)) | (1 << (GrammarParser.PARTITION_ - 128)) | (1 << (GrammarParser.RANGE_ - 128)) | (1 << (GrammarParser.PRECEDING_ - 128)) | (1 << (GrammarParser.UNBOUNDED_ - 128)) | (1 << (GrammarParser.CURRENT_ - 128)) | (1 << (GrammarParser.FOLLOWING_ - 128)) | (1 << (GrammarParser.CUME_DIST_ - 128)) | (1 << (GrammarParser.DENSE_RANK_ - 128)) | (1 << (GrammarParser.LAG_ - 128)) | (1 << (GrammarParser.LAST_VALUE_ - 128)) | (1 << (GrammarParser.LEAD_ - 128)) | (1 << (GrammarParser.NTH_VALUE_ - 128)) | (1 << (GrammarParser.NTILE_ - 128)) | (1 << (GrammarParser.PERCENT_RANK_ - 128)) | (1 << (GrammarParser.RANK_ - 128)) | (1 << (GrammarParser.ROW_NUMBER_ - 128)) | (1 << (GrammarParser.GENERATED_ - 128)) | (1 << (GrammarParser.ALWAYS_ - 128)) | (1 << (GrammarParser.STORED_ - 128)) | (1 << (GrammarParser.TRUE_ - 128)) | (1 << (GrammarParser.FALSE_ - 128)) | (1 << (GrammarParser.WINDOW_ - 128)) | (1 << (GrammarParser.NULLS_ - 128)) | (1 << (GrammarParser.FIRST_ - 128)) | (1 << (GrammarParser.LAST_ - 128)) | (1 << (GrammarParser.FILTER_ - 128)) | (1 << (GrammarParser.GROUPS_ - 128)) | (1 << (GrammarParser.EXCLUDE_ - 128)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitName" ):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)




    def name(self):

        localctx = GrammarParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1967
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_function_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFunction_name" ):
                return visitor.visitFunction_name(self)
            else:
                return visitor.visitChildren(self)




    def function_name(self):

        localctx = GrammarParser.Function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1969
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_schema_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSchema_name" ):
                return visitor.visitSchema_name(self)
            else:
                return visitor.visitChildren(self)




    def schema_name(self):

        localctx = GrammarParser.Schema_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_schema_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1971
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_table_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_name" ):
                return visitor.visitTable_name(self)
            else:
                return visitor.visitChildren(self)




    def table_name(self):

        localctx = GrammarParser.Table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1973
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_or_index_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_table_or_index_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_or_index_name" ):
                return visitor.visitTable_or_index_name(self)
            else:
                return visitor.visitChildren(self)




    def table_or_index_name(self):

        localctx = GrammarParser.Table_or_index_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_table_or_index_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1975
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class New_table_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_new_table_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNew_table_name" ):
                return visitor.visitNew_table_name(self)
            else:
                return visitor.visitChildren(self)




    def new_table_name(self):

        localctx = GrammarParser.New_table_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_new_table_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1977
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_column_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitColumn_name" ):
                return visitor.visitColumn_name(self)
            else:
                return visitor.visitChildren(self)




    def column_name(self):

        localctx = GrammarParser.Column_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_column_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1979
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Collation_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_collation_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitCollation_name" ):
                return visitor.visitCollation_name(self)
            else:
                return visitor.visitChildren(self)




    def collation_name(self):

        localctx = GrammarParser.Collation_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_collation_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1981
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Foreign_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_foreign_table

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitForeign_table" ):
                return visitor.visitForeign_table(self)
            else:
                return visitor.visitChildren(self)




    def foreign_table(self):

        localctx = GrammarParser.Foreign_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_foreign_table)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1983
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_index_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitIndex_name" ):
                return visitor.visitIndex_name(self)
            else:
                return visitor.visitChildren(self)




    def index_name(self):

        localctx = GrammarParser.Index_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_index_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1985
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trigger_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_trigger_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrigger_name" ):
                return visitor.visitTrigger_name(self)
            else:
                return visitor.visitChildren(self)




    def trigger_name(self):

        localctx = GrammarParser.Trigger_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_trigger_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1987
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_view_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitView_name" ):
                return visitor.visitView_name(self)
            else:
                return visitor.visitChildren(self)




    def view_name(self):

        localctx = GrammarParser.View_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_view_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1989
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Module_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_module_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitModule_name" ):
                return visitor.visitModule_name(self)
            else:
                return visitor.visitChildren(self)




    def module_name(self):

        localctx = GrammarParser.Module_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_module_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1991
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Pragma_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_pragma_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPragma_name" ):
                return visitor.visitPragma_name(self)
            else:
                return visitor.visitChildren(self)




    def pragma_name(self):

        localctx = GrammarParser.Pragma_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_pragma_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1993
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Savepoint_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_savepoint_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSavepoint_name" ):
                return visitor.visitSavepoint_name(self)
            else:
                return visitor.visitChildren(self)




    def savepoint_name(self):

        localctx = GrammarParser.Savepoint_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_savepoint_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1995
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_aliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_table_alias

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_alias" ):
                return visitor.visitTable_alias(self)
            else:
                return visitor.visitChildren(self)




    def table_alias(self):

        localctx = GrammarParser.Table_aliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_table_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1997
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Transaction_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_transaction_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTransaction_name" ):
                return visitor.visitTransaction_name(self)
            else:
                return visitor.visitChildren(self)




    def transaction_name(self):

        localctx = GrammarParser.Transaction_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_transaction_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1999
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_window_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWindow_name" ):
                return visitor.visitWindow_name(self)
            else:
                return visitor.visitChildren(self)




    def window_name(self):

        localctx = GrammarParser.Window_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_window_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2001
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_alias

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAlias" ):
                return visitor.visitAlias(self)
            else:
                return visitor.visitChildren(self)




    def alias(self):

        localctx = GrammarParser.AliasContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_alias)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2003
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FilenameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_filename

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilename" ):
                return visitor.visitFilename(self)
            else:
                return visitor.visitChildren(self)




    def filename(self):

        localctx = GrammarParser.FilenameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_filename)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2005
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Base_window_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_base_window_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitBase_window_name" ):
                return visitor.visitBase_window_name(self)
            else:
                return visitor.visitChildren(self)




    def base_window_name(self):

        localctx = GrammarParser.Base_window_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_base_window_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2007
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Simple_funcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_simple_func

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitSimple_func" ):
                return visitor.visitSimple_func(self)
            else:
                return visitor.visitChildren(self)




    def simple_func(self):

        localctx = GrammarParser.Simple_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_simple_func)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2009
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Aggregate_funcContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_aggregate_func

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAggregate_func" ):
                return visitor.visitAggregate_func(self)
            else:
                return visitor.visitChildren(self)




    def aggregate_func(self):

        localctx = GrammarParser.Aggregate_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_aggregate_func)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2011
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_function_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def getRuleIndex(self):
            return GrammarParser.RULE_table_function_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTable_function_name" ):
                return visitor.visitTable_function_name(self)
            else:
                return visitor.visitChildren(self)




    def table_function_name(self):

        localctx = GrammarParser.Table_function_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_table_function_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2013
            self.any_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Any_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENTIFIER(self):
            return self.getToken(GrammarParser.IDENTIFIER, 0)

        def keyword(self):
            return self.getTypedRuleContext(GrammarParser.KeywordContext,0)


        def STRING_LITERAL(self):
            return self.getToken(GrammarParser.STRING_LITERAL, 0)

        def OPEN_PAR(self):
            return self.getToken(GrammarParser.OPEN_PAR, 0)

        def any_name(self):
            return self.getTypedRuleContext(GrammarParser.Any_nameContext,0)


        def CLOSE_PAR(self):
            return self.getToken(GrammarParser.CLOSE_PAR, 0)

        def getRuleIndex(self):
            return GrammarParser.RULE_any_name

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAny_name" ):
                return visitor.visitAny_name(self)
            else:
                return visitor.visitChildren(self)




    def any_name(self):

        localctx = GrammarParser.Any_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_any_name)
        try:
            self.state = 2022
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [GrammarParser.IDENTIFIER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2015
                self.match(GrammarParser.IDENTIFIER)
                pass
            elif token in [GrammarParser.ABORT_, GrammarParser.ACTION_, GrammarParser.ADD_, GrammarParser.AFTER_, GrammarParser.ALL_, GrammarParser.ALTER_, GrammarParser.ANALYZE_, GrammarParser.AND_, GrammarParser.AS_, GrammarParser.ASC_, GrammarParser.ATTACH_, GrammarParser.AUTOINCREMENT_, GrammarParser.BEFORE_, GrammarParser.BEGIN_, GrammarParser.BETWEEN_, GrammarParser.BY_, GrammarParser.CASCADE_, GrammarParser.CASE_, GrammarParser.CAST_, GrammarParser.CHECK_, GrammarParser.COLLATE_, GrammarParser.COLUMN_, GrammarParser.COMMIT_, GrammarParser.CONFLICT_, GrammarParser.CONSTRAINT_, GrammarParser.CREATE_, GrammarParser.CROSS_, GrammarParser.CURRENT_DATE_, GrammarParser.CURRENT_TIME_, GrammarParser.CURRENT_TIMESTAMP_, GrammarParser.DATABASE_, GrammarParser.DEFAULT_, GrammarParser.DEFERRABLE_, GrammarParser.DEFERRED_, GrammarParser.DELETE_, GrammarParser.DESC_, GrammarParser.DETACH_, GrammarParser.DISTINCT_, GrammarParser.DROP_, GrammarParser.EACH_, GrammarParser.ELSE_, GrammarParser.END_, GrammarParser.ESCAPE_, GrammarParser.EXCEPT_, GrammarParser.EXCLUSIVE_, GrammarParser.EXISTS_, GrammarParser.EXPLAIN_, GrammarParser.FAIL_, GrammarParser.FOR_, GrammarParser.FOREIGN_, GrammarParser.FROM_, GrammarParser.FULL_, GrammarParser.GLOB_, GrammarParser.GROUP_, GrammarParser.HAVING_, GrammarParser.IF_, GrammarParser.IGNORE_, GrammarParser.IMMEDIATE_, GrammarParser.IN_, GrammarParser.INDEX_, GrammarParser.INDEXED_, GrammarParser.INITIALLY_, GrammarParser.INNER_, GrammarParser.INSERT_, GrammarParser.INSTEAD_, GrammarParser.INTERSECT_, GrammarParser.INTO_, GrammarParser.IS_, GrammarParser.ISNULL_, GrammarParser.JOIN_, GrammarParser.KEY_, GrammarParser.LEFT_, GrammarParser.LIKE_, GrammarParser.LIMIT_, GrammarParser.MATCH_, GrammarParser.NATURAL_, GrammarParser.NO_, GrammarParser.NOT_, GrammarParser.NOTNULL_, GrammarParser.NULL_, GrammarParser.OF_, GrammarParser.OFFSET_, GrammarParser.ON_, GrammarParser.OR_, GrammarParser.ORDER_, GrammarParser.OUTER_, GrammarParser.PLAN_, GrammarParser.PRAGMA_, GrammarParser.PRIMARY_, GrammarParser.QUERY_, GrammarParser.RAISE_, GrammarParser.RECURSIVE_, GrammarParser.REFERENCES_, GrammarParser.REGEXP_, GrammarParser.REINDEX_, GrammarParser.RELEASE_, GrammarParser.RENAME_, GrammarParser.REPLACE_, GrammarParser.RESTRICT_, GrammarParser.RIGHT_, GrammarParser.ROLLBACK_, GrammarParser.ROW_, GrammarParser.ROWS_, GrammarParser.SAVEPOINT_, GrammarParser.SELECT_, GrammarParser.SET_, GrammarParser.TABLE_, GrammarParser.TEMP_, GrammarParser.TEMPORARY_, GrammarParser.THEN_, GrammarParser.TO_, GrammarParser.TRANSACTION_, GrammarParser.TRIGGER_, GrammarParser.UNION_, GrammarParser.UNIQUE_, GrammarParser.UPDATE_, GrammarParser.USING_, GrammarParser.VACUUM_, GrammarParser.VALUES_, GrammarParser.VIEW_, GrammarParser.VIRTUAL_, GrammarParser.WHEN_, GrammarParser.WHERE_, GrammarParser.WITH_, GrammarParser.WITHOUT_, GrammarParser.FIRST_VALUE_, GrammarParser.OVER_, GrammarParser.PARTITION_, GrammarParser.RANGE_, GrammarParser.PRECEDING_, GrammarParser.UNBOUNDED_, GrammarParser.CURRENT_, GrammarParser.FOLLOWING_, GrammarParser.CUME_DIST_, GrammarParser.DENSE_RANK_, GrammarParser.LAG_, GrammarParser.LAST_VALUE_, GrammarParser.LEAD_, GrammarParser.NTH_VALUE_, GrammarParser.NTILE_, GrammarParser.PERCENT_RANK_, GrammarParser.RANK_, GrammarParser.ROW_NUMBER_, GrammarParser.GENERATED_, GrammarParser.ALWAYS_, GrammarParser.STORED_, GrammarParser.TRUE_, GrammarParser.FALSE_, GrammarParser.WINDOW_, GrammarParser.NULLS_, GrammarParser.FIRST_, GrammarParser.LAST_, GrammarParser.FILTER_, GrammarParser.GROUPS_, GrammarParser.EXCLUDE_]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2016
                self.keyword()
                pass
            elif token in [GrammarParser.STRING_LITERAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2017
                self.match(GrammarParser.STRING_LITERAL)
                pass
            elif token in [GrammarParser.OPEN_PAR]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2018
                self.match(GrammarParser.OPEN_PAR)
                self.state = 2019
                self.any_name()
                self.state = 2020
                self.match(GrammarParser.CLOSE_PAR)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[31] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 18)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 4)
         




